{
  "version": 3,
  "sources": ["../../../../sigma/src/types.ts", "../../../../sigma/src/utils/easings.ts", "../../../../sigma/src/utils/animate.ts", "../../../../sigma/src/utils/colors.ts", "../../../../sigma/src/utils/matrices.ts", "../../../../sigma/src/utils/coordinates.ts", "../../../../sigma/src/utils/data.ts", "../../../../sigma/src/utils/graph.ts", "../../../../sigma/src/utils/misc.ts", "../../../../sigma/src/utils/normalization.ts", "../../../../sigma/src/core/camera.ts", "../../../../sigma/src/rendering/utils.ts", "../../../../sigma/src/rendering/program.ts", "../../../../sigma/src/rendering/node.ts", "../../../../sigma/src/rendering/edge.ts", "../../../../sigma/src/rendering/edge-labels.ts", "../../../../sigma/src/rendering/node-labels.ts", "../../../../sigma/src/rendering/node-hover.ts", "../../../../sigma/src/rendering/programs/node-circle/frag.glsl.ts", "../../../../sigma/src/rendering/programs/node-circle/vert.glsl.ts", "../../../../sigma/src/rendering/programs/node-circle/index.ts", "../../../../sigma/src/rendering/programs/node-point/index.ts", "../../../../sigma/src/rendering/programs/edge-arrow-head/frag.glsl.ts", "../../../../sigma/src/rendering/programs/edge-arrow-head/vert.glsl.ts", "../../../../sigma/src/rendering/programs/edge-arrow-head/index.ts", "../../../../sigma/src/rendering/programs/edge-rectangle/frag.glsl.ts", "../../../../sigma/src/rendering/programs/edge-clamped/vert.glsl.ts", "../../../../sigma/src/rendering/programs/edge-clamped/index.ts", "../../../../sigma/src/rendering/programs/edge-arrow/index.ts", "../../../../sigma/src/rendering/programs/edge-line/index.ts", "../../../../sigma/src/rendering/programs/edge-rectangle/vert.glsl.ts", "../../../../sigma/src/rendering/programs/edge-rectangle/index.ts", "../../../../sigma/src/rendering/programs/edge-triangle/index.ts", "../../../../sigma/src/settings.ts", "../../../../sigma/src/core/captors/captor.ts", "../../../../sigma/src/core/captors/mouse.ts", "../../../../sigma/src/core/captors/touch.ts", "../../../../sigma/src/core/labels.ts", "../../../../sigma/src/sigma.ts", "../../../../../node_modules/@react-sigma/core/src/hooks/context.ts", "../../../../../node_modules/@react-sigma/core/src/hooks/useSigma.ts", "../../../../../node_modules/@react-sigma/core/src/hooks/useSetSettings.ts", "../../../../../node_modules/@react-sigma/core/src/hooks/useRegisterEvents.ts", "../../../../../node_modules/@react-sigma/core/src/hooks/useLoadGraph.ts", "../../../../../node_modules/@react-sigma/core/src/utils.ts", "../../../../../node_modules/@react-sigma/core/src/hooks/useCamera.ts", "../../../../../node_modules/@react-sigma/core/src/hooks/useFullScreen.ts", "../../../../../node_modules/@react-sigma/core/src/components/SigmaContainer.tsx", "../../../../../node_modules/@react-sigma/core/src/components/controls/ControlsContainer.tsx", "../../../../../node_modules/@react-sigma/core/src/assets/icons/plus-solid.svg", "../../../../../node_modules/@react-sigma/core/src/assets/icons/minus-solid.svg", "../../../../../node_modules/@react-sigma/core/src/assets/icons/dot-circle-regular.svg", "../../../../../node_modules/@react-sigma/core/src/components/controls/ZoomControl.tsx", "../../../../../node_modules/@react-sigma/core/src/assets/icons/expand-solid.svg", "../../../../../node_modules/@react-sigma/core/src/assets/icons/compress-solid.svg", "../../../../../node_modules/@react-sigma/core/src/components/controls/FullScreenControl.tsx", "../../../../../node_modules/@react-sigma/core/src/components/controls/SearchControl.tsx"],
  "sourcesContent": ["/**\n * Sigma.js Types\n * ===============\n *\n * Various type declarations used throughout the library.\n * @module\n */\nimport { EventEmitter } from \"events\";\n\n/**\n * Util type to represent maps of typed elements, but implemented with\n * JavaScript objects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PlainObject<T = any> = { [k: string]: T };\n\n/**\n * Returns a type similar to T, but with the K set of properties of the type\n * T *required*, and the rest optional.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PartialButFor<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>> & { [others: string]: any };\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface CameraState extends Coordinates {\n  angle: number;\n  ratio: number;\n}\n\nexport type MouseInteraction = \"click\" | \"doubleClick\" | \"rightClick\" | \"wheel\" | \"down\" | \"up\" | \"leave\" | \"enter\";\n\nexport interface MouseCoords extends Coordinates {\n  sigmaDefaultPrevented: boolean;\n  preventSigmaDefault(): void;\n  original: MouseEvent | TouchEvent;\n}\n\nexport interface WheelCoords extends MouseCoords {\n  delta: number; // This will store the delta actually used by sigma\n}\n\nexport interface TouchCoords {\n  touches: Coordinates[];\n  previousTouches: Coordinates[];\n  sigmaDefaultPrevented: boolean;\n  preventSigmaDefault(): void;\n  original: TouchEvent;\n}\n\nexport interface Dimensions {\n  width: number;\n  height: number;\n}\n\nexport type Extent = [number, number];\n\nexport interface DisplayData {\n  label: string | null;\n  size: number;\n  color: string;\n  hidden: boolean;\n  forceLabel: boolean;\n  zIndex: number;\n  type: string;\n}\n\nexport interface NodeDisplayData extends Coordinates, DisplayData {\n  highlighted: boolean;\n}\nexport type EdgeDisplayData = DisplayData;\n\nexport type CoordinateConversionOverride = {\n  cameraState?: CameraState;\n  matrix?: Float32Array;\n  viewportDimensions?: Dimensions;\n  graphDimensions?: Dimensions;\n  padding?: number;\n};\n\nexport interface RenderParams {\n  width: number;\n  height: number;\n  sizeRatio: number;\n  zoomRatio: number;\n  pixelRatio: number;\n  cameraAngle: number;\n  correctionRatio: number;\n  matrix: Float32Array;\n  invMatrix: Float32Array;\n  downSizingRatio: number;\n  minEdgeThickness: number;\n  antiAliasingFeather: number;\n}\n\n/**\n * Custom event emitter types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Listener = (...args: any[]) => void;\nexport type EventsMapping = Record<string, Listener>;\n\ninterface ITypedEventEmitter<Events extends EventsMapping> {\n  rawEmitter: EventEmitter;\n\n  eventNames<Event extends keyof Events>(): Array<Event>;\n  setMaxListeners(n: number): this;\n  getMaxListeners(): number;\n  emit<Event extends keyof Events>(type: Event, ...args: Parameters<Events[Event]>): boolean;\n  addListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  on<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  once<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  prependListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  prependOnceListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  removeListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  off<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  removeAllListeners<Event extends keyof Events>(type?: Event): this;\n  listeners<Event extends keyof Events>(type: Event): Events[Event][];\n  listenerCount<Event extends keyof Events>(type: Event): number;\n  rawListeners<Event extends keyof Events>(type: Event): Events[Event][];\n}\n\nexport class TypedEventEmitter<Events extends EventsMapping> extends (EventEmitter as unknown as {\n  new <T extends EventsMapping>(): ITypedEventEmitter<T>;\n})<Events> {\n  constructor() {\n    super();\n    this.rawEmitter = this as EventEmitter;\n  }\n}\n\n/**\n * Event types.\n */\nexport interface SigmaEventPayload {\n  event: MouseCoords;\n  preventSigmaDefault(): void;\n}\n\nexport type SigmaStageEventPayload = SigmaEventPayload;\nexport interface SigmaNodeEventPayload extends SigmaEventPayload {\n  node: string;\n}\nexport interface SigmaEdgeEventPayload extends SigmaEventPayload {\n  edge: string;\n}\n\nexport type SigmaStageEvents = {\n  [E in MouseInteraction as `${E}Stage`]: (payload: SigmaStageEventPayload) => void;\n};\n\nexport type SigmaNodeEvents = {\n  [E in MouseInteraction as `${E}Node`]: (payload: SigmaNodeEventPayload) => void;\n};\n\nexport type SigmaEdgeEvents = {\n  [E in MouseInteraction as `${E}Edge`]: (payload: SigmaEdgeEventPayload) => void;\n};\n\nexport type SigmaAdditionalEvents = {\n  // Lifecycle events\n  beforeClear(): void;\n  afterClear(): void;\n  beforeProcess(): void;\n  afterProcess(): void;\n  beforeRender(): void;\n  afterRender(): void;\n  resize(): void;\n  kill(): void;\n  // Body events\n  moveBody(payload: SigmaStageEventPayload): void;\n};\n\nexport type SigmaEvents = SigmaStageEvents & SigmaNodeEvents & SigmaEdgeEvents & SigmaAdditionalEvents;\nexport type SigmaEventType = keyof SigmaEvents;\n\n/**\n * Export various other types:\n */\nexport type { CameraEvents } from \"./core/camera\";\nexport type { MouseCaptorEvents } from \"./core/captors/mouse\";\nexport type { TouchCaptorEvents } from \"./core/captors/touch\";\n", "export const linear = (k: number): number => k;\n\nexport const quadraticIn = (k: number): number => k * k;\n\nexport const quadraticOut = (k: number): number => k * (2 - k);\n\nexport const quadraticInOut = (k: number): number => {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\n\nexport const cubicIn = (k: number): number => k * k * k;\n\nexport const cubicOut = (k: number): number => --k * k * k + 1;\n\nexport const cubicInOut = (k: number): number => {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\n\nexport const easings: { [key: string]: (k: number) => number } = {\n  linear,\n  quadraticIn,\n  quadraticOut,\n  quadraticInOut,\n  cubicIn,\n  cubicOut,\n  cubicInOut,\n};\n", "import Graph from \"graphology-types\";\n\nimport { PlainObject } from \"../types\";\nimport { easings } from \"./easings\";\n\n/**\n * Defaults.\n */\nexport type Easing = keyof typeof easings | ((k: number) => number);\n\nexport interface AnimateOptions {\n  easing: Easing;\n  duration: number;\n}\nexport const ANIMATE_DEFAULTS = {\n  easing: \"quadraticInOut\",\n  duration: 150,\n};\n\n/**\n * Function used to animate the nodes.\n */\nexport function animateNodes(\n  graph: Graph,\n  targets: PlainObject<PlainObject<number>>,\n  opts: Partial<AnimateOptions>,\n  callback?: () => void,\n): () => void {\n  const options: AnimateOptions = Object.assign({}, ANIMATE_DEFAULTS, opts);\n\n  const easing: (k: number) => number = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n  const start = Date.now();\n\n  const startPositions: PlainObject<PlainObject<number>> = {};\n\n  for (const node in targets) {\n    const attrs = targets[node];\n    startPositions[node] = {};\n\n    for (const k in attrs) startPositions[node][k] = graph.getNodeAttribute(node, k);\n  }\n\n  let frame: number | null = null;\n\n  const step = () => {\n    frame = null;\n\n    let p = (Date.now() - start) / options.duration;\n\n    if (p >= 1) {\n      // Animation is done\n      for (const node in targets) {\n        const attrs = targets[node];\n\n        // We use given values to avoid precision issues and for convenience\n        for (const k in attrs) graph.setNodeAttribute(node, k, attrs[k]);\n      }\n\n      if (typeof callback === \"function\") callback();\n\n      return;\n    }\n\n    p = easing(p);\n\n    for (const node in targets) {\n      const attrs = targets[node];\n      const s = startPositions[node];\n\n      for (const k in attrs) graph.setNodeAttribute(node, k, attrs[k] * p + s[k] * (1 - p));\n    }\n\n    frame = requestAnimationFrame(step);\n  };\n\n  step();\n\n  return () => {\n    if (frame) cancelAnimationFrame(frame);\n  };\n}\n", "export const HTML_COLORS: Record<string, string> = {\n  black: \"#000000\",\n  silver: \"#C0C0C0\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  white: \"#FFFFFF\",\n  maroon: \"#800000\",\n  red: \"#FF0000\",\n  purple: \"#800080\",\n  fuchsia: \"#FF00FF\",\n  green: \"#008000\",\n  lime: \"#00FF00\",\n  olive: \"#808000\",\n  yellow: \"#FFFF00\",\n  navy: \"#000080\",\n  blue: \"#0000FF\",\n  teal: \"#008080\",\n  aqua: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  darkgreen: \"#006400\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  springgreen: \"#00FF7F\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  rebeccapurple: \"#663399\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370DB\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  darkgrey: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgray: \"#D3D3D3\",\n  lightgrey: \"#D3D3D3\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  palevioletred: \"#DB7093\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\",\n};\n\n/**\n * Function extracting the color at the given pixel.\n */\nexport function extractPixel(gl: WebGLRenderingContext, x: number, y: number, array: Uint8Array): Uint8Array {\n  const data = array || new Uint8Array(4);\n\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n  return data;\n}\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nconst INT8 = new Int8Array(4);\nconst INT32 = new Int32Array(INT8.buffer, 0, 1);\nconst FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\n\nconst RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nconst RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\n\ntype RGBAColor = { r: number; g: number; b: number; a: number };\n\nexport function parseColor(val: string): RGBAColor {\n  let r = 0; // byte\n  let g = 0; // byte\n  let b = 0; // byte\n  let a = 1; // float\n\n  // Handling hexadecimal notation\n  if (val[0] === \"#\") {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n    if (val.length === 9) {\n      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;\n    }\n  }\n\n  // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n    const match = val.match(RGBA_EXTRACT_REGEX);\n    if (match) {\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n\n      if (match[4]) a = +match[4];\n    }\n  }\n\n  return { r, g, b, a };\n}\n\nconst FLOAT_COLOR_CACHE: { [key: string]: number } = {};\nfor (const htmlColor in HTML_COLORS) {\n  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);\n  // Replicating cache for hex values for free\n  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];\n}\n\nexport function rgbaToFloat(r: number, g: number, b: number, a: number, masking?: boolean): number {\n  INT32[0] = (a << 24) | (b << 16) | (g << 8) | r;\n  if (masking) INT32[0] = INT32[0] & 0xfeffffff;\n  return FLOAT32[0];\n}\nexport function floatColor(val: string): number {\n  // The html color names are case-insensitive\n  val = val.toLowerCase();\n\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\") return FLOAT_COLOR_CACHE[val];\n\n  const parsed = parseColor(val);\n  const { r, g, b } = parsed;\n  let { a } = parsed;\n  a = (a * 255) | 0;\n\n  const color = rgbaToFloat(r, g, b, a, true);\n\n  FLOAT_COLOR_CACHE[val] = color;\n\n  return color;\n}\nexport function colorToArray(val: string, masking?: boolean): [number, number, number, number] {\n  FLOAT32[0] = floatColor(val);\n  let intValue = INT32[0];\n\n  if (masking) {\n    intValue = intValue | 0x01000000;\n  }\n\n  const r = intValue & 0xff;\n  const g = (intValue >> 8) & 0xff;\n  const b = (intValue >> 16) & 0xff;\n  const a = (intValue >> 24) & 0xff;\n\n  return [r, g, b, a];\n}\n\nconst FLOAT_INDEX_CACHE: { [key: number]: number } = {};\nexport function indexToColor(index: number): number {\n  // If the index is already computed, we yield it\n  if (typeof FLOAT_INDEX_CACHE[index] !== \"undefined\") return FLOAT_INDEX_CACHE[index];\n\n  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,\n  // but with alpha hard-set to 1.0 (or 255):\n  const r = (index & 0x00ff0000) >>> 16;\n  const g = (index & 0x0000ff00) >>> 8;\n  const b = index & 0x000000ff;\n  const a = 0x000000ff;\n\n  // The original 4 bytes color encoding was the following:\n  // const r = (index & 0xff000000) >>> 24;\n  // const g = (index & 0x00ff0000) >>> 16;\n  // const b = (index & 0x0000ff00) >>> 8;\n  // const a = index & 0x000000ff;\n\n  const color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_INDEX_CACHE[index] = color;\n\n  return color;\n}\n\nexport function colorToIndex(r: number, g: number, b: number, _a: number): number {\n  // As for the function indexToColor, because of #1397 and the \"alpha is always\n  // 1.0\" strategy, we need to fix this function as well:\n  return b + (g << 8) + (r << 16);\n\n  // The original 4 bytes color decoding is the following:\n  // return a + (b << 8) + (g << 16) + (r << 24);\n}\n\nexport function getPixelColor(\n  gl: WebGLRenderingContext,\n  frameBuffer: WebGLBuffer | null,\n  x: number,\n  y: number,\n  pixelRatio: number,\n  downSizingRatio: number,\n): [number, number, number, number] {\n  const bufferX = Math.floor((x / downSizingRatio) * pixelRatio);\n  const bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - (y / downSizingRatio) * pixelRatio);\n\n  const pixel = new Uint8Array(4);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n  const [r, g, b, a] = pixel;\n  return [r, g, b, a];\n}\n", "import { Coordinates } from \"../types\";\n\nexport function identity(): Float32Array {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n}\n\n// TODO: optimize\nexport function scale(m: Float32Array, x: number, y?: number): Float32Array {\n  m[0] = x;\n  m[4] = typeof y === \"number\" ? y : x;\n\n  return m;\n}\n\nexport function rotate(m: Float32Array, r: number): Float32Array {\n  const s = Math.sin(r),\n    c = Math.cos(r);\n\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n\n  return m;\n}\n\nexport function translate(m: Float32Array, x: number, y: number): Float32Array {\n  m[6] = x;\n  m[7] = y;\n\n  return m;\n}\n\nexport function multiply<T extends number[] | Float32Array>(a: T, b: Float32Array | number[]): T {\n  const a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  const a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  const a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n\n  const b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  const b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  const b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\n  return a;\n}\n\nexport function multiplyVec2(a: Float32Array | number[], b: Coordinates, z = 1): Coordinates {\n  const a00 = a[0];\n  const a01 = a[1];\n  const a10 = a[3];\n  const a11 = a[4];\n  const a20 = a[6];\n  const a21 = a[7];\n\n  const b0 = b.x;\n  const b1 = b.y;\n\n  return { x: b0 * a00 + b1 * a10 + a20 * z, y: b0 * a01 + b1 * a11 + a21 * z };\n}\n", "import { CameraState, Dimensions } from \"../types\";\nimport { identity, multiply, multiplyVec2, rotate, scale, translate } from \"./matrices\";\n\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps to deal with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\nexport function getCorrectionRatio(\n  viewportDimensions: { width: number; height: number },\n  graphDimensions: { width: number; height: number },\n): number {\n  const viewportRatio = viewportDimensions.height / viewportDimensions.width;\n  const graphRatio = graphDimensions.height / graphDimensions.width;\n\n  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n  if ((viewportRatio < 1 && graphRatio > 1) || (viewportRatio > 1 && graphRatio < 1)) {\n    return 1;\n  }\n\n  // Else, we need to fit the graph inside the stage:\n  // 1. If the graph is \"squarer\" (i.e. with a ratio closer to 1), we need to make the largest sides touch;\n  // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\n\n/**\n * Function returning a matrix from the current state of the camera.\n */\nexport function matrixFromCamera(\n  state: CameraState,\n  viewportDimensions: { width: number; height: number },\n  graphDimensions: { width: number; height: number },\n  padding: number,\n  inverse?: boolean,\n): Float32Array {\n  // TODO: it's possible to optimize this drastically!\n  const { angle, ratio, x, y } = state;\n\n  const { width, height } = viewportDimensions;\n\n  const matrix = identity();\n\n  const smallestDimension = Math.min(width, height) - 2 * padding;\n\n  const correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n\n  if (!inverse) {\n    multiply(\n      matrix,\n      scale(\n        identity(),\n        2 * (smallestDimension / width) * correctionRatio,\n        2 * (smallestDimension / height) * correctionRatio,\n      ),\n    );\n    multiply(matrix, rotate(identity(), -angle));\n    multiply(matrix, scale(identity(), 1 / ratio));\n    multiply(matrix, translate(identity(), -x, -y));\n  } else {\n    multiply(matrix, translate(identity(), x, y));\n    multiply(matrix, scale(identity(), ratio));\n    multiply(matrix, rotate(identity(), angle));\n    multiply(\n      matrix,\n      scale(\n        identity(),\n        width / smallestDimension / 2 / correctionRatio,\n        height / smallestDimension / 2 / correctionRatio,\n      ),\n    );\n  }\n\n  return matrix;\n}\n\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (i.e. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because the image is vertically\n * swapped in WebGL.\n */\nexport function getMatrixImpact(\n  matrix: Float32Array,\n  cameraState: CameraState,\n  viewportDimensions: Dimensions,\n): number {\n  const { x, y } = multiplyVec2(matrix, { x: Math.cos(cameraState.angle), y: Math.sin(cameraState.angle) }, 0);\n  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\n", "/**\n * Extends the target array with the given values.\n */\nexport function extend<T>(array: T[], values: Set<T>): void {\n  const l2 = values.size;\n\n  if (l2 === 0) return;\n\n  const l1 = array.length;\n\n  array.length += l2;\n\n  let i = 0;\n  values.forEach((value) => {\n    array[l1 + i] = value;\n    i++;\n  });\n}\n\n/**\n * Checks whether the given value is a plain object.\n */\nexport function isPlainObject(value: unknown): boolean {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\n\n/**\n * Helper to use `Object.assign` with more than two objects.\n */\nexport function assign<T>(target: Partial<T> | undefined, ...objects: Array<Partial<T | undefined>>): T {\n  target = target || {};\n\n  for (let i = 0, l = objects.length; i < l; i++) {\n    const o = objects[i];\n\n    if (!o) continue;\n\n    Object.assign(target, o);\n  }\n\n  return target as T;\n}\n\n/**\n * Very simple recursive `Object.assign` like function.\n */\nexport function assignDeep<T>(target: Partial<T> | undefined, ...objects: Array<Partial<T | undefined>>): T {\n  target = target || {};\n\n  for (let i = 0, l = objects.length; i < l; i++) {\n    const o = objects[i];\n\n    if (!o) continue;\n\n    for (const k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assignDeep(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n\n  return target as T;\n}\n", "import Graph, { Attributes } from \"graphology-types\";\nimport isGraph from \"graphology-utils/is-graph\";\n\nimport { Extent } from \"../types\";\n\n/**\n * Function returning the graph's node extent in x & y.\n */\nexport function graphExtent(graph: Graph): { x: Extent; y: Extent } {\n  if (!graph.order) return { x: [0, 1], y: [0, 1] };\n\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let yMin = Infinity;\n  let yMax = -Infinity;\n\n  graph.forEachNode((_, attr) => {\n    const { x, y } = attr;\n\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  });\n\n  return { x: [xMin, xMax], y: [yMin, yMax] };\n}\n\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\nexport function validateGraph(graph: Graph): void {\n  // check if it's a valid graphology instance\n  if (!isGraph(graph)) throw new Error(\"Sigma: invalid graph instance.\");\n\n  // check if nodes have x/y attributes\n  graph.forEachNode((key: string, attributes: Attributes) => {\n    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n      throw new Error(\n        `Sigma: Coordinates of node ${key} are invalid. A node must have a numeric 'x' and 'y' attribute.`,\n      );\n    }\n  });\n}\n", "import { Extent, PlainObject } from \"../types\";\n\n/**\n * Function used to create DOM elements easily.\n */\nexport function createElement<T extends HTMLElement>(\n  tag: string,\n  style?: Partial<CSSStyleDeclaration>,\n  attributes?: PlainObject<string>,\n): T {\n  const element: T = document.createElement(tag) as T;\n\n  if (style) {\n    for (const k in style) {\n      element.style[k] = style[k] as string;\n    }\n  }\n\n  if (attributes) {\n    for (const k in attributes) {\n      element.setAttribute(k, attributes[k]);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Function returning the browser's pixel ratio.\n */\nexport function getPixelRatio(): number {\n  if (typeof window.devicePixelRatio !== \"undefined\") return window.devicePixelRatio;\n\n  return 1;\n}\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n */\nexport function zIndexOrdering<T>(_extent: Extent, getter: (e: T) => number, elements: Array<T>): Array<T> {\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    const zA = getter(a) || 0,\n      zB = getter(b) || 0;\n\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n\n    return 0;\n  });\n\n  // TODO: counting sort optimization\n}\n", "import { Coordinates, Extent } from \"../types\";\n\n/**\n * Factory returning a function normalizing the given node's position & size.\n */\nexport interface NormalizationFunction {\n  (data: Coordinates): Coordinates;\n  ratio: number;\n  inverse(data: Coordinates): Coordinates;\n  applyTo(data: Coordinates): void;\n}\nexport function createNormalizationFunction(extent: { x: Extent; y: Extent }): NormalizationFunction {\n  const {\n    x: [minX, maxX],\n    y: [minY, maxY],\n  } = extent;\n\n  let ratio = Math.max(maxX - minX, maxY - minY),\n    dX = (maxX + minX) / 2,\n    dY = (maxY + minY) / 2;\n\n  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;\n  if (isNaN(dX)) dX = 0;\n  if (isNaN(dY)) dY = 0;\n\n  const fn = (data: Coordinates): Coordinates => {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio,\n    };\n  };\n\n  // TODO: possibility to apply this in batch over array of indices\n  fn.applyTo = (data: Coordinates): void => {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n\n  fn.inverse = (data: Coordinates): Coordinates => {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5),\n    };\n  };\n\n  fn.ratio = ratio;\n\n  return fn;\n}\n", "/**\n * Sigma.js Camera Class\n * ======================\n *\n * Class designed to store camera information & used to update it.\n * @module\n */\nimport { CameraState, TypedEventEmitter } from \"../types\";\nimport { ANIMATE_DEFAULTS, AnimateOptions, easings } from \"../utils\";\n\n/**\n * Defaults.\n */\nconst DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\nexport type CameraEvents = {\n  updated(state: CameraState): void;\n};\n\n/**\n * Camera class\n */\nexport default class Camera extends TypedEventEmitter<CameraEvents> implements CameraState {\n  x = 0.5;\n  y = 0.5;\n  angle = 0;\n  ratio = 1;\n\n  minRatio: number | null = null;\n  maxRatio: number | null = null;\n  enabledRotation = true;\n\n  private nextFrame: number | null = null;\n  private previousState: CameraState | null = null;\n  private enabled = true;\n\n  animationCallback?: () => void;\n\n  constructor() {\n    super();\n\n    // State\n    this.previousState = this.getState();\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   */\n  static from(state: CameraState): Camera {\n    const camera = new Camera();\n    return camera.setState(state);\n  }\n\n  /**\n   * Method used to enable the camera.\n   */\n  enable(): this {\n    this.enabled = true;\n    return this;\n  }\n\n  /**\n   * Method used to disable the camera.\n   */\n  disable(): this {\n    this.enabled = false;\n    return this;\n  }\n\n  /**\n   * Method used to retrieve the camera's current state.\n   */\n  getState(): CameraState {\n    return {\n      x: this.x,\n      y: this.y,\n      angle: this.angle,\n      ratio: this.ratio,\n    };\n  }\n\n  /**\n   * Method used to check whether the camera has the given state.\n   */\n  hasState(state: CameraState): boolean {\n    return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n  }\n\n  /**\n   * Method used to retrieve the camera's previous state.\n   */\n  getPreviousState(): CameraState | null {\n    const state = this.previousState;\n\n    if (!state) return null;\n\n    return {\n      x: state.x,\n      y: state.y,\n      angle: state.angle,\n      ratio: state.ratio,\n    };\n  }\n\n  /**\n   * Method used to check minRatio and maxRatio values.\n   */\n  getBoundedRatio(ratio: number): number {\n    let r = ratio;\n    if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n    if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n    return r;\n  }\n\n  /**\n   * Method used to check various things to return a legit state candidate.\n   */\n  validateState(state: Partial<CameraState>): Partial<CameraState> {\n    const validatedState: Partial<CameraState> = {};\n    if (typeof state.x === \"number\") validatedState.x = state.x;\n    if (typeof state.y === \"number\") validatedState.y = state.y;\n    if (this.enabledRotation && typeof state.angle === \"number\") validatedState.angle = state.angle;\n    if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n    return validatedState;\n  }\n\n  /**\n   * Method used to check whether the camera is currently being animated.\n   */\n  isAnimated(): boolean {\n    return !!this.nextFrame;\n  }\n\n  /**\n   * Method used to set the camera's state.\n   */\n  setState(state: Partial<CameraState>): this {\n    if (!this.enabled) return this;\n\n    // Keeping track of last state\n    this.previousState = this.getState();\n\n    const validState = this.validateState(state);\n    if (typeof validState.x === \"number\") this.x = validState.x;\n    if (typeof validState.y === \"number\") this.y = validState.y;\n    if (this.enabledRotation && typeof validState.angle === \"number\") this.angle = validState.angle;\n    if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n    // Emitting\n    if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n\n    return this;\n  }\n\n  /**\n   * Method used to update the camera's state using a function.\n   */\n  updateState(updater: (state: CameraState) => Partial<CameraState>): this {\n    this.setState(updater(this.getState()));\n    return this;\n  }\n\n  /**\n   * Method used to animate the camera.\n   */\n  animate(state: Partial<CameraState>, opts: Partial<AnimateOptions>, callback: () => void): void;\n  animate(state: Partial<CameraState>, opts?: Partial<AnimateOptions>): Promise<void>;\n  animate(\n    state: Partial<CameraState>,\n    opts: Partial<AnimateOptions> = {},\n    callback?: () => void,\n  ): void | Promise<void> {\n    if (!callback) return new Promise((resolve) => this.animate(state, opts, resolve));\n\n    if (!this.enabled) return;\n\n    const options: AnimateOptions = {\n      ...ANIMATE_DEFAULTS,\n      ...opts,\n    };\n    const validState = this.validateState(state);\n\n    const easing: (k: number) => number =\n      typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n    // State\n    const start = Date.now(),\n      initialState = this.getState();\n\n    // Function performing the animation\n    const fn = () => {\n      const t = (Date.now() - start) / options.duration;\n\n      // The animation is over:\n      if (t >= 1) {\n        this.nextFrame = null;\n        this.setState(validState);\n\n        if (this.animationCallback) {\n          this.animationCallback.call(null);\n          this.animationCallback = undefined;\n        }\n\n        return;\n      }\n\n      const coefficient = easing(t);\n\n      const newState: Partial<CameraState> = {};\n\n      if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n      if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n      if (this.enabledRotation && typeof validState.angle === \"number\")\n        newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n      if (typeof validState.ratio === \"number\")\n        newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n\n      this.setState(newState);\n\n      this.nextFrame = requestAnimationFrame(fn);\n    };\n\n    if (this.nextFrame) {\n      cancelAnimationFrame(this.nextFrame);\n      if (this.animationCallback) this.animationCallback.call(null);\n      this.nextFrame = requestAnimationFrame(fn);\n    } else {\n      fn();\n    }\n\n    this.animationCallback = callback;\n  }\n\n  /**\n   * Method used to zoom the camera.\n   */\n  animatedZoom(factorOrOptions?: number | (Partial<AnimateOptions> & { factor?: number })): Promise<void> {\n    if (!factorOrOptions) return this.animate({ ratio: this.ratio / DEFAULT_ZOOMING_RATIO });\n\n    if (typeof factorOrOptions === \"number\") return this.animate({ ratio: this.ratio / factorOrOptions });\n\n    return this.animate(\n      {\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n      },\n      factorOrOptions,\n    );\n  }\n\n  /**\n   * Method used to unzoom the camera.\n   */\n  animatedUnzoom(factorOrOptions?: number | (Partial<AnimateOptions> & { factor?: number })): Promise<void> {\n    if (!factorOrOptions) return this.animate({ ratio: this.ratio * DEFAULT_ZOOMING_RATIO });\n\n    if (typeof factorOrOptions === \"number\") return this.animate({ ratio: this.ratio * factorOrOptions });\n\n    return this.animate(\n      {\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n      },\n      factorOrOptions,\n    );\n  }\n\n  /**\n   * Method used to reset the camera.\n   */\n  animatedReset(options?: Partial<AnimateOptions>): Promise<void> {\n    return this.animate(\n      {\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Returns a new Camera instance, with the same state as the current camera.\n   */\n  copy(): Camera {\n    return Camera.from(this.getState());\n  }\n}\n", "export function getAttributeItemsCount(attr: ProgramAttributeSpecification): number {\n  return attr.normalized ? 1 : attr.size;\n}\nexport function getAttributesItemsCount(attrs: ProgramAttributeSpecification[]): number {\n  let res = 0;\n  attrs.forEach((attr) => (res += getAttributeItemsCount(attr)));\n  return res;\n}\n\nexport interface ProgramInfo<Uniform extends string = string> {\n  name: string;\n  isPicking: boolean;\n  program: WebGLProgram;\n  gl: WebGLRenderingContext | WebGL2RenderingContext;\n  frameBuffer: WebGLFramebuffer | null;\n  buffer: WebGLBuffer;\n  constantBuffer: WebGLBuffer;\n  uniformLocations: Record<Uniform, WebGLUniformLocation>;\n  attributeLocations: Record<string, number>; // Record<string, GLint>\n  vertexShader: WebGLShader;\n  fragmentShader: WebGLShader;\n}\n\nexport interface ProgramAttributeSpecification {\n  name: string;\n  size: number;\n  type: number;\n  normalized?: boolean;\n}\n\nexport interface ProgramDefinition<Uniform extends string = string> {\n  VERTICES: number;\n  VERTEX_SHADER_SOURCE: string;\n  FRAGMENT_SHADER_SOURCE: string;\n  UNIFORMS: ReadonlyArray<Uniform>;\n  ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  METHOD: number; // GLenum\n}\n\nexport interface InstancedProgramDefinition<Uniform extends string = string> extends ProgramDefinition<Uniform> {\n  CONSTANT_ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  CONSTANT_DATA: number[][];\n}\n\nfunction loadShader(type: string, gl: WebGLRenderingContext, source: string): WebGLShader {\n  const glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  const shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(`loadShader: error while creating the shader`);\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  const successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    const infoLog = gl.getShaderInfoLog(shader);\n\n    gl.deleteShader(shader);\n    throw new Error(`loadShader: error while compiling the shader:\\n${infoLog}\\n${source}`);\n  }\n\n  return shader;\n}\n\nexport function loadVertexShader(gl: WebGLRenderingContext, source: string): WebGLShader {\n  return loadShader(\"VERTEX\", gl, source);\n}\nexport function loadFragmentShader(gl: WebGLRenderingContext, source: string): WebGLShader {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nexport function loadProgram(gl: WebGLRenderingContext, shaders: Array<WebGLShader>): WebGLProgram {\n  const program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n\n  let i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n\n  gl.linkProgram(program);\n\n  // Checking status\n  const successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n\n  return program;\n}\n\nexport function killProgram({ gl, buffer, program, vertexShader, fragmentShader }: ProgramInfo): void {\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  gl.deleteProgram(program);\n  gl.deleteBuffer(buffer);\n}\n\n/**\n * Function use to print a float for inserting in a GLSL program.\n */\nexport function numberToGLSLFloat(n: number): string {\n  return n % 1 === 0 ? n.toFixed(1) : n.toString();\n}\n", "/**\n * Sigma.js WebGL Renderer Program\n * ================================\n *\n * Class representing a single WebGL program used by sigma's WebGL renderer.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport type Sigma from \"../sigma\";\nimport type { RenderParams } from \"../types\";\nimport {\n  InstancedProgramDefinition,\n  ProgramAttributeSpecification,\n  ProgramDefinition,\n  ProgramInfo,\n  getAttributesItemsCount,\n  killProgram,\n  loadFragmentShader,\n  loadProgram,\n  loadVertexShader,\n} from \"./utils\";\n\nconst PICKING_PREFIX = `#define PICKING_MODE\\n`;\n\nconst SIZE_FACTOR_PER_ATTRIBUTE_TYPE: Record<number, number> = {\n  [WebGL2RenderingContext.BOOL]: 1,\n  [WebGL2RenderingContext.BYTE]: 1,\n  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,\n  [WebGL2RenderingContext.SHORT]: 2,\n  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,\n  [WebGL2RenderingContext.INT]: 4,\n  [WebGL2RenderingContext.UNSIGNED_INT]: 4,\n  [WebGL2RenderingContext.FLOAT]: 4,\n};\n\nexport abstract class AbstractProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> {\n  constructor(_gl: WebGLRenderingContext, _pickGl: WebGLRenderingContext, _renderer: Sigma<N, E, G>) {}\n  abstract reallocate(capacity: number): void;\n  abstract render(params: RenderParams): void;\n  abstract kill(): void;\n}\n\nexport abstract class Program<\n    Uniform extends string = string,\n    N extends Attributes = Attributes,\n    E extends Attributes = Attributes,\n    G extends Attributes = Attributes,\n  >\n  implements AbstractProgram<N, E, G>, InstancedProgramDefinition\n{\n  VERTICES: number;\n  VERTEX_SHADER_SOURCE: string;\n  FRAGMENT_SHADER_SOURCE: string;\n  UNIFORMS: ReadonlyArray<Uniform>;\n  ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  METHOD: number; // GLenum\n  CONSTANT_ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  CONSTANT_DATA: number[][];\n\n  ATTRIBUTES_ITEMS_COUNT: number;\n  STRIDE: number;\n\n  renderer: Sigma<N, E, G>;\n  array: Float32Array = new Float32Array();\n  constantArray: Float32Array = new Float32Array();\n  capacity = 0;\n  verticesCount = 0;\n\n  normalProgram: ProgramInfo;\n  pickProgram: ProgramInfo | null;\n\n  isInstanced: boolean;\n\n  abstract getDefinition(): ProgramDefinition<Uniform> | InstancedProgramDefinition<Uniform>;\n\n  constructor(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    pickingBuffer: WebGLFramebuffer | null,\n    renderer: Sigma<N, E, G>,\n  ) {\n    // Reading and caching program definition\n    const def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer\n      ? this.getProgramInfo(\n          \"pick\",\n          gl,\n          PICKING_PREFIX + def.VERTEX_SHADER_SOURCE,\n          PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE,\n          pickingBuffer,\n        )\n      : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      const constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n\n      if (this.CONSTANT_DATA.length !== this.VERTICES)\n        throw new Error(\n          `Program: error while getting constant data (expected ${this.VERTICES} items, received ${this.CONSTANT_DATA.length} instead)`,\n        );\n\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (let i = 0; i < this.CONSTANT_DATA.length; i++) {\n        const vector = this.CONSTANT_DATA[i];\n\n        if (vector.length !== constantAttributesItemsCount)\n          throw new Error(\n            `Program: error while getting constant data (one vector has ${vector.length} items instead of ${constantAttributesItemsCount})`,\n          );\n\n        for (let j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n\n  kill() {\n    killProgram(this.normalProgram);\n\n    if (this.pickProgram) {\n      killProgram(this.pickProgram);\n      this.pickProgram = null;\n    }\n  }\n\n  protected getProgramInfo(\n    name: \"normal\" | \"pick\",\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    vertexShaderSource: string,\n    fragmentShaderSource: string,\n    frameBuffer: WebGLFramebuffer | null,\n  ): ProgramInfo {\n    const def = this.getDefinition();\n\n    // WebGL buffers\n    const buffer = gl.createBuffer();\n    if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n    // Shaders and program\n    const vertexShader = loadVertexShader(gl, vertexShaderSource);\n    const fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n    const program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n    // Initializing locations\n    const uniformLocations = {} as ProgramInfo[\"uniformLocations\"];\n    def.UNIFORMS.forEach((uniformName) => {\n      const location = gl.getUniformLocation(program, uniformName);\n      if (location) uniformLocations[uniformName] = location;\n    });\n\n    const attributeLocations = {} as ProgramInfo[\"attributeLocations\"];\n    def.ATTRIBUTES.forEach((attr) => {\n      attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n    });\n\n    // For instanced programs:\n    let constantBuffer;\n    if (\"CONSTANT_ATTRIBUTES\" in def) {\n      def.CONSTANT_ATTRIBUTES.forEach((attr) => {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      constantBuffer = gl.createBuffer();\n      if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n    }\n\n    return {\n      name,\n      program,\n      gl,\n      frameBuffer,\n      buffer,\n      constantBuffer: constantBuffer || ({} as WebGLBuffer),\n      uniformLocations,\n      attributeLocations,\n      isPicking: name === \"pick\",\n      vertexShader,\n      fragmentShader,\n    };\n  }\n\n  protected bindProgram(program: ProgramInfo): void {\n    let offset = 0;\n\n    const { gl, buffer } = program;\n    if (!this.isInstanced) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n      offset = 0;\n      this.ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    } else {\n      // Handle constant data (things that remain unchanged for all items):\n      gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n\n      offset = 0;\n      this.CONSTANT_ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset, false)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n      // Handle \"instance specific\" data (things that vary for each item):\n      gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n\n      offset = 0;\n      this.ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset, true)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  protected unbindProgram(program: ProgramInfo): void {\n    if (!this.isInstanced) {\n      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program));\n    } else {\n      this.CONSTANT_ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, false));\n      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, true));\n    }\n  }\n\n  protected bindAttribute(\n    attr: ProgramAttributeSpecification,\n    program: ProgramInfo,\n    offset: number,\n    setDivisor?: boolean,\n  ): number {\n    const sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n    if (typeof sizeFactor !== \"number\") throw new Error(`Program.bind: yet unsupported attribute type \"${attr.type}\"`);\n\n    const location = program.attributeLocations[attr.name];\n    const gl = program.gl;\n\n    if (location !== -1) {\n      gl.enableVertexAttribArray(location);\n\n      const stride = !this.isInstanced\n        ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT\n        : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) *\n          Float32Array.BYTES_PER_ELEMENT;\n\n      gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n\n      if (this.isInstanced && setDivisor) {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.vertexAttribDivisor(location, 1);\n        } else {\n          const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n        }\n      }\n    }\n\n    return attr.size * sizeFactor;\n  }\n\n  protected unbindAttribute(attr: ProgramAttributeSpecification, program: ProgramInfo, unsetDivisor?: boolean) {\n    const location = program.attributeLocations[attr.name];\n    const gl = program.gl;\n\n    if (location !== -1) {\n      gl.disableVertexAttribArray(location);\n\n      if (this.isInstanced && unsetDivisor) {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.vertexAttribDivisor(location, 0);\n        } else {\n          const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n        }\n      }\n    }\n  }\n\n  reallocate(capacity: number): void {\n    // If desired capacity has not changed we do nothing\n    // NOTE: it's possible here to implement more subtle reallocation schemes\n    // when the number of rendered items increase or decrease\n    if (capacity === this.capacity) return;\n\n    this.capacity = capacity;\n    this.verticesCount = this.VERTICES * capacity;\n    this.array = new Float32Array(\n      !this.isInstanced\n        ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT\n        : this.capacity * this.ATTRIBUTES_ITEMS_COUNT,\n    );\n  }\n\n  hasNothingToRender(): boolean {\n    return this.verticesCount === 0;\n  }\n\n  abstract setUniforms(params: RenderParams, programInfo: ProgramInfo): void;\n\n  protected renderProgram(params: RenderParams, programInfo: ProgramInfo): void {\n    const { gl, program } = programInfo;\n\n    // With the current fix for #1397, the alpha blending is enabled for the\n    // picking layer:\n    gl.enable(gl.BLEND);\n\n    // Original code:\n    // if (!isPicking) gl.enable(gl.BLEND);\n    // else gl.disable(gl.BLEND);\n\n    gl.useProgram(program);\n    this.setUniforms(params, programInfo);\n    this.drawWebGL(this.METHOD, programInfo);\n  }\n\n  render(params: RenderParams): void {\n    if (this.hasNothingToRender()) return;\n\n    if (this.pickProgram) {\n      this.pickProgram.gl.viewport(\n        0,\n        0,\n        (params.width * params.pixelRatio) / params.downSizingRatio,\n        (params.height * params.pixelRatio) / params.downSizingRatio,\n      );\n      this.bindProgram(this.pickProgram);\n      this.renderProgram({ ...params, pixelRatio: params.pixelRatio / params.downSizingRatio }, this.pickProgram);\n      this.unbindProgram(this.pickProgram);\n    }\n\n    this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n    this.bindProgram(this.normalProgram);\n    this.renderProgram(params, this.normalProgram);\n    this.unbindProgram(this.normalProgram);\n  }\n\n  drawWebGL(method: number /* GLenum */, { gl, frameBuffer }: ProgramInfo): void {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n\n    if (!this.isInstanced) {\n      gl.drawArrays(method, 0, this.verticesCount);\n    } else {\n      if (gl instanceof WebGL2RenderingContext) {\n        gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n      } else {\n        const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n        if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n      }\n    }\n  }\n}\n\nclass _ProgramClass<\n  Uniform extends string = string,\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends Program<Uniform, N, E, G> {\n  getDefinition(): ProgramDefinition<Uniform> | InstancedProgramDefinition<Uniform> {\n    return {} as unknown as ProgramDefinition<Uniform>;\n  }\n  setUniforms(_params: RenderParams, _programInfo: ProgramInfo) {\n    return undefined;\n  }\n}\nexport type ProgramType<\n  Uniform extends string = string,\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> = typeof _ProgramClass<Uniform, N, E, G>;\n", "/**\n * Sigma.js WebGL Abstract Node Program\n * =====================================\n *\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport Sigma from \"../sigma\";\nimport { NodeDisplayData, NonEmptyArray, RenderParams } from \"../types\";\nimport { indexToColor } from \"../utils\";\nimport { NodeHoverDrawingFunction } from \"./node-hover\";\nimport { NodeLabelDrawingFunction } from \"./node-labels\";\nimport { AbstractProgram, Program } from \"./program\";\n\nexport abstract class AbstractNodeProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends AbstractProgram<N, E, G> {\n  abstract drawLabel: NodeLabelDrawingFunction<N, E, G> | undefined;\n  abstract drawHover: NodeHoverDrawingFunction<N, E, G> | undefined;\n  abstract process(nodeIndex: number, offset: number, data: NodeDisplayData): void;\n}\n\nexport abstract class NodeProgram<\n    Uniform extends string = string,\n    N extends Attributes = Attributes,\n    E extends Attributes = Attributes,\n    G extends Attributes = Attributes,\n  >\n  extends Program<Uniform, N, E, G>\n  implements AbstractNodeProgram<N, E, G>\n{\n  drawLabel: NodeLabelDrawingFunction<N, E, G> | undefined;\n  drawHover: NodeHoverDrawingFunction<N, E, G> | undefined;\n\n  kill(): void {\n    super.kill();\n  }\n\n  process(nodeIndex: number, offset: number, data: NodeDisplayData): void {\n    let i = offset * this.STRIDE;\n    // NOTE: dealing with hidden items automatically\n    if (data.hidden) {\n      for (let l = i + this.STRIDE; i < l; i++) {\n        this.array[i] = 0;\n      }\n      return;\n    }\n\n    return this.processVisibleItem(indexToColor(nodeIndex), i, data);\n  }\n\n  abstract processVisibleItem(nodeIndex: number, i: number, data: NodeDisplayData): void;\n}\n\nclass _NodeProgramClass<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> implements AbstractNodeProgram<N, E, G>\n{\n  constructor(_gl: WebGLRenderingContext, _pickingBuffer: WebGLFramebuffer | null, _renderer: Sigma<N, E, G>) {\n    return this;\n  }\n  drawLabel: NodeLabelDrawingFunction<N, E, G> | undefined;\n  drawHover: NodeHoverDrawingFunction<N, E, G> | undefined;\n\n  kill(): void {\n    return undefined;\n  }\n  reallocate(_capacity: number): void {\n    return undefined;\n  }\n  process(_nodeIndex: number, _offset: number, _data: NodeDisplayData): void {\n    return undefined;\n  }\n  render(_params: RenderParams): void {\n    return undefined;\n  }\n}\nexport type NodeProgramType<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> = typeof _NodeProgramClass<N, E, G>;\n\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nexport function createNodeCompoundProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(\n  programClasses: NonEmptyArray<NodeProgramType<N, E, G>>,\n  drawLabel?: NodeLabelDrawingFunction<N, E, G>,\n  drawHover?: NodeLabelDrawingFunction<N, E, G>,\n): NodeProgramType<N, E, G> {\n  return class NodeCompoundProgram implements AbstractNodeProgram<N, E, G> {\n    programs: NonEmptyArray<AbstractNodeProgram<N, E, G>>;\n\n    constructor(gl: WebGLRenderingContext, pickingBuffer: WebGLFramebuffer | null, renderer: Sigma<N, E, G>) {\n      this.programs = programClasses.map((Program) => {\n        return new Program(gl, pickingBuffer, renderer);\n      }) as unknown as NonEmptyArray<AbstractNodeProgram<N, E, G>>;\n    }\n\n    drawLabel = drawLabel;\n\n    drawHover = drawHover;\n\n    reallocate(capacity: number): void {\n      this.programs.forEach((program) => program.reallocate(capacity));\n    }\n\n    process(nodeIndex: number, offset: number, data: NodeDisplayData): void {\n      this.programs.forEach((program) => program.process(nodeIndex, offset, data));\n    }\n\n    render(params: RenderParams): void {\n      this.programs.forEach((program) => program.render(params));\n    }\n\n    kill(): void {\n      this.programs.forEach((program) => program.kill());\n    }\n  };\n}\n", "/**\n * Sigma.js WebGL Abstract Edge Program\n * =====================================\n *\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport Sigma from \"../sigma\";\nimport { EdgeDisplayData, NodeDisplayData, RenderParams } from \"../types\";\nimport { indexToColor } from \"../utils\";\nimport { EdgeLabelDrawingFunction } from \"./edge-labels\";\nimport { AbstractProgram, Program } from \"./program\";\n\nexport abstract class AbstractEdgeProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends AbstractProgram<N, E, G> {\n  abstract drawLabel: EdgeLabelDrawingFunction<N, E, G> | undefined;\n\n  abstract process(\n    edgeIndex: number,\n    offset: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void;\n}\n\nexport abstract class EdgeProgram<\n    Uniform extends string = string,\n    N extends Attributes = Attributes,\n    E extends Attributes = Attributes,\n    G extends Attributes = Attributes,\n  >\n  extends Program<Uniform, N, E, G>\n  implements AbstractEdgeProgram<N, E, G>\n{\n  drawLabel: EdgeLabelDrawingFunction<N, E, G> | undefined = undefined;\n\n  kill(): void {\n    super.kill();\n  }\n\n  process(\n    edgeIndex: number,\n    offset: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void {\n    let i = offset * this.STRIDE;\n    // NOTE: dealing with hidden items automatically\n    if (data.hidden || sourceData.hidden || targetData.hidden) {\n      for (let l = i + this.STRIDE; i < l; i++) {\n        this.array[i] = 0;\n      }\n      return;\n    }\n\n    return this.processVisibleItem(indexToColor(edgeIndex), i, sourceData, targetData, data);\n  }\n\n  abstract processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void;\n}\n\nclass _EdgeProgramClass<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> implements AbstractEdgeProgram<N, E, G>\n{\n  constructor(_gl: WebGLRenderingContext, _pickingBuffer: WebGLFramebuffer | null, _renderer: Sigma<N, E, G>) {\n    return this;\n  }\n\n  drawLabel: EdgeLabelDrawingFunction<N, E, G> | undefined = undefined;\n\n  kill(): void {\n    return undefined;\n  }\n  reallocate(_capacity: number): void {\n    return undefined;\n  }\n  process(\n    _edgeIndex: number,\n    _offset: number,\n    _sourceData: NodeDisplayData,\n    _targetData: NodeDisplayData,\n    _data: EdgeDisplayData,\n  ): void {\n    return undefined;\n  }\n  render(_params: RenderParams): void {\n    return undefined;\n  }\n}\nexport type EdgeProgramType<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> = typeof _EdgeProgramClass<N, E, G>;\n\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nexport function createEdgeCompoundProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(\n  programClasses: Array<EdgeProgramType<N, E, G>>,\n  drawLabel?: EdgeLabelDrawingFunction<N, E, G>,\n): EdgeProgramType<N, E, G> {\n  return class EdgeCompoundProgram implements AbstractEdgeProgram<N, E, G> {\n    programs: Array<AbstractEdgeProgram<N, E, G>>;\n\n    constructor(gl: WebGLRenderingContext, pickingBuffer: WebGLFramebuffer | null, renderer: Sigma<N, E, G>) {\n      this.programs = programClasses.map((Program) => {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n\n    drawLabel = drawLabel;\n\n    reallocate(capacity: number): void {\n      this.programs.forEach((program) => program.reallocate(capacity));\n    }\n\n    process(\n      edgeIndex: number,\n      offset: number,\n      sourceData: NodeDisplayData,\n      targetData: NodeDisplayData,\n      data: EdgeDisplayData,\n    ): void {\n      this.programs.forEach((program) => program.process(edgeIndex, offset, sourceData, targetData, data));\n    }\n\n    render(params: RenderParams): void {\n      this.programs.forEach((program) => program.render(params));\n    }\n\n    kill(): void {\n      this.programs.forEach((program) => program.kill());\n    }\n  };\n}\n", "import { Attributes } from \"graphology-types\";\n\nimport { Settings } from \"../settings\";\nimport { EdgeDisplayData, NodeDisplayData, PartialButFor } from \"../types\";\n\nexport type EdgeLabelDrawingFunction<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> = (\n  context: CanvasRenderingContext2D,\n  edgeData: PartialButFor<EdgeDisplayData, \"label\" | \"color\" | \"size\">,\n  sourceData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  targetData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  settings: Settings<N, E, G>,\n) => void;\n\nexport function drawStraightEdgeLabel<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(\n  context: CanvasRenderingContext2D,\n  edgeData: PartialButFor<EdgeDisplayData, \"label\" | \"color\" | \"size\">,\n  sourceData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  targetData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  settings: Settings<N, E, G>,\n): void {\n  const size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute\n      ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\"\n      : settings.edgeLabelColor.color;\n\n  let label = edgeData.label;\n\n  if (!label) return;\n\n  context.fillStyle = color;\n  context.font = `${weight} ${size}px ${font}`;\n\n  // Computing positions without considering nodes sizes:\n  const sSize = sourceData.size;\n  const tSize = targetData.size;\n  let sx = sourceData.x;\n  let sy = sourceData.y;\n  let tx = targetData.x;\n  let ty = targetData.y;\n  let cx = (sx + tx) / 2;\n  let cy = (sy + ty) / 2;\n  let dx = tx - sx;\n  let dy = ty - sy;\n  let d = Math.sqrt(dx * dx + dy * dy);\n\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += (dx * sSize) / d;\n  sy += (dy * sSize) / d;\n  tx -= (dx * tSize) / d;\n  ty -= (dy * tSize) / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  let textLength = context.measureText(label).width;\n\n  if (textLength > d) {\n    const ellipsis = \"…\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n\n    if (label.length < 4) return;\n  }\n\n  let angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);\n    else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;\n    else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n\n  context.restore();\n}\n", "import { Attributes } from \"graphology-types\";\n\nimport { Settings } from \"../settings\";\nimport { NodeDisplayData, PartialButFor } from \"../types\";\n\nexport type NodeLabelDrawingFunction<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> = (\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings<N, E, G>,\n) => void;\n\nexport function drawDiscNodeLabel<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings<N, E, G>,\n): void {\n  if (!data.label) return;\n\n  const size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute\n      ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\"\n      : settings.labelColor.color;\n\n  context.fillStyle = color;\n  context.font = `${weight} ${size}px ${font}`;\n\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n", "import { Attributes } from \"graphology-types\";\n\nimport { Settings } from \"../settings\";\nimport { NodeDisplayData, PartialButFor } from \"../types\";\nimport { drawDiscNodeLabel } from \"./node-labels\";\n\nexport type NodeHoverDrawingFunction<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> = (\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings<N, E, G>,\n) => void;\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nexport function drawDiscNodeHover<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings<N, E, G>,\n): void {\n  const size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n\n  context.font = `${weight} ${size}px ${font}`;\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n\n  const PADDING = 2;\n\n  if (typeof data.label === \"string\") {\n    const textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n\n    const angleRadian = Math.asin(boxHeight / 2 / radius);\n    const xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n", "// language=GLSL\nconst SHADER_SOURCE = /*glsl*/ `\nprecision highp float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\n\nuniform float u_correctionRatio;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float border = u_correctionRatio * 2.0;\n  float dist = length(v_diffVector) - v_radius + border;\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  if (dist > border)\n    gl_FragColor = transparent;\n  else\n    gl_FragColor = v_color;\n\n  #else\n  float t = 0.0;\n  if (dist > border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / border;\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n`;\n\nexport default SHADER_SOURCE;\n", "// language=GLSL\nconst SHADER_SOURCE = /*glsl*/ `\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_diffVector = diffVector;\n  v_radius = size / 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n`;\n\nexport default SHADER_SOURCE;\n", "/**\n * Sigma.js WebGL Renderer Node Program\n * =====================================\n *\n * Simple program rendering nodes as discs, shaped by triangles using the\n * `gl.TRIANGLES` display mode. So, to draw one node, it will need to store\n * three times the center of the node, with the color, the size and an angle\n * indicating which \"corner\" of the triangle to draw.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { NodeProgram } from \"../../node\";\nimport { ProgramInfo } from \"../../utils\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_matrix\"] as const;\n\nexport default class NodeCircleProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends NodeProgram<(typeof UNIFORMS)[number], N, E, G> {\n  static readonly ANGLE_1 = 0;\n  static readonly ANGLE_2 = (2 * Math.PI) / 3;\n  static readonly ANGLE_3 = (4 * Math.PI) / 3;\n\n  getDefinition() {\n    return {\n      VERTICES: 3,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.TRIANGLES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_position\", size: 2, type: FLOAT },\n        { name: \"a_size\", size: 1, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n      CONSTANT_ATTRIBUTES: [{ name: \"a_angle\", size: 1, type: FLOAT }],\n      CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]],\n    };\n  }\n\n  processVisibleItem(nodeIndex: number, startIndex: number, data: NodeDisplayData) {\n    const array = this.array;\n    const color = floatColor(data.color);\n\n    array[startIndex++] = data.x;\n    array[startIndex++] = data.y;\n    array[startIndex++] = data.size;\n    array[startIndex++] = color;\n    array[startIndex++] = nodeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_sizeRatio, u_correctionRatio, u_matrix } = uniformLocations;\n\n    gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    gl.uniform1f(u_sizeRatio, params.sizeRatio);\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n  }\n}\n", "/**\n * Sigma.js WebGL Renderer Node Program\n * =====================================\n *\n * Simple program rendering nodes using GL_POINTS. This is faster than the\n * three triangle option but has some quirks and is not supported equally by\n * every GPU.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { NodeProgram } from \"../../node\";\nimport { ProgramInfo } from \"../../utils\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"] as const;\n\nexport default class NodePointProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends NodeProgram<(typeof UNIFORMS)[number], N, E, G> {\n  getDefinition() {\n    return {\n      VERTICES: 1,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.POINTS,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_position\", size: 2, type: FLOAT },\n        { name: \"a_size\", size: 1, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n    };\n  }\n\n  processVisibleItem(nodeIndex: number, startIndex: number, data: NodeDisplayData) {\n    const array = this.array;\n\n    array[startIndex++] = data.x;\n    array[startIndex++] = data.y;\n    array[startIndex++] = data.size;\n    array[startIndex++] = floatColor(data.color);\n    array[startIndex++] = nodeIndex;\n  }\n\n  setUniforms({ sizeRatio, pixelRatio, matrix }: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_sizeRatio, u_pixelRatio, u_matrix } = uniformLocations;\n\n    gl.uniform1f(u_pixelRatio, pixelRatio);\n    gl.uniform1f(u_sizeRatio, sizeRatio);\n    gl.uniformMatrix3fv(u_matrix, false, matrix);\n  }\n}\n", "// language=GLSL\nconst SHADER_SOURCE = /*glsl*/ `\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n`;\n\nexport default SHADER_SOURCE;\n", "// language=GLSL\nconst SHADER_SOURCE = /*glsl*/ `\nattribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec3 a_barycentric;\n\n#ifdef PICKING_MODE\nattribute vec4 a_id;\n#else\nattribute vec4 a_color;\n#endif\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_lengthToThicknessRatio;\nuniform float u_widenessToThicknessRatio;\n\nvarying vec4 v_color;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength / u_sizeRatio, minThickness);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n  float webGLArrowHeadThickness = webGLThickness * u_widenessToThicknessRatio;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (webGLNodeRadius * unitNormal.y)\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadThickness * unitNormal.x)\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadThickness * unitNormal.x),\n\n      da * (-webGLNodeRadius * unitNormal.x)\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadThickness * unitNormal.y)\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadThickness * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n`;\n\nexport default SHADER_SOURCE;\n", "import { Attributes } from \"graphology-types\";\n\nimport { EdgeDisplayData, NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram, EdgeProgramType } from \"../../edge\";\nimport { ProgramInfo } from \"../../utils\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\n  \"u_matrix\",\n  \"u_sizeRatio\",\n  \"u_correctionRatio\",\n  \"u_minEdgeThickness\",\n  \"u_lengthToThicknessRatio\",\n  \"u_widenessToThicknessRatio\",\n] as const;\n\nexport type CreateEdgeArrowHeadProgramOptions = {\n  lengthToThicknessRatio: number;\n  widenessToThicknessRatio: number;\n};\n\nexport const DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS: CreateEdgeArrowHeadProgramOptions = {\n  lengthToThicknessRatio: 2.5,\n  widenessToThicknessRatio: 2,\n};\n\nexport function createEdgeArrowHeadProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(inputOptions?: Partial<CreateEdgeArrowHeadProgramOptions>): EdgeProgramType<N, E, G> {\n  const options = {\n    ...DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS,\n    ...(inputOptions || {}),\n  };\n\n  return class EdgeArrowHeadProgram<\n    N extends Attributes = Attributes,\n    E extends Attributes = Attributes,\n    G extends Attributes = Attributes,\n  > extends EdgeProgram<(typeof UNIFORMS)[number], N, E, G> {\n    getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS,\n        ATTRIBUTES: [\n          { name: \"a_position\", size: 2, type: FLOAT },\n          { name: \"a_normal\", size: 2, type: FLOAT },\n          { name: \"a_radius\", size: 1, type: FLOAT },\n          { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n          { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        ],\n        CONSTANT_ATTRIBUTES: [{ name: \"a_barycentric\", size: 3, type: FLOAT }],\n        CONSTANT_DATA: [\n          [1, 0, 0],\n          [0, 1, 0],\n          [0, 0, 1],\n        ],\n      };\n    }\n\n    processVisibleItem(\n      edgeIndex: number,\n      startIndex: number,\n      sourceData: NodeDisplayData,\n      targetData: NodeDisplayData,\n      data: EdgeDisplayData,\n    ) {\n      const thickness = data.size || 1;\n      const radius = targetData.size || 1;\n      const x1 = sourceData.x;\n      const y1 = sourceData.y;\n      const x2 = targetData.x;\n      const y2 = targetData.y;\n      const color = floatColor(data.color);\n\n      // Computing normals\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n\n      let len = dx * dx + dy * dy;\n      let n1 = 0;\n      let n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n\n      const array = this.array;\n\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = -n1;\n      array[startIndex++] = -n2;\n      array[startIndex++] = radius;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n\n    setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n      const {\n        u_matrix,\n        u_sizeRatio,\n        u_correctionRatio,\n        u_minEdgeThickness,\n        u_lengthToThicknessRatio,\n        u_widenessToThicknessRatio,\n      } = uniformLocations;\n\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n      gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n      gl.uniform1f(u_widenessToThicknessRatio, options.widenessToThicknessRatio);\n    }\n  };\n}\n\nconst EdgeArrowHeadProgram = createEdgeArrowHeadProgram();\n\nexport default EdgeArrowHeadProgram;\n", "// language=GLSL\nconst SHADER_SOURCE = /*glsl*/ `\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  // We only handle antialiasing for normal mode:\n  #ifdef PICKING_MODE\n  gl_FragColor = v_color;\n  #else\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - v_feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n`;\n\nexport default SHADER_SOURCE;\n", "// language=GLSL\nconst SHADER_SOURCE = /*glsl*/ `\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\nattribute float a_radius;\nattribute float a_radiusCoef;\n\nuniform mat3 u_matrix;\nuniform float u_zoomRatio;\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_lengthToThicknessRatio;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  float radius = a_radius * a_radiusCoef;\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here, we move the point to leave space for the arrow head:\n  float direction = sign(radius);\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n`;\n\nexport default SHADER_SOURCE;\n", "import { Attributes } from \"graphology-types\";\n\nimport { EdgeDisplayData, NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram, EdgeProgramType } from \"../../edge\";\nimport { ProgramInfo } from \"../../utils\";\nimport { CreateEdgeArrowHeadProgramOptions, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS } from \"../edge-arrow-head\";\nimport FRAGMENT_SHADER_SOURCE from \"../edge-rectangle/frag.glsl\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\n  \"u_matrix\",\n  \"u_zoomRatio\",\n  \"u_sizeRatio\",\n  \"u_correctionRatio\",\n  \"u_pixelRatio\",\n  \"u_feather\",\n  \"u_minEdgeThickness\",\n  \"u_lengthToThicknessRatio\",\n] as const;\n\nexport type CreateEdgeClampedProgramOptions = Pick<CreateEdgeArrowHeadProgramOptions, \"lengthToThicknessRatio\">;\n\nexport const DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS: CreateEdgeClampedProgramOptions = {\n  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio,\n};\n\nexport function createEdgeClampedProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(inputOptions?: Partial<CreateEdgeClampedProgramOptions>): EdgeProgramType<N, E, G> {\n  const options = {\n    ...DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS,\n    ...(inputOptions || {}),\n  };\n\n  return class EdgeClampedProgram<\n    N extends Attributes = Attributes,\n    E extends Attributes = Attributes,\n    G extends Attributes = Attributes,\n  > extends EdgeProgram<(typeof UNIFORMS)[number], N, E, G> {\n    getDefinition() {\n      return {\n        VERTICES: 6,\n        VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS,\n        ATTRIBUTES: [\n          { name: \"a_positionStart\", size: 2, type: FLOAT },\n          { name: \"a_positionEnd\", size: 2, type: FLOAT },\n          { name: \"a_normal\", size: 2, type: FLOAT },\n          { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n          { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n          { name: \"a_radius\", size: 1, type: FLOAT },\n        ],\n        CONSTANT_ATTRIBUTES: [\n          // If 0, then position will be a_positionStart\n          // If 1, then position will be a_positionEnd\n          { name: \"a_positionCoef\", size: 1, type: FLOAT },\n          { name: \"a_normalCoef\", size: 1, type: FLOAT },\n          { name: \"a_radiusCoef\", size: 1, type: FLOAT },\n        ],\n        CONSTANT_DATA: [\n          [0, 1, 0],\n          [0, -1, 0],\n          [1, 1, 1],\n          [1, 1, 1],\n          [0, -1, 0],\n          [1, -1, -1],\n        ],\n      };\n    }\n\n    processVisibleItem(\n      edgeIndex: number,\n      startIndex: number,\n      sourceData: NodeDisplayData,\n      targetData: NodeDisplayData,\n      data: EdgeDisplayData,\n    ) {\n      const thickness = data.size || 1;\n      const x1 = sourceData.x;\n      const y1 = sourceData.y;\n      const x2 = targetData.x;\n      const y2 = targetData.y;\n      const color = floatColor(data.color);\n\n      // Computing normals\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n\n      const radius = targetData.size || 1;\n\n      let len = dx * dx + dy * dy;\n      let n1 = 0;\n      let n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n\n      const array = this.array;\n\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n      array[startIndex++] = radius;\n    }\n\n    setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n      const {\n        u_matrix,\n        u_zoomRatio,\n        u_feather,\n        u_pixelRatio,\n        u_correctionRatio,\n        u_sizeRatio,\n        u_minEdgeThickness,\n        u_lengthToThicknessRatio,\n      } = uniformLocations;\n\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_zoomRatio, params.zoomRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_pixelRatio, params.pixelRatio);\n      gl.uniform1f(u_feather, params.antiAliasingFeather);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n      gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n    }\n  };\n}\n\nconst EdgeClampedProgram = createEdgeClampedProgram();\n\nexport default EdgeClampedProgram;\n", "import { Attributes } from \"graphology-types\";\n\nimport { EdgeProgramType, createEdgeCompoundProgram } from \"../../edge\";\nimport { CreateEdgeArrowHeadProgramOptions, createEdgeArrowHeadProgram } from \"../edge-arrow-head\";\nimport { createEdgeClampedProgram } from \"../edge-clamped\";\n\nexport function createEdgeArrowProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(inputOptions?: Partial<CreateEdgeArrowHeadProgramOptions>): EdgeProgramType<N, E, G> {\n  return createEdgeCompoundProgram([createEdgeClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions)]);\n}\n\nconst EdgeArrowProgram = createEdgeArrowProgram();\n\nexport default EdgeArrowProgram;\n", "/**\n * Sigma.js WebGL Renderer Fast Edge Program\n * ==========================================\n *\n * Program rendering edges using GL_LINES which is presumably very fast but\n * won't render thickness correctly on some GPUs and has some quirks.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { EdgeDisplayData, NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram } from \"../../edge\";\nimport { ProgramInfo } from \"../../utils\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_matrix\"] as const;\n\nexport default class EdgeLineProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends EdgeProgram<(typeof UNIFORMS)[number], N, E, G> {\n  getDefinition() {\n    return {\n      VERTICES: 2,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.LINES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_position\", size: 2, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const array = this.array;\n\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // First point\n    array[startIndex++] = x1;\n    array[startIndex++] = y1;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n\n    // Second point\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_matrix } = uniformLocations;\n\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n  }\n}\n", "// language=GLSL\nconst SHADER_SOURCE = /*glsl*/ `\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_zoomRatio;\nuniform float u_pixelRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // We require edges to be at least \"minThickness\" pixels thick *on screen*\n  // (so we need to compensate the size ratio):\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\n  // referential (in a ([0, 1], [0, 1]) space), using our \"magic\" correction\n  // ratio:\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  // For the fragment shader though, we need a thickness that takes the \"magic\"\n  // correction ratio into account (as in webGLThickness), but so that the\n  // antialiasing effect does not depend on the zoom level. So here's yet\n  // another thickness version:\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n`;\n\nexport default SHADER_SOURCE;\n", "/**\n * Sigma.js WebGL Renderer Edge Program\n * =====================================\n *\n * Program rendering edges as thick lines using four points translated\n * orthogonally from the source & target's centers by half thickness.\n *\n * Rendering two triangles by using only four points is made possible through\n * the use of indices.\n *\n * This method should be faster than the 6 points / 2 triangles approach and\n * should handle thickness better than with gl.LINES.\n *\n * This version of the shader balances geometry computation evenly between\n * the CPU & GPU (normals are computed on the CPU side).\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { EdgeDisplayData, NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram } from \"../../edge\";\nimport { ProgramInfo } from \"../../utils\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\n  \"u_matrix\",\n  \"u_zoomRatio\",\n  \"u_sizeRatio\",\n  \"u_correctionRatio\",\n  \"u_pixelRatio\",\n  \"u_feather\",\n  \"u_minEdgeThickness\",\n] as const;\n\nexport default class EdgeRectangleProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends EdgeProgram<(typeof UNIFORMS)[number], N, E, G> {\n  getDefinition() {\n    return {\n      VERTICES: 6,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.TRIANGLES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_positionStart\", size: 2, type: FLOAT },\n        { name: \"a_positionEnd\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n      CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        { name: \"a_positionCoef\", size: 1, type: FLOAT },\n        { name: \"a_normalCoef\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_DATA: [\n        [0, 1],\n        [0, -1],\n        [1, 1],\n        [1, 1],\n        [0, -1],\n        [1, -1],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    array[startIndex++] = x1;\n    array[startIndex++] = y1;\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = n1;\n    array[startIndex++] = n2;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_matrix, u_zoomRatio, u_feather, u_pixelRatio, u_correctionRatio, u_sizeRatio, u_minEdgeThickness } =\n      uniformLocations;\n\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    gl.uniform1f(u_zoomRatio, params.zoomRatio);\n    gl.uniform1f(u_sizeRatio, params.sizeRatio);\n    gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    gl.uniform1f(u_pixelRatio, params.pixelRatio);\n    gl.uniform1f(u_feather, params.antiAliasingFeather);\n    gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n  }\n}\n", "/**\n * Sigma.js WebGL Renderer Triangle Edge Program\n * ==============================================\n *\n * Program rendering directed edges as a single triangle.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { EdgeDisplayData, NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram } from \"../../edge\";\nimport { ProgramInfo } from \"../../utils\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_minEdgeThickness\"] as const;\n\nexport default class EdgeTriangleProgram<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends EdgeProgram<(typeof UNIFORMS)[number], N, E, G> {\n  getDefinition() {\n    return {\n      VERTICES: 3,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.TRIANGLES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_positionStart\", size: 2, type: FLOAT },\n        { name: \"a_positionEnd\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n      CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        { name: \"a_positionCoef\", size: 1, type: FLOAT },\n        { name: \"a_normalCoef\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_DATA: [\n        [0, 1],\n        [0, -1],\n        [1, 0],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    // First point\n    array[startIndex++] = x1;\n    array[startIndex++] = y1;\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = n1;\n    array[startIndex++] = n2;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_matrix, u_sizeRatio, u_correctionRatio, u_minEdgeThickness } = uniformLocations;\n\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    gl.uniform1f(u_sizeRatio, params.sizeRatio);\n    gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n  }\n}\n", "/**\n * Sigma.js Settings\n * =================================\n *\n * The list of settings and some handy functions.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport {\n  EdgeArrowProgram,\n  EdgeLabelDrawingFunction,\n  EdgeProgramType,\n  EdgeRectangleProgram,\n  NodeCircleProgram,\n  NodeHoverDrawingFunction,\n  NodeLabelDrawingFunction,\n  NodeProgramType,\n  drawDiscNodeHover,\n  drawDiscNodeLabel,\n  drawStraightEdgeLabel,\n} from \"./rendering\";\nimport { EdgeDisplayData, NodeDisplayData } from \"./types\";\nimport { assign } from \"./utils\";\n\n/**\n * Sigma.js settings\n * =================================\n */\nexport interface Settings<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> {\n  // Performance\n  hideEdgesOnMove: boolean;\n  hideLabelsOnMove: boolean;\n  renderLabels: boolean;\n  renderEdgeLabels: boolean;\n  enableEdgeEvents: boolean;\n  // Component rendering\n  defaultNodeColor: string;\n  defaultNodeType: string;\n  defaultEdgeColor: string;\n  defaultEdgeType: string;\n  labelFont: string;\n  labelSize: number;\n  labelWeight: string;\n  labelColor: { attribute: string; color?: string } | { color: string; attribute?: undefined };\n  edgeLabelFont: string;\n  edgeLabelSize: number;\n  edgeLabelWeight: string;\n  edgeLabelColor: { attribute: string; color?: string } | { color: string; attribute?: undefined };\n  stagePadding: number;\n  defaultDrawEdgeLabel: EdgeLabelDrawingFunction<N, E, G>;\n  defaultDrawNodeLabel: NodeLabelDrawingFunction<N, E, G>;\n  defaultDrawNodeHover: NodeHoverDrawingFunction<N, E, G>;\n  minEdgeThickness: number;\n  antiAliasingFeather: number;\n\n  // Mouse and touch settings\n  dragTimeout: number;\n  draggedEventsTolerance: number;\n  inertiaDuration: number;\n  inertiaRatio: number;\n  zoomDuration: number;\n  zoomingRatio: number;\n  doubleClickTimeout: number;\n  doubleClickZoomingRatio: number;\n  doubleClickZoomingDuration: number;\n  tapMoveTolerance: number;\n\n  // Size and scaling\n  zoomToSizeRatioFunction: (ratio: number) => number;\n  itemSizesReference: \"screen\" | \"positions\";\n  autoRescale: boolean;\n  autoCenter: boolean;\n\n  // Labels\n  labelDensity: number;\n  labelGridCellSize: number;\n  labelRenderedSizeThreshold: number;\n\n  // Reducers\n  nodeReducer: null | ((node: string, data: N) => Partial<NodeDisplayData>);\n  edgeReducer: null | ((edge: string, data: E) => Partial<EdgeDisplayData>);\n\n  // Features\n  zIndex: boolean;\n  minCameraRatio: null | number;\n  maxCameraRatio: null | number;\n  enableCameraRotation: boolean;\n\n  // Lifecycle\n  allowInvalidContainer: boolean;\n\n  // Program classes\n  nodeProgramClasses: { [type: string]: NodeProgramType<N, E, G> };\n  nodeHoverProgramClasses: { [type: string]: NodeProgramType<N, E, G> };\n  edgeProgramClasses: { [type: string]: EdgeProgramType<N, E, G> };\n}\n\nexport const DEFAULT_SETTINGS: Settings<Attributes, Attributes, Attributes> = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  enableEdgeEvents: false,\n\n  // Component rendering\n  defaultNodeColor: \"#999\",\n  defaultNodeType: \"circle\",\n  defaultEdgeColor: \"#ccc\",\n  defaultEdgeType: \"line\",\n  labelFont: \"Arial\",\n  labelSize: 14,\n  labelWeight: \"normal\",\n  labelColor: { color: \"#000\" },\n  edgeLabelFont: \"Arial\",\n  edgeLabelSize: 14,\n  edgeLabelWeight: \"normal\",\n  edgeLabelColor: { attribute: \"color\" },\n  stagePadding: 30,\n  defaultDrawEdgeLabel: drawStraightEdgeLabel,\n  defaultDrawNodeLabel: drawDiscNodeLabel,\n  defaultDrawNodeHover: drawDiscNodeHover,\n  minEdgeThickness: 1.7,\n  antiAliasingFeather: 1,\n\n  // Mouse and touch settings\n  dragTimeout: 100,\n  draggedEventsTolerance: 3,\n  inertiaDuration: 200,\n  inertiaRatio: 3,\n  zoomDuration: 250,\n  zoomingRatio: 1.7,\n  doubleClickTimeout: 300,\n  doubleClickZoomingRatio: 2.2,\n  doubleClickZoomingDuration: 200,\n  tapMoveTolerance: 10,\n\n  // Size and scaling\n  zoomToSizeRatioFunction: Math.sqrt,\n  itemSizesReference: \"screen\",\n  autoRescale: true,\n  autoCenter: true,\n\n  // Labels\n  labelDensity: 1,\n  labelGridCellSize: 100,\n  labelRenderedSizeThreshold: 6,\n\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n\n  // Features\n  zIndex: false,\n  minCameraRatio: null,\n  maxCameraRatio: null,\n  enableCameraRotation: true,\n\n  // Lifecycle\n  allowInvalidContainer: false,\n\n  // Program classes\n  nodeProgramClasses: {},\n  nodeHoverProgramClasses: {},\n  edgeProgramClasses: {},\n};\n\nexport const DEFAULT_NODE_PROGRAM_CLASSES: Record<string, NodeProgramType> = {\n  circle: NodeCircleProgram,\n};\n\nexport const DEFAULT_EDGE_PROGRAM_CLASSES: Record<string, EdgeProgramType> = {\n  arrow: EdgeArrowProgram,\n  line: EdgeRectangleProgram,\n};\n\nexport function validateSettings<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(settings: Settings<N, E, G>): void {\n  if (typeof settings.labelDensity !== \"number\" || settings.labelDensity < 0) {\n    throw new Error(\"Settings: invalid `labelDensity`. Expecting a positive number.\");\n  }\n\n  const { minCameraRatio, maxCameraRatio } = settings;\n  if (typeof minCameraRatio === \"number\" && typeof maxCameraRatio === \"number\" && maxCameraRatio < minCameraRatio) {\n    throw new Error(\n      \"Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.\",\n    );\n  }\n}\n\nexport function resolveSettings<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(settings: Partial<Settings<N, E, G>>): Settings<N, E, G> {\n  const resolvedSettings = assign({}, DEFAULT_SETTINGS, settings);\n\n  resolvedSettings.nodeProgramClasses = assign({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);\n  resolvedSettings.edgeProgramClasses = assign({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);\n\n  return resolvedSettings;\n}\n", "/**\n * Sigma.js Captor Class\n * ======================\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport Sigma from \"../../sigma\";\nimport { Coordinates, EventsMapping, MouseCoords, TouchCoords, TypedEventEmitter, WheelCoords } from \"../../types\";\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nexport function getPosition(e: MouseEvent | Touch, dom: HTMLElement): Coordinates {\n  const bbox = dom.getBoundingClientRect();\n\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top,\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getMouseCoords(e: MouseEvent, dom: HTMLElement): MouseCoords {\n  const res: MouseCoords = {\n    ...getPosition(e, dom),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault(): void {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e,\n  };\n\n  return res;\n}\n\n/**\n * Takes a touch coords or a mouse coords, and always returns a clean mouse coords object.\n */\nexport function cleanMouseCoords(e: MouseCoords | TouchCoords): MouseCoords {\n  const res: MouseCoords =\n    \"x\" in e\n      ? e\n      : {\n          ...(e.touches[0] || e.previousTouches[0]),\n          original: e.original,\n          sigmaDefaultPrevented: e.sigmaDefaultPrevented,\n          preventSigmaDefault: () => {\n            e.sigmaDefaultPrevented = true;\n            res.sigmaDefaultPrevented = true;\n          },\n        };\n\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getWheelCoords(e: WheelEvent, dom: HTMLElement): WheelCoords {\n  return {\n    ...getMouseCoords(e, dom),\n    delta: getWheelDelta(e),\n  };\n}\n\nconst MAX_TOUCHES = 2;\nexport function getTouchesArray(touches: TouchList): Touch[] {\n  const arr: Touch[] = [];\n  for (let i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e               - A touch event.\n * @param  {Touch[]}     previousTouches - An array of the previously stored touches.\n * @param  {HTMLElement} dom             - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getTouchCoords(e: TouchEvent, previousTouches: Touch[], dom: HTMLElement): TouchCoords {\n  const res: TouchCoords = {\n    touches: getTouchesArray(e.touches).map((touch) => getPosition(touch, dom)),\n    previousTouches: previousTouches.map((touch) => getPosition(touch, dom)),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault(): void {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e,\n  };\n\n  return res;\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nexport function getWheelDelta(e: WheelEvent): number {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return (e.deltaY * -3) / 360;\n\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nexport default abstract class Captor<\n  Events extends EventsMapping,\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends TypedEventEmitter<Events> {\n  container: HTMLElement;\n  renderer: Sigma<N, E, G>;\n\n  constructor(container: HTMLElement, renderer: Sigma<N, E, G>) {\n    super();\n    // Properties\n    this.container = container;\n    this.renderer = renderer;\n  }\n\n  abstract kill(): void;\n}\n", "/**\n * Sigma.js Mouse Captor\n * ======================\n *\n * Sigma's captor dealing with the user's mouse.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { DEFAULT_SETTINGS, Settings } from \"../../settings\";\nimport Sigma from \"../../sigma\";\nimport { CameraState, MouseCoords, WheelCoords } from \"../../types\";\nimport Captor, { getMouseCoords, getPosition, getWheelCoords, getWheelDelta } from \"./captor\";\n\nexport const MOUSE_SETTINGS_KEYS = [\n  \"doubleClickTimeout\",\n  \"doubleClickZoomingDuration\",\n  \"doubleClickZoomingRatio\",\n  \"dragTimeout\",\n  \"draggedEventsTolerance\",\n  \"inertiaDuration\",\n  \"inertiaRatio\",\n  \"zoomDuration\",\n  \"zoomingRatio\",\n] as const;\n\nexport type MouseSettingKey = (typeof MOUSE_SETTINGS_KEYS)[number];\nexport type MouseSettings = Pick<Settings, MouseSettingKey>;\nexport const DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(\n  (iter, key) => ({ ...iter, [key]: DEFAULT_SETTINGS[key] }),\n  {},\n) as MouseSettings;\n\n/**\n * Event types.\n */\nexport type MouseCaptorEvents = {\n  click(coordinates: MouseCoords): void;\n  rightClick(coordinates: MouseCoords): void;\n  doubleClick(coordinates: MouseCoords): void;\n  mouseup(coordinates: MouseCoords): void;\n  mousedown(coordinates: MouseCoords): void;\n  mousemove(coordinates: MouseCoords): void;\n  mousemovebody(coordinates: MouseCoords): void;\n  mouseleave(coordinates: MouseCoords): void;\n  mouseenter(coordinates: MouseCoords): void;\n  wheel(coordinates: WheelCoords): void;\n};\n\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nexport default class MouseCaptor<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends Captor<MouseCaptorEvents, N, E, G> {\n  // State\n  enabled = true;\n  draggedEvents = 0;\n  downStartTime: number | null = null;\n  lastMouseX: number | null = null;\n  lastMouseY: number | null = null;\n  isMouseDown = false;\n  isMoving = false;\n  movingTimeout: number | null = null;\n  startCameraState: CameraState | null = null;\n  clicks = 0;\n  doubleClickTimeout: number | null = null;\n\n  currentWheelDirection: -1 | 0 | 1 = 0;\n  lastWheelTriggerTime?: number;\n\n  settings: MouseSettings = DEFAULT_MOUSE_SETTINGS;\n\n  constructor(container: HTMLElement, renderer: Sigma<N, E, G>) {\n    super(container, renderer);\n\n    // Binding methods\n    this.handleClick = this.handleClick.bind(this);\n    this.handleRightClick = this.handleRightClick.bind(this);\n    this.handleDown = this.handleDown.bind(this);\n    this.handleUp = this.handleUp.bind(this);\n    this.handleMove = this.handleMove.bind(this);\n    this.handleWheel = this.handleWheel.bind(this);\n    this.handleLeave = this.handleLeave.bind(this);\n    this.handleEnter = this.handleEnter.bind(this);\n\n    // Binding events\n    container.addEventListener(\"click\", this.handleClick, { capture: false });\n    container.addEventListener(\"contextmenu\", this.handleRightClick, { capture: false });\n    container.addEventListener(\"mousedown\", this.handleDown, { capture: false });\n    container.addEventListener(\"wheel\", this.handleWheel, { capture: false });\n    container.addEventListener(\"mouseleave\", this.handleLeave, { capture: false });\n    container.addEventListener(\"mouseenter\", this.handleEnter, { capture: false });\n\n    document.addEventListener(\"mousemove\", this.handleMove, { capture: false });\n    document.addEventListener(\"mouseup\", this.handleUp, { capture: false });\n  }\n\n  kill(): void {\n    const container = this.container;\n\n    container.removeEventListener(\"click\", this.handleClick);\n    container.removeEventListener(\"contextmenu\", this.handleRightClick);\n    container.removeEventListener(\"mousedown\", this.handleDown);\n    container.removeEventListener(\"wheel\", this.handleWheel);\n    container.removeEventListener(\"mouseleave\", this.handleLeave);\n    container.removeEventListener(\"mouseenter\", this.handleEnter);\n\n    document.removeEventListener(\"mousemove\", this.handleMove);\n    document.removeEventListener(\"mouseup\", this.handleUp);\n  }\n\n  handleClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    this.clicks++;\n\n    if (this.clicks === 2) {\n      this.clicks = 0;\n      if (typeof this.doubleClickTimeout === \"number\") {\n        clearTimeout(this.doubleClickTimeout);\n        this.doubleClickTimeout = null;\n      }\n      return this.handleDoubleClick(e);\n    }\n\n    setTimeout(() => {\n      this.clicks = 0;\n      this.doubleClickTimeout = null;\n    }, this.settings.doubleClickTimeout);\n\n    // NOTE: this is here to prevent click events on drag\n    if (this.draggedEvents < this.settings.draggedEventsTolerance)\n      this.emit(\"click\", getMouseCoords(e, this.container));\n  }\n\n  handleRightClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    this.emit(\"rightClick\", getMouseCoords(e, this.container));\n  }\n\n  handleDoubleClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const mouseCoords = getMouseCoords(e, this.container);\n    this.emit(\"doubleClick\", mouseCoords);\n\n    if (mouseCoords.sigmaDefaultPrevented) return;\n\n    // default behavior\n    const camera = this.renderer.getCamera();\n    const newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n\n    camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n      easing: \"quadraticInOut\",\n      duration: this.settings.doubleClickZoomingDuration,\n    });\n  }\n\n  handleDown(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    // We only start dragging on left button\n    if (e.button === 0) {\n      this.startCameraState = this.renderer.getCamera().getState();\n\n      const { x, y } = getPosition(e, this.container);\n      this.lastMouseX = x;\n      this.lastMouseY = y;\n\n      this.draggedEvents = 0;\n\n      this.downStartTime = Date.now();\n      this.isMouseDown = true;\n    }\n\n    this.emit(\"mousedown\", getMouseCoords(e, this.container));\n  }\n\n  handleUp(e: MouseEvent): void {\n    if (!this.enabled || !this.isMouseDown) return;\n\n    const camera = this.renderer.getCamera();\n    this.isMouseDown = false;\n\n    if (typeof this.movingTimeout === \"number\") {\n      clearTimeout(this.movingTimeout);\n      this.movingTimeout = null;\n    }\n\n    const { x, y } = getPosition(e, this.container);\n\n    const cameraState = camera.getState(),\n      previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n\n    if (this.isMoving) {\n      camera.animate(\n        {\n          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y),\n        },\n        {\n          duration: this.settings.inertiaDuration,\n          easing: \"quadraticOut\",\n        },\n      );\n    } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n      camera.setState({\n        x: cameraState.x,\n        y: cameraState.y,\n      });\n    }\n\n    this.isMoving = false;\n    setTimeout(() => {\n      const shouldRefresh = this.draggedEvents > 0;\n      this.draggedEvents = 0;\n\n      // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n      // when someone releases camera pan drag after having stopped moving.\n      // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n      // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n      // It could be possible to render instead of scheduling a refresh but for\n      // now it seems good enough.\n      if (shouldRefresh) this.renderer.refresh();\n    }, 0);\n    this.emit(\"mouseup\", getMouseCoords(e, this.container));\n  }\n\n  handleMove(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    const mouseCoords = getMouseCoords(e, this.container);\n\n    // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n    // a drag-and-drop effect that works even when the mouse is out of the\n    // container:\n    this.emit(\"mousemovebody\", mouseCoords);\n\n    // Only trigger the \"mousemove\" event when the mouse is actually hovering\n    // the container, to avoid weirdly hovering nodes and/or edges when the\n    // mouse is not hover the container:\n    if (e.target === this.container || e.composedPath()[0] === this.container) {\n      this.emit(\"mousemove\", mouseCoords);\n    }\n\n    if (mouseCoords.sigmaDefaultPrevented) return;\n\n    // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n    // stage while the mouse is not hover the container:\n    if (this.isMouseDown) {\n      this.isMoving = true;\n      this.draggedEvents++;\n\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n      }\n\n      this.movingTimeout = window.setTimeout(() => {\n        this.movingTimeout = null;\n        this.isMoving = false;\n      }, this.settings.dragTimeout);\n\n      const camera = this.renderer.getCamera();\n\n      const { x: eX, y: eY } = getPosition(e, this.container);\n\n      const lastMouse = this.renderer.viewportToFramedGraph({\n        x: this.lastMouseX as number,\n        y: this.lastMouseY as number,\n      });\n\n      const mouse = this.renderer.viewportToFramedGraph({ x: eX, y: eY });\n\n      const offsetX = lastMouse.x - mouse.x,\n        offsetY = lastMouse.y - mouse.y;\n\n      const cameraState = camera.getState();\n\n      const x = cameraState.x + offsetX,\n        y = cameraState.y + offsetY;\n\n      camera.setState({ x, y });\n\n      this.lastMouseX = eX;\n      this.lastMouseY = eY;\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  handleLeave(e: MouseEvent): void {\n    this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n  }\n\n  handleEnter(e: MouseEvent): void {\n    this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n  }\n\n  handleWheel(e: WheelEvent): void {\n    if (!this.enabled) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const delta = getWheelDelta(e);\n\n    if (!delta) return;\n\n    const wheelCoords = getWheelCoords(e, this.container);\n    this.emit(\"wheel\", wheelCoords);\n\n    if (wheelCoords.sigmaDefaultPrevented) return;\n\n    // Default behavior\n    const ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;\n    const camera = this.renderer.getCamera();\n    const newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n    const wheelDirection = delta > 0 ? 1 : -1;\n    const now = Date.now();\n\n    // Cancel events that are too close too each other and in the same direction:\n    if (\n      this.currentWheelDirection === wheelDirection &&\n      this.lastWheelTriggerTime &&\n      now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5\n    ) {\n      return;\n    }\n\n    camera.animate(\n      this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio),\n      {\n        easing: \"quadraticOut\",\n        duration: this.settings.zoomDuration,\n      },\n      () => {\n        this.currentWheelDirection = 0;\n      },\n    );\n\n    this.currentWheelDirection = wheelDirection;\n    this.lastWheelTriggerTime = now;\n  }\n\n  setSettings(settings: MouseSettings): void {\n    this.settings = settings;\n  }\n}\n", "/**\n * Sigma.js Touch Captor\n * ======================\n *\n * Sigma's captor dealing with touch.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { DEFAULT_SETTINGS, Settings } from \"../../settings\";\nimport Sigma from \"../../sigma\";\nimport { CameraState, Coordinates, Dimensions, TouchCoords } from \"../../types\";\nimport Captor, { getPosition, getTouchCoords, getTouchesArray } from \"./captor\";\n\nexport const TOUCH_SETTINGS_KEYS = [\n  \"dragTimeout\",\n  \"inertiaDuration\",\n  \"inertiaRatio\",\n  \"doubleClickTimeout\",\n  \"doubleClickZoomingRatio\",\n  \"doubleClickZoomingDuration\",\n  \"tapMoveTolerance\",\n] as const;\n\nexport type TouchSettingKey = (typeof TOUCH_SETTINGS_KEYS)[number];\nexport type TouchSettings = Pick<Settings, TouchSettingKey>;\nexport const DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(\n  (iter, key) => ({ ...iter, [key]: DEFAULT_SETTINGS[key] }),\n  {},\n) as TouchSettings;\n\n/**\n * Event types.\n */\nexport type TouchCaptorEventType = \"touchdown\" | \"touchup\" | \"touchmove\" | \"touchmovebody\" | \"tap\" | \"doubletap\";\nexport type TouchCaptorEvents = Record<TouchCaptorEventType, (coordinates: TouchCoords) => void>;\n\n/**\n * Touch captor class.\n *\n * @constructor\n */\nexport default class TouchCaptor<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends Captor<TouchCaptorEvents, N, E, G> {\n  enabled = true;\n  isMoving = false;\n  hasMoved = false;\n  startCameraState?: CameraState;\n  touchMode = 0; // number of touches down\n  movingTimeout?: number;\n\n  startTouchesAngle?: number;\n  startTouchesDistance?: number;\n  startTouchesPositions: Coordinates[] = [];\n  lastTouchesPositions?: Coordinates[];\n  lastTouches: Touch[] = [];\n  lastTap: null | { position: Coordinates; time: number } = null;\n\n  settings: TouchSettings = DEFAULT_TOUCH_SETTINGS;\n\n  constructor(container: HTMLElement, renderer: Sigma<N, E, G>) {\n    super(container, renderer);\n\n    // Binding methods:\n    this.handleStart = this.handleStart.bind(this);\n    this.handleLeave = this.handleLeave.bind(this);\n    this.handleMove = this.handleMove.bind(this);\n\n    // Binding events\n    container.addEventListener(\"touchstart\", this.handleStart, { capture: false });\n    container.addEventListener(\"touchcancel\", this.handleLeave, { capture: false });\n    document.addEventListener(\"touchend\", this.handleLeave, { capture: false, passive: false });\n    document.addEventListener(\"touchmove\", this.handleMove, { capture: false, passive: false });\n  }\n\n  kill(): void {\n    const container = this.container;\n\n    container.removeEventListener(\"touchstart\", this.handleStart);\n    container.removeEventListener(\"touchcancel\", this.handleLeave);\n    document.removeEventListener(\"touchend\", this.handleLeave);\n    document.removeEventListener(\"touchmove\", this.handleMove);\n  }\n\n  getDimensions(): Dimensions {\n    return {\n      width: this.container.offsetWidth,\n      height: this.container.offsetHeight,\n    };\n  }\n\n  handleStart(e: TouchEvent): void {\n    if (!this.enabled) return;\n\n    e.preventDefault();\n\n    const touches = getTouchesArray(e.touches);\n    this.touchMode = touches.length;\n\n    this.startCameraState = this.renderer.getCamera().getState();\n    this.startTouchesPositions = touches.map((touch) => getPosition(touch, this.container));\n\n    // When there are two touches down, let's record distance and angle as well:\n    if (this.touchMode === 2) {\n      const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.startTouchesPositions;\n      this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n      this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n    }\n\n    this.emit(\"touchdown\", getTouchCoords(e, this.lastTouches, this.container));\n    this.lastTouches = touches;\n    this.lastTouchesPositions = this.startTouchesPositions;\n  }\n\n  handleLeave(e: TouchEvent): void {\n    if (!this.enabled || !this.startTouchesPositions.length) return;\n\n    if (e.cancelable) e.preventDefault();\n\n    if (this.movingTimeout) {\n      this.isMoving = false;\n      clearTimeout(this.movingTimeout);\n    }\n\n    switch (this.touchMode) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      case 2:\n        if (e.touches.length === 1) {\n          this.handleStart(e);\n\n          e.preventDefault();\n          break;\n        }\n      /* falls through */\n      case 1:\n        if (this.isMoving) {\n          const camera = this.renderer.getCamera();\n          const cameraState = camera.getState(),\n            previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n\n          camera.animate(\n            {\n              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y),\n            },\n            {\n              duration: this.settings.inertiaDuration,\n              easing: \"quadraticOut\",\n            },\n          );\n        }\n\n        this.hasMoved = false;\n        this.isMoving = false;\n        this.touchMode = 0;\n        break;\n    }\n\n    this.emit(\"touchup\", getTouchCoords(e, this.lastTouches, this.container));\n\n    // When the last touch ends and there hasn't been too much movement, trigger a \"tap\" or \"doubletap\" event:\n    if (!e.touches.length) {\n      const position = getPosition(this.lastTouches[0], this.container);\n      const downPosition = this.startTouchesPositions[0];\n      const dSquare = (position.x - downPosition.x) ** 2 + (position.y - downPosition.y) ** 2;\n\n      if (!e.touches.length && dSquare < this.settings.tapMoveTolerance ** 2) {\n        // Only trigger \"doubletap\" when the last tap is recent enough:\n        if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {\n          const touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n          this.emit(\"doubletap\", touchCoords);\n          this.lastTap = null;\n\n          if (!touchCoords.sigmaDefaultPrevented) {\n            const camera = this.renderer.getCamera();\n            const newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n\n            camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {\n              easing: \"quadraticInOut\",\n              duration: this.settings.doubleClickZoomingDuration,\n            });\n          }\n        }\n        // Else, trigger a normal \"tap\" event:\n        else {\n          const touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n          this.emit(\"tap\", touchCoords);\n          this.lastTap = { time: Date.now(), position: touchCoords.touches[0] || touchCoords.previousTouches[0] };\n        }\n      }\n    }\n\n    this.lastTouches = getTouchesArray(e.touches);\n    this.startTouchesPositions = [];\n  }\n\n  handleMove(e: TouchEvent): void {\n    if (!this.enabled || !this.startTouchesPositions.length) return;\n\n    e.preventDefault();\n\n    const touches = getTouchesArray(e.touches);\n    const touchesPositions = touches.map((touch) => getPosition(touch, this.container));\n\n    const lastTouches = this.lastTouches;\n    this.lastTouches = touches;\n    this.lastTouchesPositions = touchesPositions;\n\n    const touchCoords = getTouchCoords(e, lastTouches, this.container);\n    this.emit(\"touchmove\", touchCoords);\n\n    if (touchCoords.sigmaDefaultPrevented) return;\n\n    // If a move was initiated at some point, and we get back to start point,\n    // we should still consider that we did move (which also happens after a\n    // multiple touch when only one touch remains in which case handleStart\n    // is recalled within handleLeave).\n    // Now, some mobile browsers report zero-distance moves so we also check that\n    // one of the touches did actually move from the origin position.\n    this.hasMoved ||= touchesPositions.some((position, idx) => {\n      const startPosition = this.startTouchesPositions[idx];\n\n      return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);\n    });\n\n    // If there was no move, do not trigger touch moves behavior\n    if (!this.hasMoved) {\n      return;\n    }\n\n    this.isMoving = true;\n\n    if (this.movingTimeout) clearTimeout(this.movingTimeout);\n\n    this.movingTimeout = window.setTimeout(() => {\n      this.isMoving = false;\n    }, this.settings.dragTimeout);\n\n    const camera = this.renderer.getCamera();\n    const startCameraState = this.startCameraState as CameraState;\n    const padding = this.renderer.getSetting(\"stagePadding\");\n\n    switch (this.touchMode) {\n      case 1: {\n        const { x: xStart, y: yStart } = this.renderer.viewportToFramedGraph(\n          (this.startTouchesPositions || [])[0] as Coordinates,\n        );\n        const { x, y } = this.renderer.viewportToFramedGraph(touchesPositions[0]);\n\n        camera.setState({\n          x: startCameraState.x + xStart - x,\n          y: startCameraState.y + yStart - y,\n        });\n        break;\n      }\n      case 2: {\n        /**\n         * Here is the thinking here:\n         *\n         * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n         *    of the d'n'd and now\n         *\n         * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n         *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n         *    position of this same touch now\n         */\n        const newCameraState: CameraState = {\n          x: 0.5,\n          y: 0.5,\n          angle: 0,\n          ratio: 1,\n        };\n\n        const { x: x0, y: y0 } = touchesPositions[0];\n        const { x: x1, y: y1 } = touchesPositions[1];\n\n        const angleDiff = Math.atan2(y1 - y0, x1 - x0) - (this.startTouchesAngle as number);\n        const ratioDiff = Math.hypot(y1 - y0, x1 - x0) / (this.startTouchesDistance as number);\n\n        // 1.\n        const newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n        newCameraState.ratio = newRatio;\n        newCameraState.angle = startCameraState.angle + angleDiff;\n\n        // 2.\n        const dimensions = this.getDimensions();\n        const touchGraphPosition = this.renderer.viewportToFramedGraph(\n          (this.startTouchesPositions || [])[0] as Coordinates,\n          { cameraState: startCameraState },\n        );\n        const smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;\n\n        const dx = smallestDimension / dimensions.width;\n        const dy = smallestDimension / dimensions.height;\n        const ratio = newRatio / smallestDimension;\n\n        // Align with center of the graph:\n        let x = x0 - smallestDimension / 2 / dx;\n        let y = y0 - smallestDimension / 2 / dy;\n\n        // Rotate:\n        [x, y] = [\n          x * Math.cos(-newCameraState.angle) - y * Math.sin(-newCameraState.angle),\n          y * Math.cos(-newCameraState.angle) + x * Math.sin(-newCameraState.angle),\n        ];\n\n        newCameraState.x = touchGraphPosition.x - x * ratio;\n        newCameraState.y = touchGraphPosition.y + y * ratio;\n\n        camera.setState(newCameraState);\n\n        break;\n      }\n    }\n  }\n\n  setSettings(settings: TouchSettings): void {\n    this.settings = settings;\n  }\n}\n", "/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\nimport Graph from \"graphology-types\";\n\nimport { Coordinates, Dimensions } from \"../types\";\n\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nclass LabelCandidate {\n  key: string;\n  size: number;\n\n  constructor(key: string, size: number) {\n    this.key = key;\n    this.size = size;\n  }\n\n  static compare(first: LabelCandidate, second: LabelCandidate): number {\n    // First we compare by size\n    if (first.size > second.size) return -1;\n    if (first.size < second.size) return 1;\n\n    // Then since no two nodes can have the same key, we use it to\n    // deterministically tie-break by key\n    if (first.key > second.key) return 1;\n\n    // NOTE: this comparator cannot return 0\n    return -1;\n  }\n}\n\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nexport class LabelGrid {\n  width = 0;\n  height = 0;\n  cellSize = 0;\n  columns = 0;\n  rows = 0;\n  cells: Record<number, Array<LabelCandidate>> = {};\n\n  resizeAndClear(dimensions: Dimensions, cellSize: number): void {\n    this.width = dimensions.width;\n    this.height = dimensions.height;\n\n    this.cellSize = cellSize;\n\n    this.columns = Math.ceil(dimensions.width / cellSize);\n    this.rows = Math.ceil(dimensions.height / cellSize);\n\n    this.cells = {};\n  }\n\n  private getIndex(pos: Coordinates): number {\n    const xIndex = Math.floor(pos.x / this.cellSize);\n    const yIndex = Math.floor(pos.y / this.cellSize);\n\n    return yIndex * this.columns + xIndex;\n  }\n\n  add(key: string, size: number, pos: Coordinates): void {\n    const candidate = new LabelCandidate(key, size);\n\n    const index = this.getIndex(pos);\n    let cell = this.cells[index];\n\n    if (!cell) {\n      cell = [];\n      this.cells[index] = cell;\n    }\n\n    cell.push(candidate);\n  }\n\n  organize(): void {\n    for (const k in this.cells) {\n      const cell = this.cells[k];\n      cell.sort(LabelCandidate.compare);\n    }\n  }\n\n  getLabelsToDisplay(ratio: number, density: number): Array<string> {\n    // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n    // TODO: adjust threshold lower, but increase cells a bit?\n    // TODO: hunt for geom issue in disguise\n    // TODO: memoize while ratio does not move. method to force recompute\n    const cellArea = this.cellSize * this.cellSize;\n    const scaledCellArea = cellArea / ratio / ratio;\n    const scaledDensity = (scaledCellArea * density) / cellArea;\n\n    const labelsToDisplayPerCell = Math.ceil(scaledDensity);\n\n    const labels: string[] = [];\n\n    for (const k in this.cells) {\n      const cell = this.cells[k];\n\n      for (let i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n        labels.push(cell[i].key);\n      }\n    }\n\n    return labels;\n  }\n}\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nexport function edgeLabelsToDisplayFromNodes(params: {\n  displayedNodeLabels: Set<string>;\n  highlightedNodes: Set<string>;\n  graph: Graph;\n  hoveredNode: string | null;\n}): Array<string> {\n  const { graph, hoveredNode, highlightedNodes, displayedNodeLabels } = params;\n\n  const worthyEdges: Array<string> = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge((edge, _, source, target) => {\n    if (\n      source === hoveredNode ||\n      target === hoveredNode ||\n      highlightedNodes.has(source) ||\n      highlightedNodes.has(target) ||\n      (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))\n    ) {\n      worthyEdges.push(edge);\n    }\n  });\n\n  return worthyEdges;\n}\n", "/**\n * Sigma.js\n * ========\n * @module\n */\nimport Graph, { Attributes } from \"graphology-types\";\n\nimport Camera from \"./core/camera\";\nimport { cleanMouseCoords } from \"./core/captors/captor\";\nimport MouseCaptor from \"./core/captors/mouse\";\nimport TouchCaptor from \"./core/captors/touch\";\nimport { LabelGrid, edgeLabelsToDisplayFromNodes } from \"./core/labels\";\nimport { AbstractEdgeProgram, AbstractNodeProgram, EdgeProgramType, NodeProgramType } from \"./rendering\";\nimport { Settings, resolveSettings, validateSettings } from \"./settings\";\nimport {\n  CameraState,\n  CoordinateConversionOverride,\n  Coordinates,\n  Dimensions,\n  EdgeDisplayData,\n  Extent,\n  Listener,\n  MouseCoords,\n  MouseInteraction,\n  NodeDisplayData,\n  PlainObject,\n  RenderParams,\n  SigmaEvents,\n  TouchCoords,\n  TypedEventEmitter,\n} from \"./types\";\nimport {\n  NormalizationFunction,\n  colorToIndex,\n  createElement,\n  createNormalizationFunction,\n  extend,\n  getMatrixImpact,\n  getPixelColor,\n  getPixelRatio,\n  graphExtent,\n  identity,\n  matrixFromCamera,\n  multiplyVec2,\n  validateGraph,\n  zIndexOrdering,\n} from \"./utils\";\n\n/**\n * Constants.\n */\nconst X_LABEL_MARGIN = 150;\nconst Y_LABEL_MARGIN = 50;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(settings: Settings<N, E, G>, key: string, data: Partial<NodeDisplayData>): NodeDisplayData {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\"))\n    throw new Error(\n      `Sigma: could not find a valid position (x, y) for node \"${key}\". All your nodes must have a number \"x\" and \"y\". Maybe your forgot to apply a layout or your \"nodeReducer\" is not returning the correct data?`,\n    );\n\n  if (!data.color) data.color = settings.defaultNodeColor;\n\n  if (!data.label && data.label !== \"\") data.label = null;\n\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;\n  else data.label = null;\n\n  if (!data.size) data.size = 2;\n\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n\n  if (!data.zIndex) data.zIndex = 0;\n\n  return data as NodeDisplayData;\n}\n\nfunction applyEdgeDefaults<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(settings: Settings<N, E, G>, _key: string, data: Partial<EdgeDisplayData>): EdgeDisplayData {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n\n  if (!data.label) data.label = \"\";\n\n  if (!data.size) data.size = 0.5;\n\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n\n  if (!data.zIndex) data.zIndex = 0;\n\n  return data as EdgeDisplayData;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nexport default class Sigma<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> extends TypedEventEmitter<SigmaEvents> {\n  private settings: Settings<N, E, G>;\n  private graph: Graph<N, E, G>;\n  private mouseCaptor: MouseCaptor<N, E, G>;\n  private touchCaptor: TouchCaptor<N, E, G>;\n  private container: HTMLElement;\n  private elements: PlainObject<HTMLCanvasElement> = {};\n  private canvasContexts: PlainObject<CanvasRenderingContext2D> = {};\n  private webGLContexts: PlainObject<WebGLRenderingContext> = {};\n  private pickingLayers: Set<string> = new Set();\n  private textures: PlainObject<WebGLTexture> = {};\n  private frameBuffers: PlainObject<WebGLFramebuffer> = {};\n  private activeListeners: PlainObject<Listener> = {};\n  private labelGrid: LabelGrid = new LabelGrid();\n  private nodeDataCache: Record<string, NodeDisplayData> = {};\n  private edgeDataCache: Record<string, EdgeDisplayData> = {};\n\n  // Indices to keep track of the index of the item inside programs\n  private nodeProgramIndex: Record<string, number> = {};\n  private edgeProgramIndex: Record<string, number> = {};\n  private nodesWithForcedLabels: Set<string> = new Set<string>();\n  private edgesWithForcedLabels: Set<string> = new Set<string>();\n  private nodeExtent: { x: Extent; y: Extent } = { x: [0, 1], y: [0, 1] };\n  private nodeZExtent: [number, number] = [Infinity, -Infinity];\n  private edgeZExtent: [number, number] = [Infinity, -Infinity];\n\n  private matrix: Float32Array = identity();\n  private invMatrix: Float32Array = identity();\n  private correctionRatio = 1;\n  private customBBox: { x: Extent; y: Extent } | null = null;\n  private normalizationFunction: NormalizationFunction = createNormalizationFunction({\n    x: [0, 1],\n    y: [0, 1],\n  });\n\n  // Cache:\n  private graphToViewportRatio = 1;\n  private itemIDsIndex: Record<number, { type: \"node\" | \"edge\"; id: string }> = {};\n  private nodeIndices: Record<string, number> = {};\n  private edgeIndices: Record<string, number> = {};\n\n  // Starting dimensions and pixel ratio\n  private width = 0;\n  private height = 0;\n  private pixelRatio = getPixelRatio();\n  private pickingDownSizingRatio = 2 * this.pixelRatio;\n\n  // Graph State\n  private displayedNodeLabels: Set<string> = new Set();\n  private displayedEdgeLabels: Set<string> = new Set();\n  private highlightedNodes: Set<string> = new Set();\n  private hoveredNode: string | null = null;\n  private hoveredEdge: string | null = null;\n\n  // Internal states\n  private renderFrame: number | null = null;\n  private renderHighlightedNodesFrame: number | null = null;\n  private needToProcess = false;\n  private checkEdgesEventsFrame: number | null = null;\n\n  // Programs\n  private nodePrograms: { [key: string]: AbstractNodeProgram<N, E, G> } = {};\n  private nodeHoverPrograms: { [key: string]: AbstractNodeProgram<N, E, G> } = {};\n  private edgePrograms: { [key: string]: AbstractEdgeProgram<N, E, G> } = {};\n\n  private camera: Camera;\n\n  constructor(graph: Graph<N, E, G>, container: HTMLElement, settings: Partial<Settings<N, E, G>> = {}) {\n    super();\n\n    // Resolving settings\n    this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    this.graph = graph;\n    this.container = container;\n\n    // Initializing contexts\n    this.createWebGLContext(\"edges\", { picking: settings.enableEdgeEvents });\n    this.createCanvasContext(\"edgeLabels\");\n    this.createWebGLContext(\"nodes\", { picking: true });\n    this.createCanvasContext(\"labels\");\n    this.createCanvasContext(\"hovers\");\n    this.createWebGLContext(\"hoverNodes\");\n    this.createCanvasContext(\"mouse\", { style: { touchAction: \"none\", userSelect: \"none\" } });\n\n    // Initial resize\n    this.resize();\n\n    // Loading programs\n    for (const type in this.settings.nodeProgramClasses) {\n      this.registerNodeProgram(\n        type,\n        this.settings.nodeProgramClasses[type],\n        this.settings.nodeHoverProgramClasses[type],\n      );\n    }\n\n    for (const type in this.settings.edgeProgramClasses) {\n      this.registerEdgeProgram(type, this.settings.edgeProgramClasses[type]);\n    }\n\n    // Initializing the camera\n    this.camera = new Camera();\n\n    // Binding camera events\n    this.bindCameraHandlers();\n\n    // Initializing captors\n    this.mouseCaptor = new MouseCaptor(this.elements.mouse, this);\n    this.mouseCaptor.setSettings(this.settings);\n    this.touchCaptor = new TouchCaptor(this.elements.mouse, this);\n    this.touchCaptor.setSettings(this.settings);\n\n    // Binding event handlers\n    this.bindEventHandlers();\n\n    // Binding graph handlers\n    this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    this.refresh();\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to register a node program\n   *\n   * @param  {string}           key              - The program's key, matching the related nodes \"type\" values.\n   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.\n   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).\n   * @return {Sigma}\n   */\n  private registerNodeProgram(\n    key: string,\n    NodeProgramClass: NodeProgramType<N, E, G>,\n    NodeHoverProgram?: NodeProgramType<N, E, G>,\n  ): this {\n    if (this.nodePrograms[key]) this.nodePrograms[key].kill();\n    if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();\n    this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n    this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);\n    return this;\n  }\n\n  /**\n   * Internal function used to register an edge program\n   *\n   * @param  {string}          key              - The program's key, matching the related edges \"type\" values.\n   * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.\n   * @return {Sigma}\n   */\n  private registerEdgeProgram(key: string, EdgeProgramClass: EdgeProgramType<N, E, G>): this {\n    if (this.edgePrograms[key]) this.edgePrograms[key].kill();\n    this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n    return this;\n  }\n\n  /**\n   * Internal function used to unregister a node program\n   *\n   * @param  {string} key - The program's key, matching the related nodes \"type\" values.\n   * @return {Sigma}\n   */\n  private unregisterNodeProgram(key: string): this {\n    if (this.nodePrograms[key]) {\n      const { [key]: program, ...programs } = this.nodePrograms;\n      program.kill();\n      this.nodePrograms = programs;\n    }\n    if (this.nodeHoverPrograms[key]) {\n      const { [key]: program, ...programs } = this.nodeHoverPrograms;\n      program.kill();\n      this.nodePrograms = programs;\n    }\n    return this;\n  }\n\n  /**\n   * Internal function used to unregister an edge program\n   *\n   * @param  {string} key - The program's key, matching the related edges \"type\" values.\n   * @return {Sigma}\n   */\n  private unregisterEdgeProgram(key: string): this {\n    if (this.edgePrograms[key]) {\n      const { [key]: program, ...programs } = this.edgePrograms;\n      program.kill();\n      this.edgePrograms = programs;\n    }\n    return this;\n  }\n\n  /**\n   * Method (re)binding WebGL texture (for picking).\n   *\n   * @return {Sigma}\n   */\n  private resetWebGLTexture(id: string): this {\n    const gl = this.webGLContexts[id] as WebGLRenderingContext;\n\n    const frameBuffer = this.frameBuffers[id];\n    const currentTexture = this.textures[id];\n    if (currentTexture) gl.deleteTexture(currentTexture);\n\n    const pickingTexture = gl.createTexture();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n\n    this.textures[id] = pickingTexture as WebGLTexture;\n\n    return this;\n  }\n\n  /**\n   * Method binding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  private bindCameraHandlers(): this {\n    this.activeListeners.camera = () => {\n      this.scheduleRender();\n    };\n\n    this.camera.on(\"updated\", this.activeListeners.camera);\n\n    return this;\n  }\n\n  /**\n   * Method unbinding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  private unbindCameraHandlers(): this {\n    this.camera.removeListener(\"updated\", this.activeListeners.camera);\n    return this;\n  }\n\n  /**\n   * Method that returns the closest node to a given position.\n   */\n  private getNodeAtPosition(position: Coordinates): string | null {\n    const { x, y } = position;\n    const color = getPixelColor(\n      this.webGLContexts.nodes,\n      this.frameBuffers.nodes,\n      x,\n      y,\n      this.pixelRatio,\n      this.pickingDownSizingRatio,\n    );\n    const index = colorToIndex(...color);\n    const itemAt = this.itemIDsIndex[index];\n\n    return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n  }\n\n  /**\n   * Method binding event handlers.\n   *\n   * @return {Sigma}\n   */\n  private bindEventHandlers(): this {\n    // Handling window resize\n    this.activeListeners.handleResize = () => {\n      // need to call a refresh to rebuild the labelgrid\n      this.scheduleRefresh();\n    };\n\n    window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n    // Handling mouse move\n    this.activeListeners.handleMove = (e: MouseCoords | TouchCoords): void => {\n      const event = cleanMouseCoords(e);\n\n      const baseEvent = {\n        event,\n        preventSigmaDefault(): void {\n          event.preventSigmaDefault();\n        },\n      };\n\n      const nodeToHover = this.getNodeAtPosition(event);\n      if (nodeToHover && this.hoveredNode !== nodeToHover && !this.nodeDataCache[nodeToHover].hidden) {\n        // Handling passing from one node to the other directly\n        if (this.hoveredNode) this.emit(\"leaveNode\", { ...baseEvent, node: this.hoveredNode });\n\n        this.hoveredNode = nodeToHover;\n        this.emit(\"enterNode\", { ...baseEvent, node: nodeToHover });\n        this.scheduleHighlightedNodesRender();\n        return;\n      }\n\n      // Checking if the hovered node is still hovered\n      if (this.hoveredNode) {\n        if (this.getNodeAtPosition(event) !== this.hoveredNode) {\n          const node = this.hoveredNode;\n          this.hoveredNode = null;\n\n          this.emit(\"leaveNode\", { ...baseEvent, node });\n          this.scheduleHighlightedNodesRender();\n          return;\n        }\n      }\n\n      if (this.settings.enableEdgeEvents) {\n        const edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n\n        if (edgeToHover !== this.hoveredEdge) {\n          if (this.hoveredEdge) this.emit(\"leaveEdge\", { ...baseEvent, edge: this.hoveredEdge });\n          if (edgeToHover) this.emit(\"enterEdge\", { ...baseEvent, edge: edgeToHover });\n          this.hoveredEdge = edgeToHover;\n        }\n      }\n    };\n\n    // Handling mouse move over body (only to dispatch the proper event):\n    this.activeListeners.handleMoveBody = (e: MouseCoords | TouchCoords): void => {\n      const event = cleanMouseCoords(e);\n\n      this.emit(\"moveBody\", {\n        event,\n        preventSigmaDefault(): void {\n          event.preventSigmaDefault();\n        },\n      });\n    };\n\n    // Handling mouse leave stage:\n    this.activeListeners.handleLeave = (e: MouseCoords | TouchCoords): void => {\n      const event = cleanMouseCoords(e);\n\n      const baseEvent = {\n        event,\n        preventSigmaDefault(): void {\n          event.preventSigmaDefault();\n        },\n      };\n\n      if (this.hoveredNode) {\n        this.emit(\"leaveNode\", { ...baseEvent, node: this.hoveredNode });\n        this.scheduleHighlightedNodesRender();\n      }\n\n      if (this.settings.enableEdgeEvents && this.hoveredEdge) {\n        this.emit(\"leaveEdge\", { ...baseEvent, edge: this.hoveredEdge });\n        this.scheduleHighlightedNodesRender();\n      }\n\n      this.emit(\"leaveStage\", { ...baseEvent });\n    };\n\n    // Handling mouse enter stage:\n    this.activeListeners.handleEnter = (e: MouseCoords | TouchCoords): void => {\n      const event = cleanMouseCoords(e);\n\n      const baseEvent = {\n        event,\n        preventSigmaDefault(): void {\n          event.preventSigmaDefault();\n        },\n      };\n\n      this.emit(\"enterStage\", { ...baseEvent });\n    };\n\n    // Handling click\n    const createInteractionListener = (eventType: MouseInteraction): ((e: MouseCoords | TouchCoords) => void) => {\n      return (e) => {\n        const event = cleanMouseCoords(e);\n\n        const baseEvent = {\n          event,\n          preventSigmaDefault: () => {\n            event.preventSigmaDefault();\n          },\n        };\n\n        const nodeAtPosition = this.getNodeAtPosition(event);\n\n        if (nodeAtPosition)\n          return this.emit(`${eventType}Node`, {\n            ...baseEvent,\n            node: nodeAtPosition,\n          });\n\n        if (this.settings.enableEdgeEvents) {\n          const edge = this.getEdgeAtPoint(event.x, event.y);\n          if (edge) return this.emit(`${eventType}Edge`, { ...baseEvent, edge });\n        }\n\n        return this.emit(`${eventType}Stage`, baseEvent);\n      };\n    };\n\n    this.activeListeners.handleClick = createInteractionListener(\"click\");\n    this.activeListeners.handleRightClick = createInteractionListener(\"rightClick\");\n    this.activeListeners.handleDoubleClick = createInteractionListener(\"doubleClick\");\n    this.activeListeners.handleWheel = createInteractionListener(\"wheel\");\n    this.activeListeners.handleDown = createInteractionListener(\"down\");\n    this.activeListeners.handleUp = createInteractionListener(\"up\");\n\n    this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n    this.mouseCaptor.on(\"mousemovebody\", this.activeListeners.handleMoveBody);\n    this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n    this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n    this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n    this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n    this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n    this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n    this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n    this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n\n    this.touchCaptor.on(\"touchdown\", this.activeListeners.handleDown);\n    this.touchCaptor.on(\"touchdown\", this.activeListeners.handleMove);\n    this.touchCaptor.on(\"touchup\", this.activeListeners.handleUp);\n    this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMove);\n    this.touchCaptor.on(\"tap\", this.activeListeners.handleClick);\n    this.touchCaptor.on(\"doubletap\", this.activeListeners.handleDoubleClick);\n    this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMoveBody);\n\n    return this;\n  }\n\n  /**\n   * Method binding graph handlers\n   *\n   * @return {Sigma}\n   */\n  private bindGraphHandlers(): this {\n    const graph = this.graph;\n\n    const LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n    this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = (e: { hints?: { attributes?: string[] } }) => {\n      const updatedFields = e.hints?.attributes;\n      // we process all nodes\n      this.graph.forEachNode((node) => this.updateNode(node));\n\n      // if coord, type or zIndex have changed, we need to schedule a render\n      // (zIndex for the programIndex)\n      const layoutChanged = !updatedFields || updatedFields.some((f) => LAYOUT_IMPACTING_FIELDS.has(f));\n      this.refresh({ partialGraph: { nodes: graph.nodes() }, skipIndexation: !layoutChanged, schedule: true });\n    };\n\n    this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = (e: { hints?: { attributes?: string[] } }) => {\n      const updatedFields = e.hints?.attributes;\n      // we process all edges\n      this.graph.forEachEdge((edge) => this.updateEdge(edge));\n      const layoutChanged = updatedFields && [\"zIndex\", \"type\"].some((f) => updatedFields?.includes(f));\n      this.refresh({ partialGraph: { edges: graph.edges() }, skipIndexation: !layoutChanged, schedule: true });\n    };\n\n    // On add node, we add the node in indices and then call for a render\n    this.activeListeners.addNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // we process the node\n      this.addNode(node);\n      // schedule a render for the node\n      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });\n    };\n\n    // On update node, we update indices and then call for a render\n    this.activeListeners.updateNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // schedule a render for the node\n      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });\n    };\n\n    // On drop node, we remove the node from indices and then call for a refresh\n    this.activeListeners.dropNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // we process the node\n      this.removeNode(node);\n      // schedule a render for everything\n      this.refresh({ schedule: true });\n    };\n\n    // On add edge, we remove the edge from indices and then call for a refresh\n    this.activeListeners.addEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // we process the edge\n      this.addEdge(edge);\n      // schedule a render for the edge\n      this.refresh({ partialGraph: { edges: [edge] }, schedule: true });\n    };\n\n    // On update edge, we update indices and then call for a refresh\n    this.activeListeners.updateEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // schedule a repaint for the edge\n      this.refresh({ partialGraph: { edges: [edge] }, skipIndexation: false, schedule: true });\n    };\n\n    // On drop edge, we remove the edge from indices and then call for a refresh\n    this.activeListeners.dropEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // we process the edge\n      this.removeEdge(edge);\n      // schedule a render for all edges\n      this.refresh({ schedule: true });\n    };\n\n    // On clear edges, we clear the edge indices and then call for a refresh\n    this.activeListeners.clearEdgesGraphUpdate = (): void => {\n      // we clear the edge data structures\n      this.clearEdgeState();\n      this.clearEdgeIndices();\n      // schedule a render for all edges\n      this.refresh({ schedule: true });\n    };\n\n    // On graph clear, we clear indices and then call for a refresh\n    this.activeListeners.clearGraphUpdate = (): void => {\n      // clear graph state\n      this.clearEdgeState();\n      this.clearNodeState();\n\n      // clear graph indices\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n\n      // schedule a render for all\n      this.refresh({ schedule: true });\n    };\n\n    graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n    graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n    graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n    graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n    graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n\n    return this;\n  }\n\n  /**\n   * Method used to unbind handlers from the graph.\n   *\n   * @return {undefined}\n   */\n  private unbindGraphHandlers() {\n    const graph = this.graph;\n\n    graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n    graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n    graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n    graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n    graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n  }\n\n  /**\n   * Method looking for an edge colliding with a given point at (x, y). Returns\n   * the key of the edge if any, or null else.\n   */\n  private getEdgeAtPoint(x: number, y: number): string | null {\n    const color = getPixelColor(\n      this.webGLContexts.edges,\n      this.frameBuffers.edges,\n      x,\n      y,\n      this.pixelRatio,\n      this.pickingDownSizingRatio,\n    );\n    const index = colorToIndex(...color);\n    const itemAt = this.itemIDsIndex[index];\n\n    return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n  }\n\n  /**\n   * Method used to process the whole graph's data.\n   *  - extent\n   *  - normalizationFunction\n   *  - compute node's coordinate\n   *  - labelgrid\n   *  - program data allocation\n   * @return {Sigma}\n   */\n  private process(): this {\n    this.emit(\"beforeProcess\");\n\n    const graph = this.graph;\n    const settings = this.settings;\n    const dimensions = this.getDimensions();\n\n    //\n    // NODES\n    //\n    this.nodeExtent = graphExtent(this.graph);\n    if (!this.settings.autoRescale) {\n      const { width, height } = dimensions;\n      const { x, y } = this.nodeExtent;\n\n      this.nodeExtent = {\n        x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],\n        y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2],\n      };\n    }\n\n    this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n    // NOTE: it is important to compute this matrix after computing the node's extent\n    // because #.getGraphDimensions relies on it\n    const nullCamera = new Camera();\n    const nullCameraMatrix = matrixFromCamera(\n      nullCamera.getState(),\n      dimensions,\n      this.getGraphDimensions(),\n      this.getStagePadding(),\n    );\n    // Resetting the label grid\n    // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n\n    const nodesPerPrograms: Record<string, number> = {};\n    const nodeIndices: typeof this.nodeIndices = {};\n    const edgeIndices: typeof this.edgeIndices = {};\n    const itemIDsIndex: typeof this.itemIDsIndex = {};\n    let incrID = 1;\n\n    let nodes = graph.nodes();\n\n    // Do some indexation on the whole graph\n    for (let i = 0, l = nodes.length; i < l; i++) {\n      const node = nodes[i];\n      const data = this.nodeDataCache[node];\n\n      // Get initial coordinates\n      const attrs = graph.getNodeAttributes(node);\n      data.x = attrs.x;\n      data.y = attrs.y;\n      this.normalizationFunction.applyTo(data);\n\n      // labelgrid\n      if (typeof data.label === \"string\" && !data.hidden)\n        this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));\n\n      // update count per program\n      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n    }\n    this.labelGrid.organize();\n\n    // Allocate memory to programs\n    for (const type in this.nodePrograms) {\n      if (!hasOwnProperty.call(this.nodePrograms, type)) {\n        throw new Error(`Sigma: could not find a suitable program for node type \"${type}\"!`);\n      }\n      this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      nodesPerPrograms[type] = 0;\n    }\n\n    // Order nodes by zIndex before to add them to program\n    if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1])\n      nodes = zIndexOrdering<string>(\n        this.nodeZExtent,\n        (node: string): number => this.nodeDataCache[node].zIndex,\n        nodes,\n      );\n\n    // Add data to programs\n    for (let i = 0, l = nodes.length; i < l; i++) {\n      const node = nodes[i];\n\n      nodeIndices[node] = incrID;\n      itemIDsIndex[nodeIndices[node]] = { type: \"node\", id: node };\n      incrID++;\n\n      const data = this.nodeDataCache[node];\n      this.addNodeToProgram(node, nodeIndices[node], nodesPerPrograms[data.type]++);\n    }\n\n    //\n    // EDGES\n    //\n\n    const edgesPerPrograms: Record<string, number> = {};\n    let edges = graph.edges();\n\n    // Allocate memory to programs\n    for (let i = 0, l = edges.length; i < l; i++) {\n      const edge = edges[i];\n      const data = this.edgeDataCache[edge];\n      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n    }\n\n    // Order edges by zIndex before to add them to program\n    if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1])\n      edges = zIndexOrdering<string>(\n        this.edgeZExtent,\n        (edge: string): number => this.edgeDataCache[edge].zIndex,\n        edges,\n      );\n\n    for (const type in this.edgePrograms) {\n      if (!hasOwnProperty.call(this.edgePrograms, type)) {\n        throw new Error(`Sigma: could not find a suitable program for edge type \"${type}\"!`);\n      }\n      this.edgePrograms[type].reallocate(edgesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      edgesPerPrograms[type] = 0;\n    }\n\n    // Add data to programs\n    for (let i = 0, l = edges.length; i < l; i++) {\n      const edge = edges[i];\n\n      edgeIndices[edge] = incrID;\n      itemIDsIndex[edgeIndices[edge]] = { type: \"edge\", id: edge };\n      incrID++;\n\n      const data = this.edgeDataCache[edge];\n      this.addEdgeToProgram(edge, edgeIndices[edge], edgesPerPrograms[data.type]++);\n    }\n\n    this.itemIDsIndex = itemIDsIndex;\n    this.nodeIndices = nodeIndices;\n    this.edgeIndices = edgeIndices;\n\n    this.emit(\"afterProcess\");\n    return this;\n  }\n\n  /**\n   * Method that backports potential settings updates where it's needed.\n   * @private\n   */\n  private handleSettingsUpdate(oldSettings?: Settings<N, E, G>): this {\n    const settings = this.settings;\n\n    this.camera.minRatio = settings.minCameraRatio;\n    this.camera.maxRatio = settings.maxCameraRatio;\n    this.camera.enabledRotation = settings.enableCameraRotation;\n    this.camera.setState(this.camera.validateState(this.camera.getState()));\n\n    if (oldSettings) {\n      // Check edge programs:\n      if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {\n        for (const type in settings.edgeProgramClasses) {\n          if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {\n            this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);\n          }\n        }\n        for (const type in oldSettings.edgeProgramClasses) {\n          if (!settings.edgeProgramClasses[type]) this.unregisterEdgeProgram(type);\n        }\n      }\n\n      // Check node programs:\n      if (\n        oldSettings.nodeProgramClasses !== settings.nodeProgramClasses ||\n        oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses\n      ) {\n        for (const type in settings.nodeProgramClasses) {\n          if (\n            settings.nodeProgramClasses[type] !== oldSettings.nodeProgramClasses[type] ||\n            settings.nodeHoverProgramClasses[type] !== oldSettings.nodeHoverProgramClasses[type]\n          ) {\n            this.registerNodeProgram(type, settings.nodeProgramClasses[type], settings.nodeHoverProgramClasses[type]);\n          }\n        }\n        for (const type in oldSettings.nodeProgramClasses) {\n          if (!settings.nodeProgramClasses[type]) this.unregisterNodeProgram(type);\n        }\n      }\n    }\n\n    // Update captors settings:\n    this.mouseCaptor.setSettings(this.settings);\n    this.touchCaptor.setSettings(this.settings);\n\n    return this;\n  }\n\n  /**\n   * Method used to render labels.\n   *\n   * @return {Sigma}\n   */\n  private renderLabels(): this {\n    if (!this.settings.renderLabels) return this;\n\n    const cameraState = this.camera.getState();\n\n    // Selecting labels to draw\n    const labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n    extend(labelsToDisplay, this.nodesWithForcedLabels);\n\n    this.displayedNodeLabels = new Set();\n\n    // Drawing labels\n    const context = this.canvasContexts.labels;\n\n    for (let i = 0, l = labelsToDisplay.length; i < l; i++) {\n      const node = labelsToDisplay[i];\n      const data = this.nodeDataCache[node];\n\n      // If the node was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      // NOTE: we can do better probably\n      if (this.displayedNodeLabels.has(node)) continue;\n\n      // If the node is hidden, we don't need to display its label obviously\n      if (data.hidden) continue;\n\n      const { x, y } = this.framedGraphToViewport(data);\n\n      // NOTE: we can cache the labels we need to render until the camera's ratio changes\n      const size = this.scaleSize(data.size);\n\n      // Is node big enough?\n      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n      // Is node actually on screen (with some margin)\n      // NOTE: we used to rely on the quadtree for this, but the coordinates\n      // conversion make it unreliable and at that point we already converted\n      // to viewport coordinates and since the label grid already culls the\n      // number of potential labels to display this looks like a good\n      // performance compromise.\n      // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n      // considering cells obviously outside of the range of the current\n      // view rectangle.\n      if (\n        x < -X_LABEL_MARGIN ||\n        x > this.width + X_LABEL_MARGIN ||\n        y < -Y_LABEL_MARGIN ||\n        y > this.height + Y_LABEL_MARGIN\n      )\n        continue;\n\n      // Because displayed edge labels depend directly on actually rendered node\n      // labels, we need to only add to this.displayedNodeLabels nodes whose label\n      // is rendered.\n      // This makes this.displayedNodeLabels depend on viewport, which might become\n      // an issue once we start memoizing getLabelsToDisplay.\n      this.displayedNodeLabels.add(node);\n\n      const { defaultDrawNodeLabel } = this.settings;\n      const nodeProgram = this.nodePrograms[data.type];\n      const drawLabel = nodeProgram?.drawLabel || defaultDrawNodeLabel;\n      drawLabel(\n        context,\n        {\n          key: node,\n          ...data,\n          size,\n          x,\n          y,\n        },\n        this.settings,\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to render edge labels, based on which node labels were\n   * rendered.\n   *\n   * @return {Sigma}\n   */\n  private renderEdgeLabels(): this {\n    if (!this.settings.renderEdgeLabels) return this;\n\n    const context = this.canvasContexts.edgeLabels;\n\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n\n    const edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n      graph: this.graph,\n      hoveredNode: this.hoveredNode,\n      displayedNodeLabels: this.displayedNodeLabels,\n      highlightedNodes: this.highlightedNodes,\n    });\n    extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n\n    const displayedLabels = new Set<string>();\n    for (let i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n      const edge = edgeLabelsToDisplay[i],\n        extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]],\n        edgeData = this.edgeDataCache[edge];\n\n      // If the edge was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      if (displayedLabels.has(edge)) continue;\n\n      // If the edge is hidden we don't need to display its label\n      // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n        continue;\n      }\n\n      const { defaultDrawEdgeLabel } = this.settings;\n      const edgeProgram = this.edgePrograms[edgeData.type];\n      const drawLabel = edgeProgram?.drawLabel || defaultDrawEdgeLabel;\n      drawLabel(\n        context,\n        {\n          key: edge,\n          ...edgeData,\n          size: this.scaleSize(edgeData.size),\n        },\n        {\n          key: extremities[0],\n          ...sourceData,\n          ...this.framedGraphToViewport(sourceData),\n          size: this.scaleSize(sourceData.size),\n        },\n        {\n          key: extremities[1],\n          ...targetData,\n          ...this.framedGraphToViewport(targetData),\n          size: this.scaleSize(targetData.size),\n        },\n        this.settings,\n      );\n      displayedLabels.add(edge);\n    }\n\n    this.displayedEdgeLabels = displayedLabels;\n\n    return this;\n  }\n\n  /**\n   * Method used to render the highlighted nodes.\n   *\n   * @return {Sigma}\n   */\n  private renderHighlightedNodes(): void {\n    const context = this.canvasContexts.hovers;\n\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n\n    // Rendering\n    const render = (node: string): void => {\n      const data = this.nodeDataCache[node];\n\n      const { x, y } = this.framedGraphToViewport(data);\n\n      const size = this.scaleSize(data.size);\n\n      const { defaultDrawNodeHover } = this.settings;\n      const nodeProgram = this.nodePrograms[data.type];\n      const drawHover = nodeProgram?.drawHover || defaultDrawNodeHover;\n      drawHover(\n        context,\n        {\n          key: node,\n          ...data,\n          size,\n          x,\n          y,\n        },\n        this.settings,\n      );\n    };\n\n    const nodesToRender: string[] = [];\n\n    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n      nodesToRender.push(this.hoveredNode);\n    }\n\n    this.highlightedNodes.forEach((node) => {\n      // The hovered node has already been highlighted\n      if (node !== this.hoveredNode) nodesToRender.push(node);\n    });\n\n    // Draw labels:\n    nodesToRender.forEach((node) => render(node));\n\n    // Draw WebGL nodes on top of the labels:\n    const nodesPerPrograms: Record<string, number> = {};\n\n    // 1. Count nodes per type:\n    nodesToRender.forEach((node) => {\n      const type = this.nodeDataCache[node].type;\n      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n    });\n    // 2. Allocate for each type for the proper number of nodes\n    for (const type in this.nodeHoverPrograms) {\n      this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // Also reset count, to use when rendering:\n      nodesPerPrograms[type] = 0;\n    }\n    // 3. Process all nodes to render:\n    nodesToRender.forEach((node) => {\n      const data = this.nodeDataCache[node];\n      this.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n    });\n    // 4. Clear hovered nodes layer:\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    // 5. Render:\n    const renderParams = this.getRenderParams();\n    for (const type in this.nodeHoverPrograms) {\n      const program = this.nodeHoverPrograms[type];\n      program.render(renderParams);\n    }\n  }\n\n  /**\n   * Method used to schedule a hover render.\n   *\n   */\n  private scheduleHighlightedNodesRender(): void {\n    if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n\n    this.renderHighlightedNodesFrame = requestAnimationFrame(() => {\n      // Resetting state\n      this.renderHighlightedNodesFrame = null;\n\n      // Rendering\n      this.renderHighlightedNodes();\n      this.renderEdgeLabels();\n    });\n  }\n\n  /**\n   * Method used to render.\n   *\n   * @return {Sigma}\n   */\n  private render(): this {\n    this.emit(\"beforeRender\");\n\n    const exitRender = () => {\n      this.emit(\"afterRender\");\n      return this;\n    };\n\n    // If a render was scheduled, we cancel it\n    if (this.renderFrame) {\n      cancelAnimationFrame(this.renderFrame);\n      this.renderFrame = null;\n    }\n\n    // First we need to resize\n    this.resize();\n\n    // Do we need to reprocess data?\n    if (this.needToProcess) this.process();\n    this.needToProcess = false;\n\n    // Clearing the canvases\n    this.clear();\n\n    // Prepare the textures\n    this.pickingLayers.forEach((layer) => this.resetWebGLTexture(layer));\n\n    // If we have no nodes we can stop right there\n    if (!this.graph.order) return exitRender();\n\n    // TODO: improve this heuristic or move to the captor itself?\n    // TODO: deal with the touch captor here as well\n    const mouseCaptor = this.mouseCaptor;\n    const moving =\n      this.camera.isAnimated() ||\n      mouseCaptor.isMoving ||\n      mouseCaptor.draggedEvents ||\n      mouseCaptor.currentWheelDirection;\n\n    // Then we need to extract a matrix from the camera\n    const cameraState = this.camera.getState();\n    const viewportDimensions = this.getDimensions();\n    const graphDimensions = this.getGraphDimensions();\n    const padding = this.getStagePadding();\n    this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n    this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n    this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n    this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n    // [jacomyal]\n    // This comment is related to the one above the `getMatrixImpact` definition:\n    // - `this.correctionRatio` is somehow not completely explained\n    // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n    //   graph\n    // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n    // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n    // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:\n    // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n    const params: RenderParams = this.getRenderParams();\n\n    // Drawing nodes\n    for (const type in this.nodePrograms) {\n      const program = this.nodePrograms[type];\n      program.render(params);\n    }\n\n    // Drawing edges\n    if (!this.settings.hideEdgesOnMove || !moving) {\n      for (const type in this.edgePrograms) {\n        const program = this.edgePrograms[type];\n        program.render(params);\n      }\n    }\n\n    // Do not display labels on move per setting\n    if (this.settings.hideLabelsOnMove && moving) return exitRender();\n\n    this.renderLabels();\n    this.renderEdgeLabels();\n    this.renderHighlightedNodes();\n\n    return exitRender();\n  }\n\n  /**\n   * Add a node in the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private addNode(key: string): void {\n    // Node display data resolution:\n    //  1. First we get the node's attributes\n    //  2. We optionally reduce them using the function provided by the user\n    //     Note that this function must return a total object and won't be merged\n    //  3. We apply our defaults, while running some vital checks\n    //  4. We apply the normalization function\n    // We shallow copy node data to avoid dangerous behaviors from reducers\n    let attr = Object.assign({}, this.graph.getNodeAttributes(key)) as Partial<NodeDisplayData>;\n    if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr as N);\n    const data = applyNodeDefaults(this.settings, key, attr);\n    this.nodeDataCache[key] = data;\n\n    // Label:\n    // We delete and add if needed because this function is also used from\n    // update\n    this.nodesWithForcedLabels.delete(key);\n    if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n    // Highlighted:\n    // We remove and re add if needed because this function is also used from\n    // update\n    this.highlightedNodes.delete(key);\n    if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n    // zIndex\n    if (this.settings.zIndex) {\n      if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n      if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n    }\n  }\n\n  /**\n   * Update a node the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private updateNode(key: string): void {\n    this.addNode(key);\n\n    // Re-apply normalization on the node\n    const data = this.nodeDataCache[key];\n    this.normalizationFunction.applyTo(data);\n  }\n\n  /**\n   * Remove a node from the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private removeNode(key: string): void {\n    // Remove from node cache\n    delete this.nodeDataCache[key];\n    // Remove from node program index\n    delete this.nodeProgramIndex[key];\n    // Remove from higlighted nodes\n    this.highlightedNodes.delete(key);\n    // Remove from hovered\n    if (this.hoveredNode === key) this.hoveredNode = null;\n    // Remove from forced label\n    this.nodesWithForcedLabels.delete(key);\n  }\n\n  /**\n   * Add an edge into the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private addEdge(key: string): void {\n    // Edge display data resolution:\n    //  1. First we get the edge's attributes\n    //  2. We optionally reduce them using the function provided by the user\n    //  3. Note that this function must return a total object and won't be merged\n    //  4. We apply our defaults, while running some vital checks\n    // We shallow copy edge data to avoid dangerous behaviors from reducers\n    let attr = Object.assign({}, this.graph.getEdgeAttributes(key)) as Partial<EdgeDisplayData>;\n    if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr as E);\n    const data = applyEdgeDefaults(this.settings, key, attr);\n    this.edgeDataCache[key] = data;\n\n    // Forced label\n    // we filter and re push if needed because this function is also used from\n    // update\n    this.edgesWithForcedLabels.delete(key);\n    if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n    // Check zIndex\n    if (this.settings.zIndex) {\n      if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n      if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n    }\n  }\n\n  /**\n   * Update an edge in the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private updateEdge(key: string): void {\n    this.addEdge(key);\n  }\n\n  /**\n   * Remove an edge from the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private removeEdge(key: string): void {\n    // Remove from edge cache\n    delete this.edgeDataCache[key];\n    // Remove from programId index\n    delete this.edgeProgramIndex[key];\n    // Remove from hovered\n    if (this.hoveredEdge === key) this.hoveredEdge = null;\n    // Remove from forced label\n    this.edgesWithForcedLabels.delete(key);\n  }\n\n  /**\n   * Clear all indices related to nodes.\n   * @private\n   */\n  private clearNodeIndices(): void {\n    // LabelGrid & nodeExtent are only manage/populated in the process function\n    this.labelGrid = new LabelGrid();\n    this.nodeExtent = { x: [0, 1], y: [0, 1] };\n    this.nodeDataCache = {};\n    this.edgeProgramIndex = {};\n    this.nodesWithForcedLabels = new Set<string>();\n    this.nodeZExtent = [Infinity, -Infinity];\n  }\n\n  /**\n   * Clear all indices related to edges.\n   * @private\n   */\n  private clearEdgeIndices(): void {\n    this.edgeDataCache = {};\n    this.edgeProgramIndex = {};\n    this.edgesWithForcedLabels = new Set<string>();\n    this.edgeZExtent = [Infinity, -Infinity];\n  }\n\n  /**\n   * Clear all indices.\n   * @private\n   */\n  private clearIndices(): void {\n    this.clearEdgeIndices();\n    this.clearNodeIndices();\n  }\n\n  /**\n   * Clear all graph state related to nodes.\n   * @private\n   */\n  private clearNodeState(): void {\n    this.displayedNodeLabels = new Set();\n    this.highlightedNodes = new Set();\n    this.hoveredNode = null;\n  }\n\n  /**\n   * Clear all graph state related to edges.\n   * @private\n   */\n  private clearEdgeState(): void {\n    this.displayedEdgeLabels = new Set();\n    this.highlightedNodes = new Set();\n    this.hoveredEdge = null;\n  }\n\n  /**\n   * Clear all graph state.\n   * @private\n   */\n  private clearState(): void {\n    this.clearEdgeState();\n    this.clearNodeState();\n  }\n\n  /**\n   * Add the node data to its program.\n   * @private\n   * @param node The node's graphology ID\n   * @param fingerprint A fingerprint used to identity the node with picking\n   * @param position The index where to place the node in the program\n   */\n  private addNodeToProgram(node: string, fingerprint: number, position: number): void {\n    const data = this.nodeDataCache[node];\n    const nodeProgram = this.nodePrograms[data.type];\n    if (!nodeProgram) throw new Error(`Sigma: could not find a suitable program for node type \"${data.type}\"!`);\n    nodeProgram.process(fingerprint, position, data);\n    // Saving program index\n    this.nodeProgramIndex[node] = position;\n  }\n\n  /**\n   * Add the edge data to its program.\n   * @private\n   * @param edge The edge's graphology ID\n   * @param fingerprint A fingerprint used to identity the edge with picking\n   * @param position The index where to place the edge in the program\n   */\n  private addEdgeToProgram(edge: string, fingerprint: number, position: number): void {\n    const data = this.edgeDataCache[edge];\n    const edgeProgram = this.edgePrograms[data.type];\n    if (!edgeProgram) throw new Error(`Sigma: could not find a suitable program for edge type \"${data.type}\"!`);\n    const extremities = this.graph.extremities(edge),\n      sourceData = this.nodeDataCache[extremities[0]],\n      targetData = this.nodeDataCache[extremities[1]];\n    edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n    // Saving program index\n    this.edgeProgramIndex[edge] = position;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Public API.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Function used to get the render params.\n   *\n   * @return {RenderParams}\n   */\n  getRenderParams(): RenderParams {\n    return {\n      matrix: this.matrix,\n      invMatrix: this.invMatrix,\n      width: this.width,\n      height: this.height,\n      pixelRatio: this.pixelRatio,\n      zoomRatio: this.camera.ratio,\n      cameraAngle: this.camera.angle,\n      sizeRatio: 1 / this.scaleSize(),\n      correctionRatio: this.correctionRatio,\n      downSizingRatio: this.pickingDownSizingRatio,\n      minEdgeThickness: this.settings.minEdgeThickness,\n      antiAliasingFeather: this.settings.antiAliasingFeather,\n    };\n  }\n\n  /**\n   * Function used to retrieve the actual stage padding value.\n   *\n   * @return {number}\n   */\n  getStagePadding(): number {\n    const { stagePadding, autoRescale } = this.settings;\n    return autoRescale ? stagePadding || 0 : 0;\n  }\n\n  /**\n   * Function used to create a canvas element.\n   *\n   * @param {string} id - Context's id.\n   * @param options\n   * @return {Sigma}\n   */\n  createCanvas(\n    id: string,\n    options: { style?: Partial<CSSStyleDeclaration> } & ({ beforeLayer?: string } | { afterLayer?: string }) = {},\n  ): HTMLCanvasElement {\n    if (this.elements[id]) throw new Error(`Sigma: a layer named \"${id}\" already exists`);\n\n    const canvas: HTMLCanvasElement = createElement<HTMLCanvasElement>(\n      \"canvas\",\n      {\n        position: \"absolute\",\n      },\n      {\n        class: `sigma-${id}`,\n      },\n    );\n\n    if (options.style) Object.assign(canvas.style, options.style);\n\n    this.elements[id] = canvas;\n\n    if (\"beforeLayer\" in options && options.beforeLayer) {\n      this.elements[options.beforeLayer].before(canvas);\n    } else if (\"afterLayer\" in options && options.afterLayer) {\n      this.elements[options.afterLayer].after(canvas);\n    } else {\n      this.container.appendChild(canvas);\n    }\n\n    return canvas;\n  }\n\n  /**\n   * Function used to create a canvas context and add the relevant DOM elements.\n   *\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  createCanvasContext(id: string, options: { style?: Partial<CSSStyleDeclaration> } = {}): this {\n    const canvas = this.createCanvas(id, options);\n\n    const contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false,\n    };\n\n    this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions) as CanvasRenderingContext2D;\n\n    return this;\n  }\n\n  /**\n   * Function used to create a WebGL context and add the relevant DOM\n   * elements.\n   *\n   * @param  {string}  id      - Context's id.\n   * @param  {object?} options - #getContext params to override (optional)\n   * @return {WebGLRenderingContext}\n   */\n  createWebGLContext(\n    id: string,\n    options: {\n      preserveDrawingBuffer?: boolean;\n      antialias?: boolean;\n      hidden?: boolean;\n      picking?: boolean;\n    } & ({ canvas?: HTMLCanvasElement; style?: undefined } | { style?: CSSStyleDeclaration; canvas?: undefined }) = {},\n  ): WebGLRenderingContext {\n    const canvas = options?.canvas || this.createCanvas(id, options);\n    if (options.hidden) canvas.remove();\n\n    const contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false,\n      ...options,\n    };\n\n    let context;\n\n    // First we try webgl2 for an easy performance boost\n    context = canvas.getContext(\"webgl2\", contextOptions);\n\n    // Else we fall back to webgl\n    if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n    // Edge, I am looking right at you...\n    if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n\n    const gl = context as WebGLRenderingContext;\n    this.webGLContexts[id] = gl;\n\n    // Blending:\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    // Prepare frame buffer for picking layers:\n    if (options.picking) {\n      this.pickingLayers.add(id);\n      const newFrameBuffer = gl.createFramebuffer();\n      if (!newFrameBuffer) throw new Error(`Sigma: cannot create a new frame buffer for layer ${id}`);\n      this.frameBuffers[id] = newFrameBuffer;\n    }\n\n    return gl;\n  }\n\n  /**\n   * Function used to properly kill a canvas layer.\n   *\n   * @param  {string} id - Layer id.\n   * @return {Sigma}\n   */\n  killLayer(id: string): this {\n    const canvas = this.elements[id];\n\n    if (!canvas) throw new Error(`Sigma: cannot kill layer ${id}, which does not exist`);\n\n    if (this.webGLContexts[id]) {\n      const gl = this.webGLContexts[id];\n      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n      delete this.webGLContexts[id];\n    } else {\n      delete this.canvasContexts[id];\n    }\n\n    // Delete canvas:\n    canvas.remove();\n    delete this.elements[id];\n\n    return this;\n  }\n\n  /**\n   * Method returning the renderer's camera.\n   *\n   * @return {Camera}\n   */\n  getCamera(): Camera {\n    return this.camera;\n  }\n\n  /**\n   * Method setting the renderer's camera.\n   *\n   * @param  {Camera} camera - New camera.\n   * @return {Sigma}\n   */\n  setCamera(camera: Camera): void {\n    this.unbindCameraHandlers();\n    this.camera = camera;\n    this.bindCameraHandlers();\n  }\n\n  /**\n   * Method returning the container DOM element.\n   *\n   * @return {HTMLElement}\n   */\n  getContainer(): HTMLElement {\n    return this.container;\n  }\n\n  /**\n   * Method returning the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  getGraph(): Graph<N, E, G> {\n    return this.graph;\n  }\n\n  /**\n   * Method used to set the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  setGraph(graph: Graph<N, E, G>): void {\n    if (graph === this.graph) return;\n\n    // Unbinding handlers on the current graph\n    this.unbindGraphHandlers();\n\n    if (this.checkEdgesEventsFrame !== null) {\n      cancelAnimationFrame(this.checkEdgesEventsFrame);\n      this.checkEdgesEventsFrame = null;\n    }\n\n    // Installing new graph\n    this.graph = graph;\n\n    // Binding new handlers\n    this.bindGraphHandlers();\n\n    // Re-rendering now to avoid discrepancies from now to next frame\n    this.refresh();\n  }\n\n  /**\n   * Method returning the mouse captor.\n   *\n   * @return {MouseCaptor}\n   */\n  getMouseCaptor(): MouseCaptor<N, E, G> {\n    return this.mouseCaptor;\n  }\n\n  /**\n   * Method returning the touch captor.\n   *\n   * @return {TouchCaptor}\n   */\n  getTouchCaptor(): TouchCaptor<N, E, G> {\n    return this.touchCaptor;\n  }\n\n  /**\n   * Method returning the current renderer's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  getDimensions(): Dimensions {\n    return { width: this.width, height: this.height };\n  }\n\n  /**\n   * Method returning the current graph's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  getGraphDimensions(): Dimensions {\n    const extent = this.customBBox || this.nodeExtent;\n\n    return {\n      width: extent.x[1] - extent.x[0] || 1,\n      height: extent.y[1] - extent.y[0] || 1,\n    };\n  }\n\n  /**\n   * Method used to get all the sigma node attributes.\n   * It's useful for example to get the position of a node\n   * and to get values that are set by the nodeReducer\n   *\n   * @param  {string} key - The node's key.\n   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n   */\n  getNodeDisplayData(key: unknown): NodeDisplayData | undefined {\n    const node = this.nodeDataCache[key as string];\n    return node ? Object.assign({}, node) : undefined;\n  }\n\n  /**\n   * Method used to get all the sigma edge attributes.\n   * It's useful for example to get values that are set by the edgeReducer.\n   *\n   * @param  {string} key - The edge's key.\n   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n   */\n  getEdgeDisplayData(key: unknown): EdgeDisplayData | undefined {\n    const edge = this.edgeDataCache[key as string];\n    return edge ? Object.assign({}, edge) : undefined;\n  }\n\n  /**\n   * Method used to get the set of currently displayed node labels.\n   *\n   * @return {Set<string>} A set of node keys whose label is displayed.\n   */\n  getNodeDisplayedLabels(): Set<string> {\n    return new Set(this.displayedNodeLabels);\n  }\n\n  /**\n   * Method used to get the set of currently displayed edge labels.\n   *\n   * @return {Set<string>} A set of edge keys whose label is displayed.\n   */\n  getEdgeDisplayedLabels(): Set<string> {\n    return new Set(this.displayedEdgeLabels);\n  }\n\n  /**\n   * Method returning a copy of the settings collection.\n   *\n   * @return {Settings} A copy of the settings collection.\n   */\n  getSettings(): Settings<N, E, G> {\n    return { ...this.settings };\n  }\n\n  /**\n   * Method returning the current value for a given setting key.\n   *\n   * @param  {string} key - The setting key to get.\n   * @return {any} The value attached to this setting key or undefined if not found\n   */\n  getSetting<K extends keyof Settings<N, E, G>>(key: K): Settings<N, E, G>[K] {\n    return this.settings[key];\n  }\n\n  /**\n   * Method setting the value of a given setting key. Note that this will schedule\n   * a new render next frame.\n   *\n   * @param  {string} key - The setting key to set.\n   * @param  {any}    value - The value to set.\n   * @return {Sigma}\n   */\n  setSetting<K extends keyof Settings<N, E, G>>(key: K, value: Settings<N, E, G>[K]): this {\n    const oldValues = { ...this.settings };\n    this.settings[key] = value;\n    validateSettings(this.settings);\n    this.handleSettingsUpdate(oldValues);\n    this.scheduleRefresh();\n    return this;\n  }\n\n  /**\n   * Method updating the value of a given setting key using the provided function.\n   * Note that this will schedule a new render next frame.\n   *\n   * @param  {string}   key     - The setting key to set.\n   * @param  {function} updater - The update function.\n   * @return {Sigma}\n   */\n  updateSetting<K extends keyof Settings<N, E, G>>(\n    key: K,\n    updater: (value: Settings<N, E, G>[K]) => Settings<N, E, G>[K],\n  ): this {\n    this.setSetting(key, updater(this.settings[key]));\n    return this;\n  }\n\n  /**\n   * Method used to resize the renderer.\n   *\n   * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).\n   * @return {Sigma}\n   */\n  resize(force?: boolean): this {\n    const previousWidth = this.width,\n      previousHeight = this.height;\n\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    this.pixelRatio = getPixelRatio();\n\n    if (this.width === 0) {\n      if (this.settings.allowInvalidContainer) this.width = 1;\n      else\n        throw new Error(\n          \"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\",\n        );\n    }\n\n    if (this.height === 0) {\n      if (this.settings.allowInvalidContainer) this.height = 1;\n      else\n        throw new Error(\n          \"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\",\n        );\n    }\n\n    // If nothing has changed, we can stop right here\n    if (!force && previousWidth === this.width && previousHeight === this.height) return this;\n\n    this.emit(\"resize\");\n\n    // Sizing dom elements\n    for (const id in this.elements) {\n      const element = this.elements[id];\n\n      element.style.width = this.width + \"px\";\n      element.style.height = this.height + \"px\";\n    }\n\n    // Sizing canvas contexts\n    for (const id in this.canvasContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n\n      if (this.pixelRatio !== 1) this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n    }\n\n    // Sizing WebGL contexts\n    for (const id in this.webGLContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n\n      const gl = this.webGLContexts[id];\n      gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n      // Clear picking texture if needed\n      if (this.pickingLayers.has(id)) {\n        const currentTexture = this.textures[id];\n        if (currentTexture) gl.deleteTexture(currentTexture);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to clear all the canvases.\n   *\n   * @return {Sigma}\n   */\n  clear(): this {\n    this.emit(\"beforeClear\");\n\n    this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n    this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n    this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n\n    this.emit(\"afterClear\");\n    return this;\n  }\n\n  /**\n   * Method used to refresh, i.e. force the renderer to reprocess graph\n   * data and render, but keep the state.\n   * - if a partialGraph is provided, we only reprocess those nodes & edges.\n   * - if schedule is TRUE, we schedule a render instead of sync render\n   * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n   *\n   * @return {Sigma}\n   */\n  refresh(opts?: {\n    partialGraph?: { nodes?: string[]; edges?: string[] };\n    schedule?: boolean;\n    skipIndexation?: boolean;\n  }): this {\n    const skipIndexation = opts?.skipIndexation !== undefined ? opts?.skipIndexation : false;\n    const schedule = opts?.schedule !== undefined ? opts.schedule : false;\n    const fullRefresh = !opts || !opts.partialGraph;\n\n    if (fullRefresh) {\n      // Re-index graph data\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n      this.graph.forEachNode((node) => this.addNode(node));\n      this.graph.forEachEdge((edge) => this.addEdge(edge));\n    } else {\n      const nodes = opts.partialGraph?.nodes || [];\n      for (let i = 0, l = nodes?.length || 0; i < l; i++) {\n        const node = nodes[i];\n        // Recompute node's data (ie. apply reducer)\n        this.updateNode(node);\n        // Add node to the program if layout is unchanged.\n        // otherwise it will be done in the process function\n        if (skipIndexation) {\n          const programIndex = this.nodeProgramIndex[node];\n          if (programIndex === undefined) throw new Error(`Sigma: node \"${node}\" can't be repaint`);\n          this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n        }\n      }\n\n      const edges = opts?.partialGraph?.edges || [];\n      for (let i = 0, l = edges.length; i < l; i++) {\n        const edge = edges[i];\n        // Recompute edge's data (ie. apply reducer)\n        this.updateEdge(edge);\n        // Add edge to the program\n        // otherwise it will be done in the process function\n        if (skipIndexation) {\n          const programIndex = this.edgeProgramIndex[edge];\n          if (programIndex === undefined) throw new Error(`Sigma: edge \"${edge}\" can't be repaint`);\n          this.addEdgeToProgram(edge, this.edgeIndices[edge], programIndex);\n        }\n      }\n    }\n\n    // Do we need to call the process function ?\n    if (fullRefresh || !skipIndexation) this.needToProcess = true;\n\n    if (schedule) this.scheduleRender();\n    else this.render();\n\n    return this;\n  }\n\n  /**\n   * Method used to schedule a render at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounces refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  scheduleRender(): this {\n    if (!this.renderFrame) {\n      this.renderFrame = requestAnimationFrame(() => {\n        this.render();\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n   * at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounces refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  scheduleRefresh(opts?: { partialGraph?: { nodes?: string[]; edges?: string[] }; layoutUnchange?: boolean }): this {\n    return this.refresh({ ...opts, schedule: true });\n  }\n\n  /**\n   * Method used to (un)zoom, while preserving the position of a viewport point.\n   * Used for instance to zoom \"on the mouse cursor\".\n   *\n   * @param viewportTarget\n   * @param newRatio\n   * @return {CameraState}\n   */\n  getViewportZoomedState(viewportTarget: Coordinates, newRatio: number): CameraState {\n    const { ratio, angle, x, y } = this.camera.getState();\n\n    const { minCameraRatio, maxCameraRatio } = this.settings;\n    if (typeof maxCameraRatio === \"number\") newRatio = Math.min(newRatio, maxCameraRatio);\n    if (typeof minCameraRatio === \"number\") newRatio = Math.max(newRatio, minCameraRatio);\n    const ratioDiff = newRatio / ratio;\n\n    const center = {\n      x: this.width / 2,\n      y: this.height / 2,\n    };\n\n    const graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n    const graphCenterPosition = this.viewportToFramedGraph(center);\n\n    return {\n      angle,\n      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n      ratio: newRatio,\n    };\n  }\n\n  /**\n   * Method returning the abstract rectangle containing the graph according\n   * to the camera's state.\n   *\n   * @return {object} - The view's rectangle.\n   */\n  viewRectangle(): {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    height: number;\n  } {\n    const p1 = this.viewportToFramedGraph({ x: 0, y: 0 }),\n      p2 = this.viewportToFramedGraph({ x: this.width, y: 0 }),\n      h = this.viewportToFramedGraph({ x: 0, y: this.height });\n\n    return {\n      x1: p1.x,\n      y1: p1.y,\n      x2: p2.x,\n      y2: p2.y,\n      height: p2.y - h.y,\n    };\n  }\n\n  /**\n   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  framedGraphToViewport(coordinates: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n    const matrix = override.matrix\n      ? override.matrix\n      : recomputeMatrix\n        ? matrixFromCamera(\n            override.cameraState || this.camera.getState(),\n            override.viewportDimensions || this.getDimensions(),\n            override.graphDimensions || this.getGraphDimensions(),\n            override.padding || this.getStagePadding(),\n          )\n        : this.matrix;\n\n    const viewportPos = multiplyVec2(matrix, coordinates);\n\n    return {\n      x: ((1 + viewportPos.x) * this.width) / 2,\n      y: ((1 - viewportPos.y) * this.height) / 2,\n    };\n  }\n\n  /**\n   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  viewportToFramedGraph(coordinates: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n    const invMatrix = override.matrix\n      ? override.matrix\n      : recomputeMatrix\n        ? matrixFromCamera(\n            override.cameraState || this.camera.getState(),\n            override.viewportDimensions || this.getDimensions(),\n            override.graphDimensions || this.getGraphDimensions(),\n            override.padding || this.getStagePadding(),\n            true,\n          )\n        : this.invMatrix;\n\n    const res = multiplyVec2(invMatrix, {\n      x: (coordinates.x / this.width) * 2 - 1,\n      y: 1 - (coordinates.y / this.height) * 2,\n    });\n\n    if (isNaN(res.x)) res.x = 0;\n    if (isNaN(res.y)) res.y = 0;\n\n    return res;\n  }\n\n  /**\n   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n   * stage) to the graph system (the reference system of data as they are in the given graph instance).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  viewportPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  viewportToGraph(viewportPoint: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n  }\n\n  /**\n   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  graphPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  graphToViewport(graphPoint: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n  }\n\n  /**\n   * Method returning the distance multiplier between the graph system and the\n   * viewport system.\n   */\n  getGraphToViewportRatio(): number {\n    const graphP1 = { x: 0, y: 0 };\n    const graphP2 = { x: 1, y: 1 };\n    const graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n\n    const viewportP1 = this.graphToViewport(graphP1);\n    const viewportP2 = this.graphToViewport(graphP2);\n    const viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n\n    return viewportD / graphD;\n  }\n\n  /**\n   * Method returning the graph's bounding box.\n   *\n   * @return {{ x: Extent, y: Extent }}\n   */\n  getBBox(): { x: Extent; y: Extent } {\n    return this.nodeExtent;\n  }\n\n  /**\n   * Method returning the graph's custom bounding box, if any.\n   *\n   * @return {{ x: Extent, y: Extent } | null}\n   */\n  getCustomBBox(): { x: Extent; y: Extent } | null {\n    return this.customBBox;\n  }\n\n  /**\n   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n   *\n   * @return {Sigma}\n   */\n  setCustomBBox(customBBox: { x: Extent; y: Extent } | null): this {\n    this.customBBox = customBBox;\n    this.scheduleRender();\n    return this;\n  }\n\n  /**\n   * Method used to shut the container & release event listeners.\n   *\n   * @return {undefined}\n   */\n  kill(): void {\n    // Emitting \"kill\" events so that plugins and such can cleanup\n    this.emit(\"kill\");\n\n    // Releasing events\n    this.removeAllListeners();\n\n    // Releasing camera handlers\n    this.unbindCameraHandlers();\n\n    // Releasing DOM events & captors\n    window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n    this.mouseCaptor.kill();\n    this.touchCaptor.kill();\n\n    // Releasing graph handlers\n    this.unbindGraphHandlers();\n\n    // Releasing cache & state\n    this.clearIndices();\n    this.clearState();\n\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n\n    this.highlightedNodes.clear();\n\n    // Clearing frames\n    if (this.renderFrame) {\n      cancelAnimationFrame(this.renderFrame);\n      this.renderFrame = null;\n    }\n\n    if (this.renderHighlightedNodesFrame) {\n      cancelAnimationFrame(this.renderHighlightedNodesFrame);\n      this.renderHighlightedNodesFrame = null;\n    }\n\n    // Destroying canvases\n    const container = this.container;\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    // Destroying remaining collections\n    this.canvasContexts = {};\n    this.webGLContexts = {};\n    this.elements = {};\n\n    // Kill programs:\n    for (const type in this.nodePrograms) {\n      this.nodePrograms[type].kill();\n    }\n    for (const type in this.nodeHoverPrograms) {\n      this.nodeHoverPrograms[type].kill();\n    }\n    for (const type in this.edgePrograms) {\n      this.edgePrograms[type].kill();\n    }\n    this.nodePrograms = {};\n    this.nodeHoverPrograms = {};\n    this.edgePrograms = {};\n\n    // Kill all canvas/WebGL contexts\n    for (const id in this.elements) {\n      this.killLayer(id);\n    }\n  }\n\n  /**\n   * Method used to scale the given size according to the camera's ratio, i.e.\n   * zooming state.\n   *\n   * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n   * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n   * @return {number}              - The scaled size.\n   */\n  scaleSize(size = 1, cameraRatio = this.camera.ratio): number {\n    return (\n      (size / this.settings.zoomToSizeRatioFunction(cameraRatio)) *\n      (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1)\n    );\n  }\n\n  /**\n   * Method that returns the collection of all used canvases.\n   * At the moment, the instantiated canvases are the following, and in the\n   * following order in the DOM:\n   * - `edges`\n   * - `nodes`\n   * - `edgeLabels`\n   * - `labels`\n   * - `hovers`\n   * - `hoverNodes`\n   * - `mouse`\n   *\n   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n   */\n  getCanvases(): PlainObject<HTMLCanvasElement> {\n    return { ...this.elements };\n  }\n}\n", "import { Attributes } from \"graphology-types\";\nimport { createContext, useContext } from \"react\";\nimport Sigma from \"sigma\";\n\nexport interface SigmaContextInterface<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n> {\n  sigma: Sigma<N, E, G>;\n  container: HTMLElement;\n}\n\n/**\n * @hidden\n */\nexport const SigmaContext = createContext<SigmaContextInterface | null>(null);\n\n/**\n * @hidden\n */\nexport const SigmaProvider = SigmaContext.Provider;\n\n/**\n * React hook that store the sigma and html container reference.\n *\n * ```typescript\n * const {sigma, container} = useSigmaContext();\n *```\n * See [[SigmaContextInterface]] for more information.\n *\n * @category Hook\n */\nexport function useSigmaContext<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(): SigmaContextInterface<N, E, G> {\n  const context = useContext(SigmaContext);\n  if (context == null) {\n    throw new Error(\"No context provided: useSigmaContext() can only be used in a descendant of <SigmaContainer>\");\n  }\n  // cast context to the one with good generics\n  return context as unknown as SigmaContextInterface<N, E, G>;\n}\n", "import Sigma from \"sigma\";\n\nimport { useSigmaContext } from \"./context\";\nimport { Attributes } from \"graphology-types\";\n\n/**\n * React hook to retrieve the sigma instance (from the context).\n *\n * ```typescript\n * const sigma = useSigma();\n *```\n * @category Hook\n */\nexport function useSigma<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(): Sigma<N, E, G> {\n  return useSigmaContext<N, E, G>().sigma;\n}\n", "import { useCallback } from \"react\";\nimport { Settings } from \"sigma/settings\";\n\nimport { useSigmaContext } from \"./context\";\nimport { Attributes } from \"graphology-types\";\n\n/**\n * React hook that helps you to update Sigma’s settings.\n *\n * ```typescript\n * const setSettings = useSetSettings();\n * ...\n * useEffect(() => {\n *  setSettings({\n *    hideEdgesOnMove: true,\n *    hideLabelsOnMove: true,\n *  });\n * }, []);\n *```\n * @category Hook\n */\nexport function useSetSettings<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(): (newSettings: Partial<Settings<N, E, G>>) => void {\n  const { sigma } = useSigmaContext<N, E, G>();\n\n  const setSettings = useCallback(\n    (newSettings: Partial<Settings<N, E, G>>) => {\n      if (!sigma) return;\n      (Object.keys(newSettings) as Array<keyof Settings<N, E, G>>).forEach((key) => {\n        // as never because of https://stackoverflow.com/questions/58656353/how-to-avoid-dynamic-keyof-object-assign-error-in-typescript\n        sigma.setSetting(key, newSettings[key] as never);\n      });\n    },\n    [sigma],\n  );\n\n  return setSettings;\n}\n", "import { useEffect, useState } from \"react\";\nimport { SigmaEvents, TouchCaptorEvents, MouseCaptorEvents, CameraEvents } from \"sigma/types\";\n\nimport { useSigma } from \"./useSigma\";\nimport { useSetSettings } from \"./useSetSettings\";\nimport { EventHandlers } from \"../types\";\nimport { Attributes } from \"graphology-types\";\n\ntype EventType = keyof EventHandlers;\n\nfunction keySet<T>(record: Record<keyof T, unknown>): Set<string> {\n  return new Set<string>(Object.keys(record));\n}\n\nconst sigmaEvents = keySet<SigmaEvents>({\n  clickNode: true,\n  rightClickNode: true,\n  downNode: true,\n  enterNode: true,\n  leaveNode: true,\n  doubleClickNode: true,\n  wheelNode: true,\n  clickEdge: true,\n  rightClickEdge: true,\n  downEdge: true,\n  enterEdge: true,\n  leaveEdge: true,\n  doubleClickEdge: true,\n  wheelEdge: true,\n  clickStage: true,\n  rightClickStage: true,\n  downStage: true,\n  doubleClickStage: true,\n  wheelStage: true,\n  beforeRender: true,\n  afterRender: true,\n  kill: true,\n  upStage: true,\n  upEdge: true,\n  upNode: true,\n  enterStage: true,\n  leaveStage: true,\n  resize: true,\n  afterClear: true,\n  afterProcess: true,\n  beforeClear: true,\n  beforeProcess: true,\n});\n\nconst mouseEvents = keySet<MouseCaptorEvents>({\n  click: true,\n  rightClick: true,\n  doubleClick: true,\n  mouseup: true,\n  mousedown: true,\n  mousemove: true,\n  mousemovebody: true,\n  mouseleave: true,\n  mouseenter: true,\n  wheel: true,\n});\n\nconst touchEvents = keySet<TouchCaptorEvents>({\n  touchup: true,\n  touchdown: true,\n  touchmove: true,\n});\nconst cameraEvents = keySet<CameraEvents>({ updated: true });\n\n/**\n * React hook that helps you to listen Sigma’s events.\n * It handles for you all the lifecyle of listener (ie. on / remove)\n *\n * ```typescript\n * const registerEvents = useRegisterEvents();\n * const [setHoveredNode,setHoveredNode] = useState<string|null>(null);\n * ...\n * useEffect(() => {\n *  registerEvents({\n *    enterNode: event => setHoveredNode(event.node),\n *    leaveNode: event => setHoveredNode(null),\n *  });\n * }, []);\n *```\n * @category Hook\n */\nexport function useRegisterEvents<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(): (eventHandlers: Partial<EventHandlers>) => void {\n  const sigma = useSigma<N, E, G>();\n  const setSettings = useSetSettings<N, E, G>();\n  const [eventHandlers, setEventHandlers] = useState<Partial<EventHandlers>>({});\n\n  useEffect(() => {\n    if (!sigma || !eventHandlers) {\n      return;\n    }\n\n    const userEvents = eventHandlers;\n\n    // list of event types to register\n    const eventTypes = Object.keys(userEvents) as Array<EventType>;\n\n    // register events\n    eventTypes.forEach((event: EventType) => {\n      const eventHandler = userEvents[event] as (...args: unknown[]) => void;\n      if (sigmaEvents.has(event)) {\n        sigma.on(event as keyof SigmaEvents, eventHandler);\n      }\n      if (mouseEvents.has(event)) {\n        sigma.getMouseCaptor().on(event as keyof MouseCaptorEvents, eventHandler);\n      }\n      if (touchEvents.has(event)) {\n        sigma.getTouchCaptor().on(event as keyof TouchCaptorEvents, eventHandler);\n      }\n      if (cameraEvents.has(event)) {\n        sigma.getCamera().on(event as keyof CameraEvents, eventHandler);\n      }\n    });\n\n    // cleanup\n    return () => {\n      // remove events listener\n      if (sigma) {\n        eventTypes.forEach((event: EventType) => {\n          const eventHandler = userEvents[event] as (...args: unknown[]) => void;\n          if (sigmaEvents.has(event)) {\n            sigma.off(event as keyof SigmaEvents, eventHandler);\n          }\n          if (mouseEvents.has(event)) {\n            sigma.getMouseCaptor().off(event as keyof MouseCaptorEvents, eventHandler);\n          }\n          if (touchEvents.has(event)) {\n            sigma.getTouchCaptor().off(event as keyof TouchCaptorEvents, eventHandler);\n          }\n          if (cameraEvents.has(event)) {\n            sigma.getCamera().off(event as keyof CameraEvents, eventHandler);\n          }\n        });\n      }\n    };\n  }, [sigma, eventHandlers, setSettings]);\n\n  return setEventHandlers;\n}\n", "import { useCallback } from \"react\";\nimport Graph from \"graphology\";\nimport { Attributes } from \"graphology-types\";\n\nimport { useSigma } from \"./useSigma\";\n\n/**\n * React hook that helps you to load a graph.\n * If a graph was previously loaded in Sigma/Graphology, per default it is cleared.\n * You can change this behaviour by settings the parameter `clear` to false.\n *\n * ```typescript\n * const loadGraph = useLoadGraph();\n * ...\n * useEffect(() => {\n *  loadGraph(erdosRenyi(UndirectedGraph, { order: 100, probability: 0.2 }), true);\n * }, []);\n *```\n * @category Hook\n */\nexport function useLoadGraph<\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(): (graph: Graph<N, E, G>, clear?: boolean) => void {\n  const sigma = useSigma<N, E, G>();\n\n  return useCallback(\n    (graph: Graph<N, E, G>, clear = true) => {\n      if (sigma && graph) {\n        if (clear && sigma.getGraph().order > 0) sigma.getGraph().clear();\n        sigma.getGraph().import(graph);\n        sigma.refresh();\n      }\n    },\n    [sigma],\n  );\n}\n", "export function getUniqueKey(): string {\n  return Math.random().toString(36).slice(2);\n}\n\nexport function isEqual(x: unknown, y: unknown): boolean {\n  // check the ref\n  if (x === y) return true;\n  // if both are object\n  if (typeof x == \"object\" && x != null && typeof y == \"object\" && y != null) {\n    // Check the number of properties\n    if (Object.keys(x).length != Object.keys(y).length) return false;\n\n    // for every props of x\n    for (const prop in x) {\n      // prop is missing in y, false\n      if (!Object.hasOwn(y, prop)) return false;\n      // prop in y is diff than the one in x, false\n      if (!isEqual((x as { [key: string]: unknown })[prop], (y as { [key: string]: unknown })[prop])) return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n", "import { useCallback, useEffect, useState } from \"react\";\nimport { AnimateOptions } from \"sigma/utils\";\nimport { CameraState } from \"sigma/types\";\n\nimport { isEqual } from \"../utils\";\nimport { useSigma } from \"./useSigma\";\n\ntype CameraOptions = Partial<AnimateOptions> & { factor?: number };\n\n/**\n * React hook that helps you to manage the camera.\n *\n * ```typescript\n * const {zoomIn, zoomOut, reset, goto, gotoNode } = useCamera();\n *```\n *\n * @category Hook\n */\nexport function useCamera(options?: CameraOptions): {\n  zoomIn: (options?: CameraOptions) => void;\n  zoomOut: (options?: CameraOptions) => void;\n  reset: (options?: Partial<AnimateOptions>) => void;\n  goto: (state: Partial<CameraState>, options?: Partial<AnimateOptions>) => void;\n  gotoNode: (nodeKey: string, options?: Partial<AnimateOptions>) => void;\n} {\n  const sigma = useSigma();\n  // Default camera options\n  const [defaultOptions, setDefaultOptions] = useState<CameraOptions>(options || {});\n  useEffect(() => {\n    if (!isEqual(defaultOptions, options || {})) setDefaultOptions(options || {});\n  }, [options]);\n\n  const zoomIn = useCallback(\n    (options?: CameraOptions) => {\n      sigma.getCamera().animatedZoom({ ...defaultOptions, ...options });\n    },\n    [sigma, defaultOptions],\n  );\n\n  const zoomOut = useCallback(\n    (options?: CameraOptions) => {\n      sigma.getCamera().animatedUnzoom({ ...defaultOptions, ...options });\n    },\n    [sigma, defaultOptions],\n  );\n\n  const reset = useCallback(\n    (options?: Partial<AnimateOptions>) => {\n      sigma.getCamera().animatedReset({ ...defaultOptions, ...options });\n    },\n    [sigma, defaultOptions],\n  );\n\n  const goto = useCallback(\n    (state: Partial<CameraState>, options?: Partial<AnimateOptions>) => {\n      sigma.getCamera().animate(state, { ...defaultOptions, ...options });\n    },\n    [sigma, defaultOptions],\n  );\n\n  const gotoNode = useCallback(\n    (nodeKey: string, options?: Partial<AnimateOptions>) => {\n      const nodeDisplayData = sigma.getNodeDisplayData(nodeKey);\n      if (nodeDisplayData) sigma.getCamera().animate(nodeDisplayData, { ...defaultOptions, ...options });\n      else console.log(`Node ${nodeKey} not found`);\n    },\n    [sigma, defaultOptions],\n  );\n\n  return { zoomIn, zoomOut, reset, goto, gotoNode };\n}\n", "import { useEffect, useState, useCallback } from \"react\";\nimport { useSigmaContext } from \"./context\";\n\nfunction toggleFullScreen(dom: HTMLElement) {\n  if (document.fullscreenElement !== dom) {\n    dom.requestFullscreen();\n  } else {\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    }\n  }\n}\n\n/**\n * React hook that helps you to set graph in fullmode.\n *\n * ```typescript\n * const {toggle, isFullScreen} = useFullscreen();\n *```\n * @category Hook\n */\nexport function useFullScreen(\n  container?: HTMLElement | null,\n): {\n  toggle: () => void;\n  isFullScreen: boolean;\n} {\n  const context = useSigmaContext();\n  const [isFullScreen, setFullScreen] = useState<boolean>(false);\n  const [element, setElement] = useState<HTMLElement>(container ? container : context.container);\n  const toggleState = () => setFullScreen((v) => !v);\n\n  useEffect(() => {\n    document.addEventListener(\"fullscreenchange\", toggleState);\n    return () => document.removeEventListener(\"fullscreenchange\", toggleState);\n  }, [toggleState]);\n\n  useEffect(() => {\n    setElement(container || context.container);\n  }, [container, context.container]);\n\n  const toggle = useCallback(() => {\n    toggleFullScreen(element);\n  }, [element]);\n\n  return {\n    toggle,\n    isFullScreen,\n  };\n}\n", "import React, {\n  CSSProperties,\n  Ref,\n  PropsWithChildren,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n  ReactElement,\n} from \"react\";\nimport Graph from \"graphology\";\nimport { Sigma } from \"sigma\";\nimport { Settings } from \"sigma/settings\";\n\nimport { SigmaContextInterface, SigmaProvider } from \"../hooks/context\";\nimport { isEqual } from \"../utils\";\nimport { GraphType } from \"../types\";\nimport { Attributes } from \"graphology-types\";\n\n/**\n * Properties for `SigmaContainer` component\n */\nexport interface SigmaContainerProps<N extends Attributes, E extends Attributes, G extends Attributes> {\n  /**\n   * Graphology instance or constructor\n   */\n  graph?: GraphType<N, E, G>;\n  /**\n   * Sigma settings\n   */\n  settings?: Partial<Settings<N, E, G>>;\n  /**\n   * HTML id\n   */\n  id?: string;\n  /**\n   * HTML class\n   */\n  className?: string;\n  /**\n   * HTML CSS style\n   */\n  style?: CSSProperties;\n}\n\n/**\n * The `SigmaContainer` component is responsible of create the Sigma instance, and provide it to its child components using a React Context that can be accessible via the hook {@link useSigma}.\n *\n * ```jsx\n * <SigmaContainer id=\"sigma-graph\">\n *   <MyCustomGraph />\n * </SigmaContainer>\n *```\n * See [[SigmaContainerProps]] for more information.\n *\n * @category Component\n */\nconst SigmaContainerComponent = <\n  N extends Attributes = Attributes,\n  E extends Attributes = Attributes,\n  G extends Attributes = Attributes,\n>(\n  { graph, id, className, style, settings = {}, children }: PropsWithChildren<SigmaContainerProps<N, E, G>>,\n  ref: Ref<Sigma<N, E, G> | null>,\n) => {\n  // Root HTML element\n  const rootRef = useRef<HTMLDivElement>(null);\n  // HTML element for the sigma instance\n  const containerRef = useRef<HTMLDivElement>(null);\n  // Common html props for the container\n  const props = { className: `react-sigma ${className ? className : \"\"}`, id, style };\n  // Sigma instance\n  const [sigma, setSigma] = useState<Sigma<N, E, G> | null>(null);\n  // Sigma settings\n  const [sigmaSettings, setSigmaSettings] = useState<Partial<Settings<N, E, G>>>(settings);\n  useEffect(() => {\n    if (!isEqual(sigmaSettings, settings)) setSigmaSettings(settings);\n  }, [settings]);\n\n  /**\n   * When graph or settings changed\n   * => create sigma\n   */\n  useEffect(() => {\n    let instance: Sigma<N, E, G> | null = null;\n\n    if (containerRef.current !== null) {\n      let sigGraph = new Graph<N, E, G>();\n      if (graph) {\n        sigGraph = typeof graph === \"function\" ? new graph() : graph;\n      }\n\n      instance = new Sigma(sigGraph, containerRef.current, sigmaSettings);\n      if (sigma) instance.getCamera().setState(sigma.getCamera().getState());\n    }\n    setSigma(instance);\n\n    return () => {\n      if (instance) {\n        instance.kill();\n      }\n      setSigma(null);\n    };\n  }, [containerRef, graph, sigmaSettings]);\n\n  /**\n   * Forward the sigma ref\n   */\n  useImperativeHandle(ref, () => sigma, [sigma]);\n\n  /**\n   * Memoify the context\n   */\n  const context = useMemo(\n    () => (sigma && rootRef.current ? { sigma, container: rootRef.current as HTMLElement } : null),\n    [sigma, rootRef.current],\n  ) as SigmaContextInterface | null;\n\n  // When context is created we provide it to children\n  const contents = context !== null ? <SigmaProvider value={context}>{children}</SigmaProvider> : null;\n\n  return (\n    <div {...props} ref={rootRef}>\n      <div className=\"sigma-container\" ref={containerRef} />\n      {contents}\n    </div>\n  );\n};\n\n/**\n * Redefine forwardRef for generics\n */\nfunction fixedForwardRef<T, P = unknown>(\n  render: (props: P, ref: React.Ref<T>) => ReactElement,\n): (props: P & React.RefAttributes<T>) => ReactElement {\n  return forwardRef(render) as (props: P & React.RefAttributes<T>) => ReactElement;\n}\n\nexport const SigmaContainer = fixedForwardRef(SigmaContainerComponent);\n", "import React, { CSSProperties, ReactNode } from \"react\";\n\n/**\n * Properties for `ControlsContainer` component.\n */\nexport interface ControlsContainerProps {\n  /**\n   * HTML id\n   */\n  id?: string;\n  /**\n   * HTML class\n   */\n  className?: string;\n  /**\n   * HTML CSS style\n   */\n  style?: CSSProperties;\n  /**\n   * Position of the container\n   */\n  position?: \"top-right\" | \"top-left\" | \"bottom-right\" | \"bottom-left\";\n  /*\n   * @hidden\n   */\n  children?: ReactNode;\n}\n\n/**\n * The `ControlsContainer` is just a wrapper for other control components.\n * It defines their position and also their style with its CSS class `react-sigma-controls`.\n *\n * ```jsx\n * <SigmaContainer>\n *   <ControlsContainer position={\"bottom-right\"}>\n *     <ForceAtlasControl autoRunFor={2000} />\n *   </ControlsContainer>\n * </SigmaContainer>\n * ```\n * See [[ControlsContainerProps]] for more information.\n *\n * @category Component\n */\nexport const ControlsContainer: React.FC<ControlsContainerProps> = ({\n  id,\n  className,\n  style,\n  children,\n  position = \"bottom-left\",\n}: ControlsContainerProps) => {\n  // Common html props for the container\n  const props = { className: `react-sigma-controls ${className ? className : \"\"} ${position}`, id, style };\n\n  return <div {...props}>{children}</div>;\n};\n", "export default \"data:image/svg+xml,%3Csvg%20aria-hidden%3D%22true%22%20focusable%3D%22false%22%20data-prefix%3D%22fas%22%20data-icon%3D%22plus%22%20class%3D%22svg-inline--fa%20fa-plus%20fa-w-14%22%20role%3D%22img%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%20%20%3Cpath%20fill%3D%22currentColor%22%20d%3D%22M416%20208H272V64c0-17.67-14.33-32-32-32h-32c-17.67%200-32%2014.33-32%2032v144H32c-17.67%200-32%2014.33-32%2032v32c0%2017.67%2014.33%2032%2032%2032h144v144c0%2017.67%2014.33%2032%2032%2032h32c17.67%200%2032-14.33%2032-32V304h144c17.67%200%2032-14.33%2032-32v-32c0-17.67-14.33-32-32-32z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\"", "export default \"data:image/svg+xml,%3Csvg%20aria-hidden%3D%22true%22%20focusable%3D%22false%22%20data-prefix%3D%22fas%22%20data-icon%3D%22minus%22%20class%3D%22svg-inline--fa%20fa-minus%20fa-w-14%22%20role%3D%22img%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20fill%3D%22currentColor%22%20d%3D%22M416%20208H32c-17.67%200-32%2014.33-32%2032v32c0%2017.67%2014.33%2032%2032%2032h384c17.67%200%2032-14.33%2032-32v-32c0-17.67-14.33-32-32-32z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\"", "export default \"data:image/svg+xml,%3Csvg%20aria-hidden%3D%22true%22%20focusable%3D%22false%22%20data-prefix%3D%22far%22%20data-icon%3D%22dot-circle%22%20class%3D%22svg-inline--fa%20fa-dot-circle%20fa-w-16%22%20role%3D%22img%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20512%20512%22%3E%3Cpath%20fill%3D%22currentColor%22%20d%3D%22M256%2056c110.532%200%20200%2089.451%20200%20200%200%20110.532-89.451%20200-200%20200-110.532%200-200-89.451-200-200%200-110.532%2089.451-200%20200-200m0-48C119.033%208%208%20119.033%208%20256s111.033%20248%20248%20248%20248-111.033%20248-248S392.967%208%20256%208zm0%20168c-44.183%200-80%2035.817-80%2080s35.817%2080%2080%2080%2080-35.817%2080-80-35.817-80-80-80z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\"", "import React, { CSSProperties } from \"react\";\n\nimport { ReactComponent as ZoomInIcon } from \"../../assets/icons/plus-solid.svg\";\nimport { ReactComponent as ZoomOutIcon } from \"../../assets/icons/minus-solid.svg\";\nimport { ReactComponent as ZoomResetIcon } from \"../../assets/icons/dot-circle-regular.svg\";\nimport { useCamera } from \"../../hooks/useCamera\";\n\ntype ZoomLabelKeys = \"zoomIn\" | \"zoomOut\" | \"reset\";\n\n/**\n * Properties for `ZoomControl` component\n */\nexport interface ZoomControlProps {\n  /**\n   * HTML class that will be added to all div button wrapper\n   */\n  className?: string;\n\n  /**\n   * HTML CSS style that will be added to all div button wrapper\n   */\n  style?: CSSProperties;\n\n  /**\n   * Number of ms for the zoom animation (default is 200ms)\n   */\n  animationDuration?: number;\n\n  /**\n   * It's possible to customize the button, by passing to JSX Element.\n   * First one is for the \"zoom in\", second for \"zoom out\" and third for \"view whole graph\".\n   * Example :\n   * ```jsx\n   * <ZoomControl>\n   *   <BsZoomIn />\n   *   <BsZoomOut />\n   *   <BiReset />\n   * </FullScreenControl>\n   * ```\n   */\n  children?: [JSX.Element, JSX.Element, JSX.Element];\n\n  /**\n   * Map of the labels we use in the component.\n   * This is usefull for I18N\n   */\n  labels?: { [Key in ZoomLabelKeys]?: string };\n}\n\n/**\n * The `ZoomControl` create three UI buttons that allows the user to\n * - zoom in\n * - zoom out\n * - reset zoom (ie. see the whole graph)\n *\n * ```jsx\n * <SigmaContainer>\n *   <ControlsContainer>\n *     <ZoomControl />\n *   </ControlsContainer>\n * </SigmaContainer>\n * ```\n * See [[ZoomControlProps]] for more information.\n *\n * @category Component\n */\nexport const ZoomControl: React.FC<ZoomControlProps> = ({\n  className,\n  style,\n  animationDuration = 200,\n  children,\n  labels = {},\n}: ZoomControlProps) => {\n  const { zoomIn, zoomOut, reset } = useCamera({ duration: animationDuration, factor: 1.5 });\n\n  // Common html props for the div wrapper\n  const htmlProps = {\n    style,\n    className: `react-sigma-control ${className || \"\"}`,\n  };\n\n  return (\n    <>\n      <div {...htmlProps}>\n        <button onClick={() => zoomIn()} title={labels[\"zoomIn\"] || \"Zoom In\"}>\n          {children ? children[0] : <ZoomInIcon style={{ width: \"1em\" }} />}\n        </button>\n      </div>\n      <div {...htmlProps}>\n        <button onClick={() => zoomOut()} title={labels[\"zoomOut\"] || \"Zoom Out\"}>\n          {children ? children[1] : <ZoomOutIcon style={{ width: \"1em\" }} />}\n        </button>\n      </div>\n      <div {...htmlProps}>\n        <button onClick={() => reset()} title={labels[\"reset\"] || \"See whole graph\"}>\n          {children ? children[2] : <ZoomResetIcon style={{ width: \"1em\" }} />}\n        </button>\n      </div>\n    </>\n  );\n};\n", "export default \"data:image/svg+xml,%3Csvg%20aria-hidden%3D%22true%22%20focusable%3D%22false%22%20data-prefix%3D%22fas%22%20data-icon%3D%22expand%22%20class%3D%22svg-inline--fa%20fa-expand%20fa-w-14%22%20role%3D%22img%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20fill%3D%22currentColor%22%20d%3D%22M0%20180V56c0-13.3%2010.7-24%2024-24h124c6.6%200%2012%205.4%2012%2012v40c0%206.6-5.4%2012-12%2012H64v84c0%206.6-5.4%2012-12%2012H12c-6.6%200-12-5.4-12-12zM288%2044v40c0%206.6%205.4%2012%2012%2012h84v84c0%206.6%205.4%2012%2012%2012h40c6.6%200%2012-5.4%2012-12V56c0-13.3-10.7-24-24-24H300c-6.6%200-12%205.4-12%2012zm148%20276h-40c-6.6%200-12%205.4-12%2012v84h-84c-6.6%200-12%205.4-12%2012v40c0%206.6%205.4%2012%2012%2012h124c13.3%200%2024-10.7%2024-24V332c0-6.6-5.4-12-12-12zM160%20468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6%200-12%205.4-12%2012v124c0%2013.3%2010.7%2024%2024%2024h124c6.6%200%2012-5.4%2012-12z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\"", "export default \"data:image/svg+xml,%3Csvg%20aria-hidden%3D%22true%22%20focusable%3D%22false%22%20data-prefix%3D%22fas%22%20data-icon%3D%22compress%22%20class%3D%22svg-inline--fa%20fa-compress%20fa-w-14%22%20role%3D%22img%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20448%20512%22%3E%3Cpath%20fill%3D%22currentColor%22%20d%3D%22M436%20192H312c-13.3%200-24-10.7-24-24V44c0-6.6%205.4-12%2012-12h40c6.6%200%2012%205.4%2012%2012v84h84c6.6%200%2012%205.4%2012%2012v40c0%206.6-5.4%2012-12%2012zm-276-24V44c0-6.6-5.4-12-12-12h-40c-6.6%200-12%205.4-12%2012v84H12c-6.6%200-12%205.4-12%2012v40c0%206.6%205.4%2012%2012%2012h124c13.3%200%2024-10.7%2024-24zm0%20300V344c0-13.3-10.7-24-24-24H12c-6.6%200-12%205.4-12%2012v40c0%206.6%205.4%2012%2012%2012h84v84c0%206.6%205.4%2012%2012%2012h40c6.6%200%2012-5.4%2012-12zm192%200v-84h84c6.6%200%2012-5.4%2012-12v-40c0-6.6-5.4-12-12-12H312c-13.3%200-24%2010.7-24%2024v124c0%206.6%205.4%2012%2012%2012h40c6.6%200%2012-5.4%2012-12z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\"", "import React, { CSSProperties, RefObject } from \"react\";\n\nimport { ReactComponent as EnterIcon } from \"../../assets/icons/expand-solid.svg\";\nimport { ReactComponent as ExitIcon } from \"../../assets/icons/compress-solid.svg\";\nimport { useFullScreen } from \"../../hooks/useFullScreen\";\n\ntype FullScreenLabelKeys = \"enter\" | \"exit\";\n\n/**\n * Properties for `FullScreenControl` component.\n */\nexport interface FullScreenControlProps {\n  /**\n   * HTML id\n   */\n  id?: string;\n\n  /**\n   * HTML class\n   */\n  className?: string;\n\n  /**\n   * HTML CSS style\n   */\n  style?: CSSProperties;\n\n  /**\n   * If defined, this container will be taken for the fullscreen instead of the sigma one.\n   */\n  container?: RefObject<HTMLElement>;\n\n  /**\n   * It's possible to customize the button, by passing to JSX Element.\n   * First one is for the \"enter fullscreen\", and the second to \"exit fullscreen\".\n   * Example :\n   * ```jsx\n   * <FullScreenControl>\n   *   <BiFullscreen />\n   *   <BiExitFullscreen />\n   * </FullScreenControl>\n   * ```\n   */\n  children?: [JSX.Element, JSX.Element];\n\n  /**\n   * Map of the labels we use in the component.\n   * This is usefull for I18N\n   */\n  labels?: { [Key in FullScreenLabelKeys]?: string };\n}\n\n/**\n * The `FullScreenControl` create a UI button that allows the user to display the graph in fullscreen\n *\n * ```jsx\n * <SigmaContainer>\n *   <ControlsContainer>\n *     <FullScreenControl />\n *   </ControlsContainer>\n * </SigmaContainer>\n * ```\n * See [[FullScreenControlProps]] for more information.\n *\n * @category Component\n */\nexport const FullScreenControl: React.FC<FullScreenControlProps> = ({\n  id,\n  className,\n  style,\n  container,\n  children,\n  labels = {},\n}: FullScreenControlProps) => {\n  // Get Sigma\n  const { isFullScreen, toggle } = useFullScreen(container?.current);\n\n  // Common html props for the div\n  const htmlProps = {\n    className: `react-sigma-control ${className || \"\"}`,\n    id,\n    style,\n  };\n\n  if (!document.fullscreenEnabled) return null;\n\n  return (\n    <div {...htmlProps}>\n      <button\n        onClick={toggle}\n        title={isFullScreen ? labels[\"exit\"] || \"Exit fullscreen\" : labels[\"enter\"] || \"Enter fullscreen\"}\n      >\n        {children && !isFullScreen && children[0]}\n        {children && isFullScreen && children[1]}\n        {!children && !isFullScreen && <EnterIcon style={{ width: \"1em\" }} />}\n        {!children && isFullScreen && <ExitIcon style={{ width: \"1em\" }} />}\n      </button>\n    </div>\n  );\n};\n", "import React, { ChangeEvent, useEffect, useState, CSSProperties } from \"react\";\nimport { Attributes } from \"graphology-types\";\n\nimport { getUniqueKey } from \"../../utils\";\nimport { useSigma } from \"../../hooks/useSigma\";\nimport { useCamera } from \"../../hooks/useCamera\";\nimport { useRegisterEvents } from \"../../hooks/useRegisterEvents\";\n\ntype SearchLabelKeys = \"text\" | \"placeholder\";\n\n/**\n * Properties for `SearchControl` component\n */\nexport interface SearchControlProps {\n  /**\n   * HTML id\n   */\n  id?: string;\n\n  /**\n   * HTML class\n   */\n  className?: string;\n\n  /**\n   * HTML CSS style\n   */\n  style?: CSSProperties;\n\n  /**\n   * Map of the labels we use in the component.\n   * This is usefull for I18N\n   */\n  labels?: { [Key in SearchLabelKeys]?: string };\n}\n\n/**\n * The `SearchControl` create an input text where user can search a node in the graph by its label.\n * There is an autocomplete based on includes & lower case.\n * When a node is found, the graph will focus on the highlighted node\n *\n * ```jsx\n * <SigmaContainer>\n *   <ControlsContainer>\n *     <SearchControl />\n *   </ControlsContainer>\n * </SigmaContainer>\n * ```\n * See [[SearchControlProps]] for more information.\n *\n * @category Component\n */\nexport const SearchControl: React.FC<SearchControlProps> = ({\n  id,\n  className,\n  style,\n  labels = {},\n}: SearchControlProps) => {\n  // Get sigma\n  const sigma = useSigma();\n  // Get event hook\n  const registerEvents = useRegisterEvents();\n  // Get camera hook\n  const { gotoNode } = useCamera();\n  // Search value\n  const [search, setSearch] = useState<string>(\"\");\n  // Datalist values\n  const [values, setValues] = useState<Array<{ id: string; label: string }>>([]);\n  // Selected\n  const [selected, setSelected] = useState<string | null>(null);\n  // random id for the input\n  const [inputId, setInputId] = useState<string>(\"\");\n\n  /**\n   * When component mount, we set a random input id.\n   */\n  useEffect(() => {\n    setInputId(`search-${getUniqueKey()}`);\n  }, []);\n\n  /**\n   * When the search input changes, recompute the autocomplete values.\n   */\n  useEffect(() => {\n    const newValues: Array<{ id: string; label: string }> = [];\n    if (!selected && search.length > 1) {\n      sigma.getGraph().forEachNode((key: string, attributes: Attributes): void => {\n        if (attributes.label && attributes.label.toLowerCase().includes(search.toLowerCase()))\n          newValues.push({ id: key, label: attributes.label });\n      });\n    }\n    setValues(newValues);\n  }, [search]);\n\n  /**\n   * When use clik on the stage\n   *  => reset the selection\n   */\n  useEffect(() => {\n    registerEvents({\n      clickStage: () => {\n        setSelected(null);\n        setSearch(\"\");\n      },\n    });\n  }, [registerEvents]);\n\n  /**\n   * When the selected item changes, highlighted the node and center the camera on it.\n   */\n  useEffect(() => {\n    if (!selected) {\n      return;\n    }\n\n    sigma.getGraph().setNodeAttribute(selected, \"highlighted\", true);\n    gotoNode(selected);\n\n    return () => {\n      sigma.getGraph().setNodeAttribute(selected, \"highlighted\", false);\n    };\n  }, [selected]);\n\n  /**\n   * On change event handler for the search input, to set the state.\n   */\n  const onInputChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const searchString = e.target.value;\n    const valueItem = values.find((value) => value.label === searchString);\n    if (valueItem) {\n      setSearch(valueItem.label);\n      setValues([]);\n      setSelected(valueItem.id);\n    } else {\n      setSelected(null);\n      setSearch(searchString);\n    }\n  };\n\n  // Common html props for the div\n  const htmlProps = {\n    className: `react-sigma-search ${className ? className : \"\"}`,\n    id,\n    style,\n  };\n\n  return (\n    <div {...htmlProps}>\n      <label htmlFor={inputId} style={{ display: \"none\" }}>\n        {labels[\"text\"] || \"Search a node\"}\n      </label>\n      <input\n        id={inputId}\n        type=\"text\"\n        placeholder={labels[\"placeholder\"] || \"Search...\"}\n        list={`${inputId}-datalist`}\n        value={search}\n        onChange={onInputChange}\n      />\n      <datalist id={`${inputId}-datalist`}>\n        {values.map((value: { id: string; label: string }) => (\n          <option key={value.id} value={value.label}>\n            {value.label}\n          </option>\n        ))}\n      </datalist>\n    </div>\n  );\n};\n"],
  "mappings": "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",
  "names": ["k", "r", "b", "a", "r", "b", "a", "x", "y", "m", "x", "y", "r", "s", "c", "a", "b", "z", "x", "y", "i", "i", "l", "o", "_", "x", "y", "isGraph", "k", "a", "b", "r", "t", "i", "l", "i", "j", "i", "l", "i", "l", "Program", "SHADER_SOURCE", "UNSIGNED_BYTE", "FLOAT", "SHADER_SOURCE", "frag_glsl_default", "SHADER_SOURCE", "vert_glsl_default", "UNSIGNED_BYTE", "FLOAT", "UNIFORMS", "vert_glsl_default", "frag_glsl_default", "SHADER_SOURCE", "frag_glsl_default", "SHADER_SOURCE", "vert_glsl_default", "UNSIGNED_BYTE", "FLOAT", "UNIFORMS", "vert_glsl_default", "frag_glsl_default", "UNSIGNED_BYTE", "FLOAT", "SHADER_SOURCE", "vert_glsl_default", "UNSIGNED_BYTE", "FLOAT", "UNIFORMS", "vert_glsl_default", "frag_glsl_default", "UNSIGNED_BYTE", "FLOAT", "e", "i", "l", "e", "x", "y", "e", "x", "y", "k", "i", "_", "x", "y", "e", "f", "i", "l", "h", "SigmaContext", "createContext", "SigmaProvider", "Provider", "useSigmaContext", "context", "useContext", "Error", "useSigma", "sigma", "useSetSettings", "useCallback", "newSettings", "Object", "keys", "forEach", "key", "setSetting", "keySet", "record", "Set", "sigmaEvents", "clickNode", "rightClickNode", "downNode", "enterNode", "leaveNode", "doubleClickNode", "wheelNode", "clickEdge", "rightClickEdge", "downEdge", "enterEdge", "leaveEdge", "doubleClickEdge", "wheelEdge", "clickStage", "rightClickStage", "downStage", "doubleClickStage", "wheelStage", "beforeRender", "afterRender", "kill", "upStage", "upEdge", "upNode", "enterStage", "leaveStage", "resize", "afterClear", "afterProcess", "beforeClear", "beforeProcess", "mouseEvents", "click", "rightClick", "doubleClick", "mouseup", "mousedown", "mousemove", "mousemovebody", "mouseleave", "mouseenter", "wheel", "touchEvents", "touchup", "touchdown", "touchmove", "cameraEvents", "updated", "useRegisterEvents", "setSettings", "eventHandlers", "setEventHandlers", "useState", "useEffect", "userEvents", "eventTypes", "event", "eventHandler", "has", "on", "getMouseCaptor", "getTouchCaptor", "getCamera", "off", "useLoadGraph", "graph", "clear", "getGraph", "order", "import", "refresh", "getUniqueKey", "Math", "random", "toString", "slice", "isEqual", "x", "y", "length", "prop", "hasOwn", "useCamera", "options", "defaultOptions", "setDefaultOptions", "zoomIn", "animatedZoom", "zoomOut", "animatedUnzoom", "reset", "animatedReset", "goto", "state", "animate", "assign", "gotoNode", "nodeKey", "nodeDisplayData", "getNodeDisplayData", "console", "log", "useFullScreen", "container", "isFullScreen", "setFullScreen", "element", "setElement", "toggleState", "v", "document", "addEventListener", "removeEventListener", "toggle", "dom", "fullscreenElement", "requestFullscreen", "exitFullscreen", "SigmaContainer", "forwardRef", "id", "className", "style", "settings", "children", "ref", "rootRef", "useRef", "containerRef", "props", "setSigma", "sigmaSettings", "setSigmaSettings", "instance", "current", "sigGraph", "Graph", "Sigma", "setState", "getState", "useImperativeHandle", "useMemo", "contents", "React", "createElement", "value", "ControlsContainer", "position", "_path", "_extends", "bind", "target", "i", "arguments", "source", "prototype", "hasOwnProperty", "call", "apply", "this", "SvgPlusSolid", "xmlns", "viewBox", "width", "height", "fill", "d", "SvgMinusSolid", "SvgDotCircleRegular", "ZoomControl", "animationDuration", "labels", "duration", "factor", "htmlProps", "Fragment", "onClick", "title", "ZoomInIcon", "ZoomOutIcon", "ZoomResetIcon", "SvgExpandSolid", "SvgCompressSolid", "FullScreenControl", "fullscreenEnabled", "EnterIcon", "ExitIcon", "SearchControl", "registerEvents", "search", "setSearch", "values", "setValues", "selected", "setSelected", "inputId", "setInputId", "newValues", "forEachNode", "attributes", "label", "toLowerCase", "includes", "push", "setNodeAttribute", "htmlFor", "display", "type", "placeholder", "list", "onChange", "e", "searchString", "valueItem", "find", "map"]
}
