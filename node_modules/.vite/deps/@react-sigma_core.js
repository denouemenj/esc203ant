import {
  require_is_graph
} from "./chunk-J4LDCC3O.js";
import {
  require_react
} from "./chunk-CN7HREE2.js";
import {
  Graph
} from "./chunk-EOMWJ3SU.js";
import {
  require_events
} from "./chunk-7PFSFVDG.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// ../../node_modules/@react-sigma/core/lib/react-sigma_core.esm.min.js
var e = __toESM(require_react());
var import_react = __toESM(require_react());

// ../sigma/src/types.ts
var import_events = __toESM(require_events());
var TypedEventEmitter = class extends import_events.EventEmitter {
  constructor() {
    super();
    this.rawEmitter = this;
  }
};

// ../sigma/src/utils/easings.ts
var linear = (k2) => k2;
var quadraticIn = (k2) => k2 * k2;
var quadraticOut = (k2) => k2 * (2 - k2);
var quadraticInOut = (k2) => {
  if ((k2 *= 2) < 1) return 0.5 * k2 * k2;
  return -0.5 * (--k2 * (k2 - 2) - 1);
};
var cubicIn = (k2) => k2 * k2 * k2;
var cubicOut = (k2) => --k2 * k2 * k2 + 1;
var cubicInOut = (k2) => {
  if ((k2 *= 2) < 1) return 0.5 * k2 * k2 * k2;
  return 0.5 * ((k2 -= 2) * k2 * k2 + 2);
};
var easings = {
  linear,
  quadraticIn,
  quadraticOut,
  quadraticInOut,
  cubicIn,
  cubicOut,
  cubicInOut
};

// ../sigma/src/utils/animate.ts
var ANIMATE_DEFAULTS = {
  easing: "quadraticInOut",
  duration: 150
};

// ../sigma/src/utils/colors.ts
var HTML_COLORS = {
  black: "#000000",
  silver: "#C0C0C0",
  gray: "#808080",
  grey: "#808080",
  white: "#FFFFFF",
  maroon: "#800000",
  red: "#FF0000",
  purple: "#800080",
  fuchsia: "#FF00FF",
  green: "#008000",
  lime: "#00FF00",
  olive: "#808000",
  yellow: "#FFFF00",
  navy: "#000080",
  blue: "#0000FF",
  teal: "#008080",
  aqua: "#00FFFF",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  darkgreen: "#006400",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  springgreen: "#00FF7F",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  rebeccapurple: "#663399",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  dimgrey: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  slategrey: "#708090",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370DB",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  palevioletred: "#DB7093",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0"
};
var INT8 = new Int8Array(4);
var INT32 = new Int32Array(INT8.buffer, 0, 1);
var FLOAT32 = new Float32Array(INT8.buffer, 0, 1);
var RGBA_TEST_REGEX = /^\s*rgba?\s*\(/;
var RGBA_EXTRACT_REGEX = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)(?:\s*,\s*(.*)?)?\)\s*$/;
function parseColor(val) {
  let r2 = 0;
  let g = 0;
  let b2 = 0;
  let a2 = 1;
  if (val[0] === "#") {
    if (val.length === 4) {
      r2 = parseInt(val.charAt(1) + val.charAt(1), 16);
      g = parseInt(val.charAt(2) + val.charAt(2), 16);
      b2 = parseInt(val.charAt(3) + val.charAt(3), 16);
    } else {
      r2 = parseInt(val.charAt(1) + val.charAt(2), 16);
      g = parseInt(val.charAt(3) + val.charAt(4), 16);
      b2 = parseInt(val.charAt(5) + val.charAt(6), 16);
    }
    if (val.length === 9) {
      a2 = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;
    }
  } else if (RGBA_TEST_REGEX.test(val)) {
    const match = val.match(RGBA_EXTRACT_REGEX);
    if (match) {
      r2 = +match[1];
      g = +match[2];
      b2 = +match[3];
      if (match[4]) a2 = +match[4];
    }
  }
  return { r: r2, g, b: b2, a: a2 };
}
var FLOAT_COLOR_CACHE = {};
for (const htmlColor in HTML_COLORS) {
  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);
  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];
}
function rgbaToFloat(r2, g, b2, a2, masking) {
  INT32[0] = a2 << 24 | b2 << 16 | g << 8 | r2;
  if (masking) INT32[0] = INT32[0] & 4278190079;
  return FLOAT32[0];
}
function floatColor(val) {
  val = val.toLowerCase();
  if (typeof FLOAT_COLOR_CACHE[val] !== "undefined") return FLOAT_COLOR_CACHE[val];
  const parsed = parseColor(val);
  const { r: r2, g, b: b2 } = parsed;
  let { a: a2 } = parsed;
  a2 = a2 * 255 | 0;
  const color = rgbaToFloat(r2, g, b2, a2, true);
  FLOAT_COLOR_CACHE[val] = color;
  return color;
}
var FLOAT_INDEX_CACHE = {};
function indexToColor(index) {
  if (typeof FLOAT_INDEX_CACHE[index] !== "undefined") return FLOAT_INDEX_CACHE[index];
  const r2 = (index & 16711680) >>> 16;
  const g = (index & 65280) >>> 8;
  const b2 = index & 255;
  const a2 = 255;
  const color = rgbaToFloat(r2, g, b2, a2, true);
  FLOAT_INDEX_CACHE[index] = color;
  return color;
}
function colorToIndex(r2, g, b2, _a) {
  return b2 + (g << 8) + (r2 << 16);
}
function getPixelColor(gl, frameBuffer, x2, y2, pixelRatio, downSizingRatio) {
  const bufferX = Math.floor(x2 / downSizingRatio * pixelRatio);
  const bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - y2 / downSizingRatio * pixelRatio);
  const pixel = new Uint8Array(4);
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
  const [r2, g, b2, a2] = pixel;
  return [r2, g, b2, a2];
}

// ../sigma/src/utils/matrices.ts
function identity() {
  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);
}
function scale(m2, x2, y2) {
  m2[0] = x2;
  m2[4] = typeof y2 === "number" ? y2 : x2;
  return m2;
}
function rotate(m2, r2) {
  const s2 = Math.sin(r2), c2 = Math.cos(r2);
  m2[0] = c2;
  m2[1] = s2;
  m2[3] = -s2;
  m2[4] = c2;
  return m2;
}
function translate(m2, x2, y2) {
  m2[6] = x2;
  m2[7] = y2;
  return m2;
}
function multiply(a2, b2) {
  const a00 = a2[0], a01 = a2[1], a02 = a2[2];
  const a10 = a2[3], a11 = a2[4], a12 = a2[5];
  const a20 = a2[6], a21 = a2[7], a22 = a2[8];
  const b00 = b2[0], b01 = b2[1], b02 = b2[2];
  const b10 = b2[3], b11 = b2[4], b12 = b2[5];
  const b20 = b2[6], b21 = b2[7], b22 = b2[8];
  a2[0] = b00 * a00 + b01 * a10 + b02 * a20;
  a2[1] = b00 * a01 + b01 * a11 + b02 * a21;
  a2[2] = b00 * a02 + b01 * a12 + b02 * a22;
  a2[3] = b10 * a00 + b11 * a10 + b12 * a20;
  a2[4] = b10 * a01 + b11 * a11 + b12 * a21;
  a2[5] = b10 * a02 + b11 * a12 + b12 * a22;
  a2[6] = b20 * a00 + b21 * a10 + b22 * a20;
  a2[7] = b20 * a01 + b21 * a11 + b22 * a21;
  a2[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return a2;
}
function multiplyVec2(a2, b2, z2 = 1) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a10 = a2[3];
  const a11 = a2[4];
  const a20 = a2[6];
  const a21 = a2[7];
  const b0 = b2.x;
  const b1 = b2.y;
  return { x: b0 * a00 + b1 * a10 + a20 * z2, y: b0 * a01 + b1 * a11 + a21 * z2 };
}

// ../sigma/src/utils/coordinates.ts
function getCorrectionRatio(viewportDimensions, graphDimensions) {
  const viewportRatio = viewportDimensions.height / viewportDimensions.width;
  const graphRatio = graphDimensions.height / graphDimensions.width;
  if (viewportRatio < 1 && graphRatio > 1 || viewportRatio > 1 && graphRatio < 1) {
    return 1;
  }
  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));
}
function matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {
  const { angle, ratio, x: x2, y: y2 } = state;
  const { width, height } = viewportDimensions;
  const matrix = identity();
  const smallestDimension = Math.min(width, height) - 2 * padding;
  const correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);
  if (!inverse) {
    multiply(
      matrix,
      scale(
        identity(),
        2 * (smallestDimension / width) * correctionRatio,
        2 * (smallestDimension / height) * correctionRatio
      )
    );
    multiply(matrix, rotate(identity(), -angle));
    multiply(matrix, scale(identity(), 1 / ratio));
    multiply(matrix, translate(identity(), -x2, -y2));
  } else {
    multiply(matrix, translate(identity(), x2, y2));
    multiply(matrix, scale(identity(), ratio));
    multiply(matrix, rotate(identity(), angle));
    multiply(
      matrix,
      scale(
        identity(),
        width / smallestDimension / 2 / correctionRatio,
        height / smallestDimension / 2 / correctionRatio
      )
    );
  }
  return matrix;
}
function getMatrixImpact(matrix, cameraState, viewportDimensions) {
  const { x: x2, y: y2 } = multiplyVec2(matrix, { x: Math.cos(cameraState.angle), y: Math.sin(cameraState.angle) }, 0);
  return 1 / Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)) / viewportDimensions.width;
}

// ../sigma/src/utils/data.ts
function extend(array, values) {
  const l2 = values.size;
  if (l2 === 0) return;
  const l1 = array.length;
  array.length += l2;
  let i2 = 0;
  values.forEach((value) => {
    array[l1 + i2] = value;
    i2++;
  });
}
function assign(target, ...objects) {
  target = target || {};
  for (let i2 = 0, l2 = objects.length; i2 < l2; i2++) {
    const o2 = objects[i2];
    if (!o2) continue;
    Object.assign(target, o2);
  }
  return target;
}

// ../sigma/src/utils/graph.ts
var import_is_graph = __toESM(require_is_graph());
function graphExtent(graph) {
  if (!graph.order) return { x: [0, 1], y: [0, 1] };
  let xMin = Infinity;
  let xMax = -Infinity;
  let yMin = Infinity;
  let yMax = -Infinity;
  graph.forEachNode((_2, attr) => {
    const { x: x2, y: y2 } = attr;
    if (x2 < xMin) xMin = x2;
    if (x2 > xMax) xMax = x2;
    if (y2 < yMin) yMin = y2;
    if (y2 > yMax) yMax = y2;
  });
  return { x: [xMin, xMax], y: [yMin, yMax] };
}
function validateGraph(graph) {
  if (!(0, import_is_graph.default)(graph)) throw new Error("Sigma: invalid graph instance.");
  graph.forEachNode((key, attributes) => {
    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {
      throw new Error(
        `Sigma: Coordinates of node ${key} are invalid. A node must have a numeric 'x' and 'y' attribute.`
      );
    }
  });
}

// ../sigma/src/utils/misc.ts
function createElement(tag, style, attributes) {
  const element = document.createElement(tag);
  if (style) {
    for (const k2 in style) {
      element.style[k2] = style[k2];
    }
  }
  if (attributes) {
    for (const k2 in attributes) {
      element.setAttribute(k2, attributes[k2]);
    }
  }
  return element;
}
function getPixelRatio() {
  if (typeof window.devicePixelRatio !== "undefined") return window.devicePixelRatio;
  return 1;
}
function zIndexOrdering(_extent, getter, elements) {
  return elements.sort(function(a2, b2) {
    const zA = getter(a2) || 0, zB = getter(b2) || 0;
    if (zA < zB) return -1;
    if (zA > zB) return 1;
    return 0;
  });
}

// ../sigma/src/utils/normalization.ts
function createNormalizationFunction(extent) {
  const {
    x: [minX, maxX],
    y: [minY, maxY]
  } = extent;
  let ratio = Math.max(maxX - minX, maxY - minY), dX = (maxX + minX) / 2, dY = (maxY + minY) / 2;
  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;
  if (isNaN(dX)) dX = 0;
  if (isNaN(dY)) dY = 0;
  const fn = (data) => {
    return {
      x: 0.5 + (data.x - dX) / ratio,
      y: 0.5 + (data.y - dY) / ratio
    };
  };
  fn.applyTo = (data) => {
    data.x = 0.5 + (data.x - dX) / ratio;
    data.y = 0.5 + (data.y - dY) / ratio;
  };
  fn.inverse = (data) => {
    return {
      x: dX + ratio * (data.x - 0.5),
      y: dY + ratio * (data.y - 0.5)
    };
  };
  fn.ratio = ratio;
  return fn;
}

// ../sigma/src/core/camera.ts
var DEFAULT_ZOOMING_RATIO = 1.5;
var Camera = class _Camera extends TypedEventEmitter {
  constructor() {
    super();
    this.x = 0.5;
    this.y = 0.5;
    this.angle = 0;
    this.ratio = 1;
    this.minRatio = null;
    this.maxRatio = null;
    this.enabledRotation = true;
    this.nextFrame = null;
    this.previousState = null;
    this.enabled = true;
    this.previousState = this.getState();
  }
  /**
   * Static method used to create a Camera object with a given state.
   */
  static from(state) {
    const camera = new _Camera();
    return camera.setState(state);
  }
  /**
   * Method used to enable the camera.
   */
  enable() {
    this.enabled = true;
    return this;
  }
  /**
   * Method used to disable the camera.
   */
  disable() {
    this.enabled = false;
    return this;
  }
  /**
   * Method used to retrieve the camera's current state.
   */
  getState() {
    return {
      x: this.x,
      y: this.y,
      angle: this.angle,
      ratio: this.ratio
    };
  }
  /**
   * Method used to check whether the camera has the given state.
   */
  hasState(state) {
    return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;
  }
  /**
   * Method used to retrieve the camera's previous state.
   */
  getPreviousState() {
    const state = this.previousState;
    if (!state) return null;
    return {
      x: state.x,
      y: state.y,
      angle: state.angle,
      ratio: state.ratio
    };
  }
  /**
   * Method used to check minRatio and maxRatio values.
   */
  getBoundedRatio(ratio) {
    let r2 = ratio;
    if (typeof this.minRatio === "number") r2 = Math.max(r2, this.minRatio);
    if (typeof this.maxRatio === "number") r2 = Math.min(r2, this.maxRatio);
    return r2;
  }
  /**
   * Method used to check various things to return a legit state candidate.
   */
  validateState(state) {
    const validatedState = {};
    if (typeof state.x === "number") validatedState.x = state.x;
    if (typeof state.y === "number") validatedState.y = state.y;
    if (this.enabledRotation && typeof state.angle === "number") validatedState.angle = state.angle;
    if (typeof state.ratio === "number") validatedState.ratio = this.getBoundedRatio(state.ratio);
    return validatedState;
  }
  /**
   * Method used to check whether the camera is currently being animated.
   */
  isAnimated() {
    return !!this.nextFrame;
  }
  /**
   * Method used to set the camera's state.
   */
  setState(state) {
    if (!this.enabled) return this;
    this.previousState = this.getState();
    const validState = this.validateState(state);
    if (typeof validState.x === "number") this.x = validState.x;
    if (typeof validState.y === "number") this.y = validState.y;
    if (this.enabledRotation && typeof validState.angle === "number") this.angle = validState.angle;
    if (typeof validState.ratio === "number") this.ratio = validState.ratio;
    if (!this.hasState(this.previousState)) this.emit("updated", this.getState());
    return this;
  }
  /**
   * Method used to update the camera's state using a function.
   */
  updateState(updater) {
    this.setState(updater(this.getState()));
    return this;
  }
  animate(state, opts = {}, callback) {
    if (!callback) return new Promise((resolve) => this.animate(state, opts, resolve));
    if (!this.enabled) return;
    const options = {
      ...ANIMATE_DEFAULTS,
      ...opts
    };
    const validState = this.validateState(state);
    const easing = typeof options.easing === "function" ? options.easing : easings[options.easing];
    const start = Date.now(), initialState = this.getState();
    const fn = () => {
      const t2 = (Date.now() - start) / options.duration;
      if (t2 >= 1) {
        this.nextFrame = null;
        this.setState(validState);
        if (this.animationCallback) {
          this.animationCallback.call(null);
          this.animationCallback = void 0;
        }
        return;
      }
      const coefficient = easing(t2);
      const newState = {};
      if (typeof validState.x === "number") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;
      if (typeof validState.y === "number") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;
      if (this.enabledRotation && typeof validState.angle === "number")
        newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;
      if (typeof validState.ratio === "number")
        newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;
      this.setState(newState);
      this.nextFrame = requestAnimationFrame(fn);
    };
    if (this.nextFrame) {
      cancelAnimationFrame(this.nextFrame);
      if (this.animationCallback) this.animationCallback.call(null);
      this.nextFrame = requestAnimationFrame(fn);
    } else {
      fn();
    }
    this.animationCallback = callback;
  }
  /**
   * Method used to zoom the camera.
   */
  animatedZoom(factorOrOptions) {
    if (!factorOrOptions) return this.animate({ ratio: this.ratio / DEFAULT_ZOOMING_RATIO });
    if (typeof factorOrOptions === "number") return this.animate({ ratio: this.ratio / factorOrOptions });
    return this.animate(
      {
        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
      },
      factorOrOptions
    );
  }
  /**
   * Method used to unzoom the camera.
   */
  animatedUnzoom(factorOrOptions) {
    if (!factorOrOptions) return this.animate({ ratio: this.ratio * DEFAULT_ZOOMING_RATIO });
    if (typeof factorOrOptions === "number") return this.animate({ ratio: this.ratio * factorOrOptions });
    return this.animate(
      {
        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
      },
      factorOrOptions
    );
  }
  /**
   * Method used to reset the camera.
   */
  animatedReset(options) {
    return this.animate(
      {
        x: 0.5,
        y: 0.5,
        ratio: 1,
        angle: 0
      },
      options
    );
  }
  /**
   * Returns a new Camera instance, with the same state as the current camera.
   */
  copy() {
    return _Camera.from(this.getState());
  }
};

// ../sigma/src/rendering/utils.ts
function getAttributeItemsCount(attr) {
  return attr.normalized ? 1 : attr.size;
}
function getAttributesItemsCount(attrs) {
  let res = 0;
  attrs.forEach((attr) => res += getAttributeItemsCount(attr));
  return res;
}
function loadShader(type, gl, source) {
  const glType = type === "VERTEX" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;
  const shader = gl.createShader(glType);
  if (shader === null) {
    throw new Error(`loadShader: error while creating the shader`);
  }
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!successfullyCompiled) {
    const infoLog = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw new Error(`loadShader: error while compiling the shader:
${infoLog}
${source}`);
  }
  return shader;
}
function loadVertexShader(gl, source) {
  return loadShader("VERTEX", gl, source);
}
function loadFragmentShader(gl, source) {
  return loadShader("FRAGMENT", gl, source);
}
function loadProgram(gl, shaders) {
  const program = gl.createProgram();
  if (program === null) {
    throw new Error("loadProgram: error while creating the program.");
  }
  let i2, l2;
  for (i2 = 0, l2 = shaders.length; i2 < l2; i2++) gl.attachShader(program, shaders[i2]);
  gl.linkProgram(program);
  const successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!successfullyLinked) {
    gl.deleteProgram(program);
    throw new Error("loadProgram: error while linking the program.");
  }
  return program;
}
function killProgram({ gl, buffer, program, vertexShader, fragmentShader }) {
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  gl.deleteProgram(program);
  gl.deleteBuffer(buffer);
}

// ../sigma/src/rendering/program.ts
var PICKING_PREFIX = `#define PICKING_MODE
`;
var SIZE_FACTOR_PER_ATTRIBUTE_TYPE = {
  [WebGL2RenderingContext.BOOL]: 1,
  [WebGL2RenderingContext.BYTE]: 1,
  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,
  [WebGL2RenderingContext.SHORT]: 2,
  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,
  [WebGL2RenderingContext.INT]: 4,
  [WebGL2RenderingContext.UNSIGNED_INT]: 4,
  [WebGL2RenderingContext.FLOAT]: 4
};
var Program = class {
  constructor(gl, pickingBuffer, renderer) {
    this.array = new Float32Array();
    this.constantArray = new Float32Array();
    this.capacity = 0;
    this.verticesCount = 0;
    const def = this.getDefinition();
    this.VERTICES = def.VERTICES;
    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;
    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;
    this.UNIFORMS = def.UNIFORMS;
    this.ATTRIBUTES = def.ATTRIBUTES;
    this.METHOD = def.METHOD;
    this.CONSTANT_ATTRIBUTES = "CONSTANT_ATTRIBUTES" in def ? def.CONSTANT_ATTRIBUTES : [];
    this.CONSTANT_DATA = "CONSTANT_DATA" in def ? def.CONSTANT_DATA : [];
    this.isInstanced = "CONSTANT_ATTRIBUTES" in def;
    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);
    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;
    this.renderer = renderer;
    this.normalProgram = this.getProgramInfo("normal", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);
    this.pickProgram = pickingBuffer ? this.getProgramInfo(
      "pick",
      gl,
      PICKING_PREFIX + def.VERTEX_SHADER_SOURCE,
      PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE,
      pickingBuffer
    ) : null;
    if (this.isInstanced) {
      const constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);
      if (this.CONSTANT_DATA.length !== this.VERTICES)
        throw new Error(
          `Program: error while getting constant data (expected ${this.VERTICES} items, received ${this.CONSTANT_DATA.length} instead)`
        );
      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);
      for (let i2 = 0; i2 < this.CONSTANT_DATA.length; i2++) {
        const vector = this.CONSTANT_DATA[i2];
        if (vector.length !== constantAttributesItemsCount)
          throw new Error(
            `Program: error while getting constant data (one vector has ${vector.length} items instead of ${constantAttributesItemsCount})`
          );
        for (let j2 = 0; j2 < vector.length; j2++) this.constantArray[i2 * constantAttributesItemsCount + j2] = vector[j2];
      }
      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;
    }
  }
  kill() {
    killProgram(this.normalProgram);
    if (this.pickProgram) {
      killProgram(this.pickProgram);
      this.pickProgram = null;
    }
  }
  getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {
    const def = this.getDefinition();
    const buffer = gl.createBuffer();
    if (buffer === null) throw new Error("Program: error while creating the WebGL buffer.");
    const vertexShader = loadVertexShader(gl, vertexShaderSource);
    const fragmentShader = loadFragmentShader(gl, fragmentShaderSource);
    const program = loadProgram(gl, [vertexShader, fragmentShader]);
    const uniformLocations = {};
    def.UNIFORMS.forEach((uniformName) => {
      const location = gl.getUniformLocation(program, uniformName);
      if (location) uniformLocations[uniformName] = location;
    });
    const attributeLocations = {};
    def.ATTRIBUTES.forEach((attr) => {
      attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);
    });
    let constantBuffer;
    if ("CONSTANT_ATTRIBUTES" in def) {
      def.CONSTANT_ATTRIBUTES.forEach((attr) => {
        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);
      });
      constantBuffer = gl.createBuffer();
      if (constantBuffer === null) throw new Error("Program: error while creating the WebGL constant buffer.");
    }
    return {
      name,
      program,
      gl,
      frameBuffer,
      buffer,
      constantBuffer: constantBuffer || {},
      uniformLocations,
      attributeLocations,
      isPicking: name === "pick",
      vertexShader,
      fragmentShader
    };
  }
  bindProgram(program) {
    let offset = 0;
    const { gl, buffer } = program;
    if (!this.isInstanced) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      offset = 0;
      this.ATTRIBUTES.forEach((attr) => offset += this.bindAttribute(attr, program, offset));
      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);
      offset = 0;
      this.CONSTANT_ATTRIBUTES.forEach((attr) => offset += this.bindAttribute(attr, program, offset, false));
      gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);
      offset = 0;
      this.ATTRIBUTES.forEach((attr) => offset += this.bindAttribute(attr, program, offset, true));
      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  unbindProgram(program) {
    if (!this.isInstanced) {
      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program));
    } else {
      this.CONSTANT_ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, false));
      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, true));
    }
  }
  bindAttribute(attr, program, offset, setDivisor) {
    const sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];
    if (typeof sizeFactor !== "number") throw new Error(`Program.bind: yet unsupported attribute type "${attr.type}"`);
    const location = program.attributeLocations[attr.name];
    const gl = program.gl;
    if (location !== -1) {
      gl.enableVertexAttribArray(location);
      const stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;
      gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);
      if (this.isInstanced && setDivisor) {
        if (gl instanceof WebGL2RenderingContext) {
          gl.vertexAttribDivisor(location, 1);
        } else {
          const ext = gl.getExtension("ANGLE_instanced_arrays");
          if (ext) ext.vertexAttribDivisorANGLE(location, 1);
        }
      }
    }
    return attr.size * sizeFactor;
  }
  unbindAttribute(attr, program, unsetDivisor) {
    const location = program.attributeLocations[attr.name];
    const gl = program.gl;
    if (location !== -1) {
      gl.disableVertexAttribArray(location);
      if (this.isInstanced && unsetDivisor) {
        if (gl instanceof WebGL2RenderingContext) {
          gl.vertexAttribDivisor(location, 0);
        } else {
          const ext = gl.getExtension("ANGLE_instanced_arrays");
          if (ext) ext.vertexAttribDivisorANGLE(location, 0);
        }
      }
    }
  }
  reallocate(capacity) {
    if (capacity === this.capacity) return;
    this.capacity = capacity;
    this.verticesCount = this.VERTICES * capacity;
    this.array = new Float32Array(
      !this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT
    );
  }
  hasNothingToRender() {
    return this.verticesCount === 0;
  }
  renderProgram(params, programInfo) {
    const { gl, program } = programInfo;
    gl.enable(gl.BLEND);
    gl.useProgram(program);
    this.setUniforms(params, programInfo);
    this.drawWebGL(this.METHOD, programInfo);
  }
  render(params) {
    if (this.hasNothingToRender()) return;
    if (this.pickProgram) {
      this.pickProgram.gl.viewport(
        0,
        0,
        params.width * params.pixelRatio / params.downSizingRatio,
        params.height * params.pixelRatio / params.downSizingRatio
      );
      this.bindProgram(this.pickProgram);
      this.renderProgram({ ...params, pixelRatio: params.pixelRatio / params.downSizingRatio }, this.pickProgram);
      this.unbindProgram(this.pickProgram);
    }
    this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);
    this.bindProgram(this.normalProgram);
    this.renderProgram(params, this.normalProgram);
    this.unbindProgram(this.normalProgram);
  }
  drawWebGL(method, { gl, frameBuffer }) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    if (!this.isInstanced) {
      gl.drawArrays(method, 0, this.verticesCount);
    } else {
      if (gl instanceof WebGL2RenderingContext) {
        gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);
      } else {
        const ext = gl.getExtension("ANGLE_instanced_arrays");
        if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);
      }
    }
  }
};

// ../sigma/src/rendering/node.ts
var NodeProgram = class extends Program {
  kill() {
    super.kill();
  }
  process(nodeIndex, offset, data) {
    let i2 = offset * this.STRIDE;
    if (data.hidden) {
      for (let l2 = i2 + this.STRIDE; i2 < l2; i2++) {
        this.array[i2] = 0;
      }
      return;
    }
    return this.processVisibleItem(indexToColor(nodeIndex), i2, data);
  }
};

// ../sigma/src/rendering/edge.ts
var EdgeProgram = class extends Program {
  constructor() {
    super(...arguments);
    this.drawLabel = void 0;
  }
  kill() {
    super.kill();
  }
  process(edgeIndex, offset, sourceData, targetData, data) {
    let i2 = offset * this.STRIDE;
    if (data.hidden || sourceData.hidden || targetData.hidden) {
      for (let l2 = i2 + this.STRIDE; i2 < l2; i2++) {
        this.array[i2] = 0;
      }
      return;
    }
    return this.processVisibleItem(indexToColor(edgeIndex), i2, sourceData, targetData, data);
  }
};
function createEdgeCompoundProgram(programClasses, drawLabel) {
  return class EdgeCompoundProgram {
    constructor(gl, pickingBuffer, renderer) {
      this.drawLabel = drawLabel;
      this.programs = programClasses.map((Program2) => {
        return new Program2(gl, pickingBuffer, renderer);
      });
    }
    reallocate(capacity) {
      this.programs.forEach((program) => program.reallocate(capacity));
    }
    process(edgeIndex, offset, sourceData, targetData, data) {
      this.programs.forEach((program) => program.process(edgeIndex, offset, sourceData, targetData, data));
    }
    render(params) {
      this.programs.forEach((program) => program.render(params));
    }
    kill() {
      this.programs.forEach((program) => program.kill());
    }
  };
}

// ../sigma/src/rendering/edge-labels.ts
function drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {
  const size = settings.edgeLabelSize, font = settings.edgeLabelFont, weight = settings.edgeLabelWeight, color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || "#000" : settings.edgeLabelColor.color;
  let label = edgeData.label;
  if (!label) return;
  context.fillStyle = color;
  context.font = `${weight} ${size}px ${font}`;
  const sSize = sourceData.size;
  const tSize = targetData.size;
  let sx = sourceData.x;
  let sy = sourceData.y;
  let tx = targetData.x;
  let ty = targetData.y;
  let cx = (sx + tx) / 2;
  let cy = (sy + ty) / 2;
  let dx = tx - sx;
  let dy = ty - sy;
  let d = Math.sqrt(dx * dx + dy * dy);
  if (d < sSize + tSize) return;
  sx += dx * sSize / d;
  sy += dy * sSize / d;
  tx -= dx * tSize / d;
  ty -= dy * tSize / d;
  cx = (sx + tx) / 2;
  cy = (sy + ty) / 2;
  dx = tx - sx;
  dy = ty - sy;
  d = Math.sqrt(dx * dx + dy * dy);
  let textLength = context.measureText(label).width;
  if (textLength > d) {
    const ellipsis = "â€¦";
    label = label + ellipsis;
    textLength = context.measureText(label).width;
    while (textLength > d && label.length > 1) {
      label = label.slice(0, -2) + ellipsis;
      textLength = context.measureText(label).width;
    }
    if (label.length < 4) return;
  }
  let angle;
  if (dx > 0) {
    if (dy > 0) angle = Math.acos(dx / d);
    else angle = Math.asin(dy / d);
  } else {
    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;
    else angle = Math.asin(dx / d) + Math.PI / 2;
  }
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);
  context.restore();
}

// ../sigma/src/rendering/node-labels.ts
function drawDiscNodeLabel(context, data, settings) {
  if (!data.label) return;
  const size = settings.labelSize, font = settings.labelFont, weight = settings.labelWeight, color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || "#000" : settings.labelColor.color;
  context.fillStyle = color;
  context.font = `${weight} ${size}px ${font}`;
  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);
}

// ../sigma/src/rendering/node-hover.ts
function drawDiscNodeHover(context, data, settings) {
  const size = settings.labelSize, font = settings.labelFont, weight = settings.labelWeight;
  context.font = `${weight} ${size}px ${font}`;
  context.fillStyle = "#FFF";
  context.shadowOffsetX = 0;
  context.shadowOffsetY = 0;
  context.shadowBlur = 8;
  context.shadowColor = "#000";
  const PADDING = 2;
  if (typeof data.label === "string") {
    const textWidth = context.measureText(data.label).width, boxWidth = Math.round(textWidth + 5), boxHeight = Math.round(size + 2 * PADDING), radius = Math.max(data.size, size / 2) + PADDING;
    const angleRadian = Math.asin(boxHeight / 2 / radius);
    const xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));
    context.beginPath();
    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);
    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);
    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);
    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);
    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);
    context.closePath();
    context.fill();
  } else {
    context.beginPath();
    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);
    context.closePath();
    context.fill();
  }
  context.shadowOffsetX = 0;
  context.shadowOffsetY = 0;
  context.shadowBlur = 0;
  drawDiscNodeLabel(context, data, settings);
}

// ../sigma/src/rendering/programs/node-circle/frag.glsl.ts
var SHADER_SOURCE = (
  /*glsl*/
  `
precision highp float;

varying vec4 v_color;
varying vec2 v_diffVector;
varying float v_radius;

uniform float u_correctionRatio;

const vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);

void main(void) {
  float border = u_correctionRatio * 2.0;
  float dist = length(v_diffVector) - v_radius + border;

  // No antialiasing for picking mode:
  #ifdef PICKING_MODE
  if (dist > border)
    gl_FragColor = transparent;
  else
    gl_FragColor = v_color;

  #else
  float t = 0.0;
  if (dist > border)
    t = 1.0;
  else if (dist > 0.0)
    t = dist / border;

  gl_FragColor = mix(v_color, transparent, t);
  #endif
}
`
);
var frag_glsl_default = SHADER_SOURCE;

// ../sigma/src/rendering/programs/node-circle/vert.glsl.ts
var SHADER_SOURCE2 = (
  /*glsl*/
  `
attribute vec4 a_id;
attribute vec4 a_color;
attribute vec2 a_position;
attribute float a_size;
attribute float a_angle;

uniform mat3 u_matrix;
uniform float u_sizeRatio;
uniform float u_correctionRatio;

varying vec4 v_color;
varying vec2 v_diffVector;
varying float v_radius;
varying float v_border;

const float bias = 255.0 / 254.0;

void main() {
  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;
  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));
  vec2 position = a_position + diffVector;
  gl_Position = vec4(
    (u_matrix * vec3(position, 1)).xy,
    0,
    1
  );

  v_diffVector = diffVector;
  v_radius = size / 2.0;

  #ifdef PICKING_MODE
  // For picking mode, we use the ID as the color:
  v_color = a_id;
  #else
  // For normal mode, we use the color:
  v_color = a_color;
  #endif

  v_color.a *= bias;
}
`
);
var vert_glsl_default = SHADER_SOURCE2;

// ../sigma/src/rendering/programs/node-circle/index.ts
var { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;
var UNIFORMS = ["u_sizeRatio", "u_correctionRatio", "u_matrix"];
var _NodeCircleProgram = class _NodeCircleProgram extends NodeProgram {
  getDefinition() {
    return {
      VERTICES: 3,
      VERTEX_SHADER_SOURCE: vert_glsl_default,
      FRAGMENT_SHADER_SOURCE: frag_glsl_default,
      METHOD: WebGLRenderingContext.TRIANGLES,
      UNIFORMS,
      ATTRIBUTES: [
        { name: "a_position", size: 2, type: FLOAT },
        { name: "a_size", size: 1, type: FLOAT },
        { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
        { name: "a_id", size: 4, type: UNSIGNED_BYTE, normalized: true }
      ],
      CONSTANT_ATTRIBUTES: [{ name: "a_angle", size: 1, type: FLOAT }],
      CONSTANT_DATA: [[_NodeCircleProgram.ANGLE_1], [_NodeCircleProgram.ANGLE_2], [_NodeCircleProgram.ANGLE_3]]
    };
  }
  processVisibleItem(nodeIndex, startIndex, data) {
    const array = this.array;
    const color = floatColor(data.color);
    array[startIndex++] = data.x;
    array[startIndex++] = data.y;
    array[startIndex++] = data.size;
    array[startIndex++] = color;
    array[startIndex++] = nodeIndex;
  }
  setUniforms(params, { gl, uniformLocations }) {
    const { u_sizeRatio, u_correctionRatio, u_matrix } = uniformLocations;
    gl.uniform1f(u_correctionRatio, params.correctionRatio);
    gl.uniform1f(u_sizeRatio, params.sizeRatio);
    gl.uniformMatrix3fv(u_matrix, false, params.matrix);
  }
};
_NodeCircleProgram.ANGLE_1 = 0;
_NodeCircleProgram.ANGLE_2 = 2 * Math.PI / 3;
_NodeCircleProgram.ANGLE_3 = 4 * Math.PI / 3;
var NodeCircleProgram = _NodeCircleProgram;

// ../sigma/src/rendering/programs/node-point/index.ts
var { UNSIGNED_BYTE: UNSIGNED_BYTE2, FLOAT: FLOAT2 } = WebGLRenderingContext;

// ../sigma/src/rendering/programs/edge-arrow-head/frag.glsl.ts
var SHADER_SOURCE3 = (
  /*glsl*/
  `
precision mediump float;

varying vec4 v_color;

void main(void) {
  gl_FragColor = v_color;
}
`
);
var frag_glsl_default3 = SHADER_SOURCE3;

// ../sigma/src/rendering/programs/edge-arrow-head/vert.glsl.ts
var SHADER_SOURCE4 = (
  /*glsl*/
  `
attribute vec2 a_position;
attribute vec2 a_normal;
attribute float a_radius;
attribute vec3 a_barycentric;

#ifdef PICKING_MODE
attribute vec4 a_id;
#else
attribute vec4 a_color;
#endif

uniform mat3 u_matrix;
uniform float u_sizeRatio;
uniform float u_correctionRatio;
uniform float u_minEdgeThickness;
uniform float u_lengthToThicknessRatio;
uniform float u_widenessToThicknessRatio;

varying vec4 v_color;

const float bias = 255.0 / 254.0;

void main() {
  float minThickness = u_minEdgeThickness;

  float normalLength = length(a_normal);
  vec2 unitNormal = a_normal / normalLength;

  // These first computations are taken from edge.vert.glsl and
  // edge.clamped.vert.glsl. Please read it to get better comments on what's
  // happening:
  float pixelsThickness = max(normalLength / u_sizeRatio, minThickness);
  float webGLThickness = pixelsThickness * u_correctionRatio;
  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;
  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;
  float webGLArrowHeadThickness = webGLThickness * u_widenessToThicknessRatio;

  float da = a_barycentric.x;
  float db = a_barycentric.y;
  float dc = a_barycentric.z;

  vec2 delta = vec2(
      da * (webGLNodeRadius * unitNormal.y)
    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadThickness * unitNormal.x)
    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadThickness * unitNormal.x),

      da * (-webGLNodeRadius * unitNormal.x)
    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadThickness * unitNormal.y)
    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadThickness * unitNormal.y)
  );

  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;

  gl_Position = vec4(position, 0, 1);

  #ifdef PICKING_MODE
  // For picking mode, we use the ID as the color:
  v_color = a_id;
  #else
  // For normal mode, we use the color:
  v_color = a_color;
  #endif

  v_color.a *= bias;
}
`
);
var vert_glsl_default3 = SHADER_SOURCE4;

// ../sigma/src/rendering/programs/edge-arrow-head/index.ts
var { UNSIGNED_BYTE: UNSIGNED_BYTE3, FLOAT: FLOAT3 } = WebGLRenderingContext;
var UNIFORMS2 = [
  "u_matrix",
  "u_sizeRatio",
  "u_correctionRatio",
  "u_minEdgeThickness",
  "u_lengthToThicknessRatio",
  "u_widenessToThicknessRatio"
];
var DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS = {
  lengthToThicknessRatio: 2.5,
  widenessToThicknessRatio: 2
};
function createEdgeArrowHeadProgram(inputOptions) {
  const options = {
    ...DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS,
    ...inputOptions || {}
  };
  return class EdgeArrowHeadProgram extends EdgeProgram {
    getDefinition() {
      return {
        VERTICES: 3,
        VERTEX_SHADER_SOURCE: vert_glsl_default3,
        FRAGMENT_SHADER_SOURCE: frag_glsl_default3,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS: UNIFORMS2,
        ATTRIBUTES: [
          { name: "a_position", size: 2, type: FLOAT3 },
          { name: "a_normal", size: 2, type: FLOAT3 },
          { name: "a_radius", size: 1, type: FLOAT3 },
          { name: "a_color", size: 4, type: UNSIGNED_BYTE3, normalized: true },
          { name: "a_id", size: 4, type: UNSIGNED_BYTE3, normalized: true }
        ],
        CONSTANT_ATTRIBUTES: [{ name: "a_barycentric", size: 3, type: FLOAT3 }],
        CONSTANT_DATA: [
          [1, 0, 0],
          [0, 1, 0],
          [0, 0, 1]
        ]
      };
    }
    processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      const thickness = data.size || 1;
      const radius = targetData.size || 1;
      const x1 = sourceData.x;
      const y1 = sourceData.y;
      const x2 = targetData.x;
      const y2 = targetData.y;
      const color = floatColor(data.color);
      const dx = x2 - x1;
      const dy = y2 - y1;
      let len = dx * dx + dy * dy;
      let n1 = 0;
      let n2 = 0;
      if (len) {
        len = 1 / Math.sqrt(len);
        n1 = -dy * len * thickness;
        n2 = dx * len * thickness;
      }
      const array = this.array;
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = -n1;
      array[startIndex++] = -n2;
      array[startIndex++] = radius;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
    }
    setUniforms(params, { gl, uniformLocations }) {
      const {
        u_matrix,
        u_sizeRatio,
        u_correctionRatio,
        u_minEdgeThickness,
        u_lengthToThicknessRatio,
        u_widenessToThicknessRatio
      } = uniformLocations;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
      gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);
      gl.uniform1f(u_widenessToThicknessRatio, options.widenessToThicknessRatio);
    }
  };
}
var EdgeArrowHeadProgram = createEdgeArrowHeadProgram();

// ../sigma/src/rendering/programs/edge-rectangle/frag.glsl.ts
var SHADER_SOURCE5 = (
  /*glsl*/
  `
precision mediump float;

varying vec4 v_color;
varying vec2 v_normal;
varying float v_thickness;
varying float v_feather;

const vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);

void main(void) {
  // We only handle antialiasing for normal mode:
  #ifdef PICKING_MODE
  gl_FragColor = v_color;
  #else
  float dist = length(v_normal) * v_thickness;

  float t = smoothstep(
    v_thickness - v_feather,
    v_thickness,
    dist
  );

  gl_FragColor = mix(v_color, transparent, t);
  #endif
}
`
);
var frag_glsl_default4 = SHADER_SOURCE5;

// ../sigma/src/rendering/programs/edge-clamped/vert.glsl.ts
var SHADER_SOURCE6 = (
  /*glsl*/
  `
attribute vec4 a_id;
attribute vec4 a_color;
attribute vec2 a_normal;
attribute float a_normalCoef;
attribute vec2 a_positionStart;
attribute vec2 a_positionEnd;
attribute float a_positionCoef;
attribute float a_radius;
attribute float a_radiusCoef;

uniform mat3 u_matrix;
uniform float u_zoomRatio;
uniform float u_sizeRatio;
uniform float u_pixelRatio;
uniform float u_correctionRatio;
uniform float u_minEdgeThickness;
uniform float u_lengthToThicknessRatio;
uniform float u_feather;

varying vec4 v_color;
varying vec2 v_normal;
varying float v_thickness;
varying float v_feather;

const float bias = 255.0 / 254.0;

void main() {
  float minThickness = u_minEdgeThickness;

  float radius = a_radius * a_radiusCoef;
  vec2 normal = a_normal * a_normalCoef;
  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;

  float normalLength = length(normal);
  vec2 unitNormal = normal / normalLength;

  // These first computations are taken from edge.vert.glsl. Please read it to
  // get better comments on what's happening:
  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);
  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;

  // Here, we move the point to leave space for the arrow head:
  float direction = sign(radius);
  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;
  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;

  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);

  // Here is the proper position of the vertex
  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);

  v_thickness = webGLThickness / u_zoomRatio;

  v_normal = unitNormal;

  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;

  #ifdef PICKING_MODE
  // For picking mode, we use the ID as the color:
  v_color = a_id;
  #else
  // For normal mode, we use the color:
  v_color = a_color;
  #endif

  v_color.a *= bias;
}
`
);
var vert_glsl_default4 = SHADER_SOURCE6;

// ../sigma/src/rendering/programs/edge-clamped/index.ts
var { UNSIGNED_BYTE: UNSIGNED_BYTE4, FLOAT: FLOAT4 } = WebGLRenderingContext;
var UNIFORMS3 = [
  "u_matrix",
  "u_zoomRatio",
  "u_sizeRatio",
  "u_correctionRatio",
  "u_pixelRatio",
  "u_feather",
  "u_minEdgeThickness",
  "u_lengthToThicknessRatio"
];
var DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS = {
  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio
};
function createEdgeClampedProgram(inputOptions) {
  const options = {
    ...DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS,
    ...inputOptions || {}
  };
  return class EdgeClampedProgram extends EdgeProgram {
    getDefinition() {
      return {
        VERTICES: 6,
        VERTEX_SHADER_SOURCE: vert_glsl_default4,
        FRAGMENT_SHADER_SOURCE: frag_glsl_default4,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS: UNIFORMS3,
        ATTRIBUTES: [
          { name: "a_positionStart", size: 2, type: FLOAT4 },
          { name: "a_positionEnd", size: 2, type: FLOAT4 },
          { name: "a_normal", size: 2, type: FLOAT4 },
          { name: "a_color", size: 4, type: UNSIGNED_BYTE4, normalized: true },
          { name: "a_id", size: 4, type: UNSIGNED_BYTE4, normalized: true },
          { name: "a_radius", size: 1, type: FLOAT4 }
        ],
        CONSTANT_ATTRIBUTES: [
          // If 0, then position will be a_positionStart
          // If 1, then position will be a_positionEnd
          { name: "a_positionCoef", size: 1, type: FLOAT4 },
          { name: "a_normalCoef", size: 1, type: FLOAT4 },
          { name: "a_radiusCoef", size: 1, type: FLOAT4 }
        ],
        CONSTANT_DATA: [
          [0, 1, 0],
          [0, -1, 0],
          [1, 1, 1],
          [1, 1, 1],
          [0, -1, 0],
          [1, -1, -1]
        ]
      };
    }
    processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      const thickness = data.size || 1;
      const x1 = sourceData.x;
      const y1 = sourceData.y;
      const x2 = targetData.x;
      const y2 = targetData.y;
      const color = floatColor(data.color);
      const dx = x2 - x1;
      const dy = y2 - y1;
      const radius = targetData.size || 1;
      let len = dx * dx + dy * dy;
      let n1 = 0;
      let n2 = 0;
      if (len) {
        len = 1 / Math.sqrt(len);
        n1 = -dy * len * thickness;
        n2 = dx * len * thickness;
      }
      const array = this.array;
      array[startIndex++] = x1;
      array[startIndex++] = y1;
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = n1;
      array[startIndex++] = n2;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
      array[startIndex++] = radius;
    }
    setUniforms(params, { gl, uniformLocations }) {
      const {
        u_matrix,
        u_zoomRatio,
        u_feather,
        u_pixelRatio,
        u_correctionRatio,
        u_sizeRatio,
        u_minEdgeThickness,
        u_lengthToThicknessRatio
      } = uniformLocations;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
      gl.uniform1f(u_zoomRatio, params.zoomRatio);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_pixelRatio, params.pixelRatio);
      gl.uniform1f(u_feather, params.antiAliasingFeather);
      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
      gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);
    }
  };
}
var EdgeClampedProgram = createEdgeClampedProgram();

// ../sigma/src/rendering/programs/edge-arrow/index.ts
function createEdgeArrowProgram(inputOptions) {
  return createEdgeCompoundProgram([createEdgeClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions)]);
}
var EdgeArrowProgram = createEdgeArrowProgram();
var edge_arrow_default = EdgeArrowProgram;

// ../sigma/src/rendering/programs/edge-line/index.ts
var { UNSIGNED_BYTE: UNSIGNED_BYTE5, FLOAT: FLOAT5 } = WebGLRenderingContext;

// ../sigma/src/rendering/programs/edge-rectangle/vert.glsl.ts
var SHADER_SOURCE7 = (
  /*glsl*/
  `
attribute vec4 a_id;
attribute vec4 a_color;
attribute vec2 a_normal;
attribute float a_normalCoef;
attribute vec2 a_positionStart;
attribute vec2 a_positionEnd;
attribute float a_positionCoef;

uniform mat3 u_matrix;
uniform float u_sizeRatio;
uniform float u_zoomRatio;
uniform float u_pixelRatio;
uniform float u_correctionRatio;
uniform float u_minEdgeThickness;
uniform float u_feather;

varying vec4 v_color;
varying vec2 v_normal;
varying float v_thickness;
varying float v_feather;

const float bias = 255.0 / 254.0;

void main() {
  float minThickness = u_minEdgeThickness;

  vec2 normal = a_normal * a_normalCoef;
  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;

  float normalLength = length(normal);
  vec2 unitNormal = normal / normalLength;

  // We require edges to be at least "minThickness" pixels thick *on screen*
  // (so we need to compensate the size ratio):
  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);

  // Then, we need to retrieve the normalized thickness of the edge in the WebGL
  // referential (in a ([0, 1], [0, 1]) space), using our "magic" correction
  // ratio:
  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;

  // Here is the proper position of the vertex
  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);

  // For the fragment shader though, we need a thickness that takes the "magic"
  // correction ratio into account (as in webGLThickness), but so that the
  // antialiasing effect does not depend on the zoom level. So here's yet
  // another thickness version:
  v_thickness = webGLThickness / u_zoomRatio;

  v_normal = unitNormal;

  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;

  #ifdef PICKING_MODE
  // For picking mode, we use the ID as the color:
  v_color = a_id;
  #else
  // For normal mode, we use the color:
  v_color = a_color;
  #endif

  v_color.a *= bias;
}
`
);
var vert_glsl_default6 = SHADER_SOURCE7;

// ../sigma/src/rendering/programs/edge-rectangle/index.ts
var { UNSIGNED_BYTE: UNSIGNED_BYTE6, FLOAT: FLOAT6 } = WebGLRenderingContext;
var UNIFORMS4 = [
  "u_matrix",
  "u_zoomRatio",
  "u_sizeRatio",
  "u_correctionRatio",
  "u_pixelRatio",
  "u_feather",
  "u_minEdgeThickness"
];
var EdgeRectangleProgram = class extends EdgeProgram {
  getDefinition() {
    return {
      VERTICES: 6,
      VERTEX_SHADER_SOURCE: vert_glsl_default6,
      FRAGMENT_SHADER_SOURCE: frag_glsl_default4,
      METHOD: WebGLRenderingContext.TRIANGLES,
      UNIFORMS: UNIFORMS4,
      ATTRIBUTES: [
        { name: "a_positionStart", size: 2, type: FLOAT6 },
        { name: "a_positionEnd", size: 2, type: FLOAT6 },
        { name: "a_normal", size: 2, type: FLOAT6 },
        { name: "a_color", size: 4, type: UNSIGNED_BYTE6, normalized: true },
        { name: "a_id", size: 4, type: UNSIGNED_BYTE6, normalized: true }
      ],
      CONSTANT_ATTRIBUTES: [
        // If 0, then position will be a_positionStart
        // If 2, then position will be a_positionEnd
        { name: "a_positionCoef", size: 1, type: FLOAT6 },
        { name: "a_normalCoef", size: 1, type: FLOAT6 }
      ],
      CONSTANT_DATA: [
        [0, 1],
        [0, -1],
        [1, 1],
        [1, 1],
        [0, -1],
        [1, -1]
      ]
    };
  }
  processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
    const thickness = data.size || 1;
    const x1 = sourceData.x;
    const y1 = sourceData.y;
    const x2 = targetData.x;
    const y2 = targetData.y;
    const color = floatColor(data.color);
    const dx = x2 - x1;
    const dy = y2 - y1;
    let len = dx * dx + dy * dy;
    let n1 = 0;
    let n2 = 0;
    if (len) {
      len = 1 / Math.sqrt(len);
      n1 = -dy * len * thickness;
      n2 = dx * len * thickness;
    }
    const array = this.array;
    array[startIndex++] = x1;
    array[startIndex++] = y1;
    array[startIndex++] = x2;
    array[startIndex++] = y2;
    array[startIndex++] = n1;
    array[startIndex++] = n2;
    array[startIndex++] = color;
    array[startIndex++] = edgeIndex;
  }
  setUniforms(params, { gl, uniformLocations }) {
    const { u_matrix, u_zoomRatio, u_feather, u_pixelRatio, u_correctionRatio, u_sizeRatio, u_minEdgeThickness } = uniformLocations;
    gl.uniformMatrix3fv(u_matrix, false, params.matrix);
    gl.uniform1f(u_zoomRatio, params.zoomRatio);
    gl.uniform1f(u_sizeRatio, params.sizeRatio);
    gl.uniform1f(u_correctionRatio, params.correctionRatio);
    gl.uniform1f(u_pixelRatio, params.pixelRatio);
    gl.uniform1f(u_feather, params.antiAliasingFeather);
    gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
  }
};

// ../sigma/src/rendering/programs/edge-triangle/index.ts
var { UNSIGNED_BYTE: UNSIGNED_BYTE7, FLOAT: FLOAT7 } = WebGLRenderingContext;

// ../sigma/src/settings.ts
var DEFAULT_SETTINGS = {
  // Performance
  hideEdgesOnMove: false,
  hideLabelsOnMove: false,
  renderLabels: true,
  renderEdgeLabels: false,
  enableEdgeEvents: false,
  // Component rendering
  defaultNodeColor: "#999",
  defaultNodeType: "circle",
  defaultEdgeColor: "#ccc",
  defaultEdgeType: "line",
  labelFont: "Arial",
  labelSize: 14,
  labelWeight: "normal",
  labelColor: { color: "#000" },
  edgeLabelFont: "Arial",
  edgeLabelSize: 14,
  edgeLabelWeight: "normal",
  edgeLabelColor: { attribute: "color" },
  stagePadding: 30,
  defaultDrawEdgeLabel: drawStraightEdgeLabel,
  defaultDrawNodeLabel: drawDiscNodeLabel,
  defaultDrawNodeHover: drawDiscNodeHover,
  minEdgeThickness: 1.7,
  antiAliasingFeather: 1,
  // Mouse and touch settings
  dragTimeout: 100,
  draggedEventsTolerance: 3,
  inertiaDuration: 200,
  inertiaRatio: 3,
  zoomDuration: 250,
  zoomingRatio: 1.7,
  doubleClickTimeout: 300,
  doubleClickZoomingRatio: 2.2,
  doubleClickZoomingDuration: 200,
  tapMoveTolerance: 10,
  // Size and scaling
  zoomToSizeRatioFunction: Math.sqrt,
  itemSizesReference: "screen",
  autoRescale: true,
  autoCenter: true,
  // Labels
  labelDensity: 1,
  labelGridCellSize: 100,
  labelRenderedSizeThreshold: 6,
  // Reducers
  nodeReducer: null,
  edgeReducer: null,
  // Features
  zIndex: false,
  minCameraRatio: null,
  maxCameraRatio: null,
  enableCameraRotation: true,
  // Lifecycle
  allowInvalidContainer: false,
  // Program classes
  nodeProgramClasses: {},
  nodeHoverProgramClasses: {},
  edgeProgramClasses: {}
};
var DEFAULT_NODE_PROGRAM_CLASSES = {
  circle: NodeCircleProgram
};
var DEFAULT_EDGE_PROGRAM_CLASSES = {
  arrow: edge_arrow_default,
  line: EdgeRectangleProgram
};
function validateSettings(settings) {
  if (typeof settings.labelDensity !== "number" || settings.labelDensity < 0) {
    throw new Error("Settings: invalid `labelDensity`. Expecting a positive number.");
  }
  const { minCameraRatio, maxCameraRatio } = settings;
  if (typeof minCameraRatio === "number" && typeof maxCameraRatio === "number" && maxCameraRatio < minCameraRatio) {
    throw new Error(
      "Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`."
    );
  }
}
function resolveSettings(settings) {
  const resolvedSettings = assign({}, DEFAULT_SETTINGS, settings);
  resolvedSettings.nodeProgramClasses = assign({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);
  resolvedSettings.edgeProgramClasses = assign({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);
  return resolvedSettings;
}

// ../sigma/src/core/captors/captor.ts
function getPosition(e2, dom) {
  const bbox = dom.getBoundingClientRect();
  return {
    x: e2.clientX - bbox.left,
    y: e2.clientY - bbox.top
  };
}
function getMouseCoords(e2, dom) {
  const res = {
    ...getPosition(e2, dom),
    sigmaDefaultPrevented: false,
    preventSigmaDefault() {
      res.sigmaDefaultPrevented = true;
    },
    original: e2
  };
  return res;
}
function cleanMouseCoords(e2) {
  const res = "x" in e2 ? e2 : {
    ...e2.touches[0] || e2.previousTouches[0],
    original: e2.original,
    sigmaDefaultPrevented: e2.sigmaDefaultPrevented,
    preventSigmaDefault: () => {
      e2.sigmaDefaultPrevented = true;
      res.sigmaDefaultPrevented = true;
    }
  };
  return res;
}
function getWheelCoords(e2, dom) {
  return {
    ...getMouseCoords(e2, dom),
    delta: getWheelDelta(e2)
  };
}
var MAX_TOUCHES = 2;
function getTouchesArray(touches) {
  const arr = [];
  for (let i2 = 0, l2 = Math.min(touches.length, MAX_TOUCHES); i2 < l2; i2++) arr.push(touches[i2]);
  return arr;
}
function getTouchCoords(e2, previousTouches, dom) {
  const res = {
    touches: getTouchesArray(e2.touches).map((touch) => getPosition(touch, dom)),
    previousTouches: previousTouches.map((touch) => getPosition(touch, dom)),
    sigmaDefaultPrevented: false,
    preventSigmaDefault() {
      res.sigmaDefaultPrevented = true;
    },
    original: e2
  };
  return res;
}
function getWheelDelta(e2) {
  if (typeof e2.deltaY !== "undefined") return e2.deltaY * -3 / 360;
  if (typeof e2.detail !== "undefined") return e2.detail / -9;
  throw new Error("Captor: could not extract delta from event.");
}
var Captor = class extends TypedEventEmitter {
  constructor(container, renderer) {
    super();
    this.container = container;
    this.renderer = renderer;
  }
};

// ../sigma/src/core/captors/mouse.ts
var MOUSE_SETTINGS_KEYS = [
  "doubleClickTimeout",
  "doubleClickZoomingDuration",
  "doubleClickZoomingRatio",
  "dragTimeout",
  "draggedEventsTolerance",
  "inertiaDuration",
  "inertiaRatio",
  "zoomDuration",
  "zoomingRatio"
];
var DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(
  (iter, key) => ({ ...iter, [key]: DEFAULT_SETTINGS[key] }),
  {}
);
var MouseCaptor = class extends Captor {
  constructor(container, renderer) {
    super(container, renderer);
    // State
    this.enabled = true;
    this.draggedEvents = 0;
    this.downStartTime = null;
    this.lastMouseX = null;
    this.lastMouseY = null;
    this.isMouseDown = false;
    this.isMoving = false;
    this.movingTimeout = null;
    this.startCameraState = null;
    this.clicks = 0;
    this.doubleClickTimeout = null;
    this.currentWheelDirection = 0;
    this.settings = DEFAULT_MOUSE_SETTINGS;
    this.handleClick = this.handleClick.bind(this);
    this.handleRightClick = this.handleRightClick.bind(this);
    this.handleDown = this.handleDown.bind(this);
    this.handleUp = this.handleUp.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleWheel = this.handleWheel.bind(this);
    this.handleLeave = this.handleLeave.bind(this);
    this.handleEnter = this.handleEnter.bind(this);
    container.addEventListener("click", this.handleClick, { capture: false });
    container.addEventListener("contextmenu", this.handleRightClick, { capture: false });
    container.addEventListener("mousedown", this.handleDown, { capture: false });
    container.addEventListener("wheel", this.handleWheel, { capture: false });
    container.addEventListener("mouseleave", this.handleLeave, { capture: false });
    container.addEventListener("mouseenter", this.handleEnter, { capture: false });
    document.addEventListener("mousemove", this.handleMove, { capture: false });
    document.addEventListener("mouseup", this.handleUp, { capture: false });
  }
  kill() {
    const container = this.container;
    container.removeEventListener("click", this.handleClick);
    container.removeEventListener("contextmenu", this.handleRightClick);
    container.removeEventListener("mousedown", this.handleDown);
    container.removeEventListener("wheel", this.handleWheel);
    container.removeEventListener("mouseleave", this.handleLeave);
    container.removeEventListener("mouseenter", this.handleEnter);
    document.removeEventListener("mousemove", this.handleMove);
    document.removeEventListener("mouseup", this.handleUp);
  }
  handleClick(e2) {
    if (!this.enabled) return;
    this.clicks++;
    if (this.clicks === 2) {
      this.clicks = 0;
      if (typeof this.doubleClickTimeout === "number") {
        clearTimeout(this.doubleClickTimeout);
        this.doubleClickTimeout = null;
      }
      return this.handleDoubleClick(e2);
    }
    setTimeout(() => {
      this.clicks = 0;
      this.doubleClickTimeout = null;
    }, this.settings.doubleClickTimeout);
    if (this.draggedEvents < this.settings.draggedEventsTolerance)
      this.emit("click", getMouseCoords(e2, this.container));
  }
  handleRightClick(e2) {
    if (!this.enabled) return;
    this.emit("rightClick", getMouseCoords(e2, this.container));
  }
  handleDoubleClick(e2) {
    if (!this.enabled) return;
    e2.preventDefault();
    e2.stopPropagation();
    const mouseCoords = getMouseCoords(e2, this.container);
    this.emit("doubleClick", mouseCoords);
    if (mouseCoords.sigmaDefaultPrevented) return;
    const camera = this.renderer.getCamera();
    const newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);
    camera.animate(this.renderer.getViewportZoomedState(getPosition(e2, this.container), newRatio), {
      easing: "quadraticInOut",
      duration: this.settings.doubleClickZoomingDuration
    });
  }
  handleDown(e2) {
    if (!this.enabled) return;
    if (e2.button === 0) {
      this.startCameraState = this.renderer.getCamera().getState();
      const { x: x2, y: y2 } = getPosition(e2, this.container);
      this.lastMouseX = x2;
      this.lastMouseY = y2;
      this.draggedEvents = 0;
      this.downStartTime = Date.now();
      this.isMouseDown = true;
    }
    this.emit("mousedown", getMouseCoords(e2, this.container));
  }
  handleUp(e2) {
    if (!this.enabled || !this.isMouseDown) return;
    const camera = this.renderer.getCamera();
    this.isMouseDown = false;
    if (typeof this.movingTimeout === "number") {
      clearTimeout(this.movingTimeout);
      this.movingTimeout = null;
    }
    const { x: x2, y: y2 } = getPosition(e2, this.container);
    const cameraState = camera.getState(), previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };
    if (this.isMoving) {
      camera.animate(
        {
          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),
          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)
        },
        {
          duration: this.settings.inertiaDuration,
          easing: "quadraticOut"
        }
      );
    } else if (this.lastMouseX !== x2 || this.lastMouseY !== y2) {
      camera.setState({
        x: cameraState.x,
        y: cameraState.y
      });
    }
    this.isMoving = false;
    setTimeout(() => {
      const shouldRefresh = this.draggedEvents > 0;
      this.draggedEvents = 0;
      if (shouldRefresh) this.renderer.refresh();
    }, 0);
    this.emit("mouseup", getMouseCoords(e2, this.container));
  }
  handleMove(e2) {
    if (!this.enabled) return;
    const mouseCoords = getMouseCoords(e2, this.container);
    this.emit("mousemovebody", mouseCoords);
    if (e2.target === this.container || e2.composedPath()[0] === this.container) {
      this.emit("mousemove", mouseCoords);
    }
    if (mouseCoords.sigmaDefaultPrevented) return;
    if (this.isMouseDown) {
      this.isMoving = true;
      this.draggedEvents++;
      if (typeof this.movingTimeout === "number") {
        clearTimeout(this.movingTimeout);
      }
      this.movingTimeout = window.setTimeout(() => {
        this.movingTimeout = null;
        this.isMoving = false;
      }, this.settings.dragTimeout);
      const camera = this.renderer.getCamera();
      const { x: eX, y: eY } = getPosition(e2, this.container);
      const lastMouse = this.renderer.viewportToFramedGraph({
        x: this.lastMouseX,
        y: this.lastMouseY
      });
      const mouse = this.renderer.viewportToFramedGraph({ x: eX, y: eY });
      const offsetX = lastMouse.x - mouse.x, offsetY = lastMouse.y - mouse.y;
      const cameraState = camera.getState();
      const x2 = cameraState.x + offsetX, y2 = cameraState.y + offsetY;
      camera.setState({ x: x2, y: y2 });
      this.lastMouseX = eX;
      this.lastMouseY = eY;
      e2.preventDefault();
      e2.stopPropagation();
    }
  }
  handleLeave(e2) {
    this.emit("mouseleave", getMouseCoords(e2, this.container));
  }
  handleEnter(e2) {
    this.emit("mouseenter", getMouseCoords(e2, this.container));
  }
  handleWheel(e2) {
    if (!this.enabled) return;
    e2.preventDefault();
    e2.stopPropagation();
    const delta = getWheelDelta(e2);
    if (!delta) return;
    const wheelCoords = getWheelCoords(e2, this.container);
    this.emit("wheel", wheelCoords);
    if (wheelCoords.sigmaDefaultPrevented) return;
    const ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;
    const camera = this.renderer.getCamera();
    const newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);
    const wheelDirection = delta > 0 ? 1 : -1;
    const now = Date.now();
    if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {
      return;
    }
    camera.animate(
      this.renderer.getViewportZoomedState(getPosition(e2, this.container), newRatio),
      {
        easing: "quadraticOut",
        duration: this.settings.zoomDuration
      },
      () => {
        this.currentWheelDirection = 0;
      }
    );
    this.currentWheelDirection = wheelDirection;
    this.lastWheelTriggerTime = now;
  }
  setSettings(settings) {
    this.settings = settings;
  }
};

// ../sigma/src/core/captors/touch.ts
var TOUCH_SETTINGS_KEYS = [
  "dragTimeout",
  "inertiaDuration",
  "inertiaRatio",
  "doubleClickTimeout",
  "doubleClickZoomingRatio",
  "doubleClickZoomingDuration",
  "tapMoveTolerance"
];
var DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(
  (iter, key) => ({ ...iter, [key]: DEFAULT_SETTINGS[key] }),
  {}
);
var TouchCaptor = class extends Captor {
  constructor(container, renderer) {
    super(container, renderer);
    this.enabled = true;
    this.isMoving = false;
    this.hasMoved = false;
    this.touchMode = 0;
    this.startTouchesPositions = [];
    this.lastTouches = [];
    this.lastTap = null;
    this.settings = DEFAULT_TOUCH_SETTINGS;
    this.handleStart = this.handleStart.bind(this);
    this.handleLeave = this.handleLeave.bind(this);
    this.handleMove = this.handleMove.bind(this);
    container.addEventListener("touchstart", this.handleStart, { capture: false });
    container.addEventListener("touchcancel", this.handleLeave, { capture: false });
    document.addEventListener("touchend", this.handleLeave, { capture: false, passive: false });
    document.addEventListener("touchmove", this.handleMove, { capture: false, passive: false });
  }
  kill() {
    const container = this.container;
    container.removeEventListener("touchstart", this.handleStart);
    container.removeEventListener("touchcancel", this.handleLeave);
    document.removeEventListener("touchend", this.handleLeave);
    document.removeEventListener("touchmove", this.handleMove);
  }
  getDimensions() {
    return {
      width: this.container.offsetWidth,
      height: this.container.offsetHeight
    };
  }
  handleStart(e2) {
    if (!this.enabled) return;
    e2.preventDefault();
    const touches = getTouchesArray(e2.touches);
    this.touchMode = touches.length;
    this.startCameraState = this.renderer.getCamera().getState();
    this.startTouchesPositions = touches.map((touch) => getPosition(touch, this.container));
    if (this.touchMode === 2) {
      const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.startTouchesPositions;
      this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);
      this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
    }
    this.emit("touchdown", getTouchCoords(e2, this.lastTouches, this.container));
    this.lastTouches = touches;
    this.lastTouchesPositions = this.startTouchesPositions;
  }
  handleLeave(e2) {
    if (!this.enabled || !this.startTouchesPositions.length) return;
    if (e2.cancelable) e2.preventDefault();
    if (this.movingTimeout) {
      this.isMoving = false;
      clearTimeout(this.movingTimeout);
    }
    switch (this.touchMode) {
      case 2:
        if (e2.touches.length === 1) {
          this.handleStart(e2);
          e2.preventDefault();
          break;
        }
      case 1:
        if (this.isMoving) {
          const camera = this.renderer.getCamera();
          const cameraState = camera.getState(), previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };
          camera.animate(
            {
              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),
              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)
            },
            {
              duration: this.settings.inertiaDuration,
              easing: "quadraticOut"
            }
          );
        }
        this.hasMoved = false;
        this.isMoving = false;
        this.touchMode = 0;
        break;
    }
    this.emit("touchup", getTouchCoords(e2, this.lastTouches, this.container));
    if (!e2.touches.length) {
      const position = getPosition(this.lastTouches[0], this.container);
      const downPosition = this.startTouchesPositions[0];
      const dSquare = (position.x - downPosition.x) ** 2 + (position.y - downPosition.y) ** 2;
      if (!e2.touches.length && dSquare < this.settings.tapMoveTolerance ** 2) {
        if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {
          const touchCoords = getTouchCoords(e2, this.lastTouches, this.container);
          this.emit("doubletap", touchCoords);
          this.lastTap = null;
          if (!touchCoords.sigmaDefaultPrevented) {
            const camera = this.renderer.getCamera();
            const newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);
            camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {
              easing: "quadraticInOut",
              duration: this.settings.doubleClickZoomingDuration
            });
          }
        } else {
          const touchCoords = getTouchCoords(e2, this.lastTouches, this.container);
          this.emit("tap", touchCoords);
          this.lastTap = { time: Date.now(), position: touchCoords.touches[0] || touchCoords.previousTouches[0] };
        }
      }
    }
    this.lastTouches = getTouchesArray(e2.touches);
    this.startTouchesPositions = [];
  }
  handleMove(e2) {
    if (!this.enabled || !this.startTouchesPositions.length) return;
    e2.preventDefault();
    const touches = getTouchesArray(e2.touches);
    const touchesPositions = touches.map((touch) => getPosition(touch, this.container));
    const lastTouches = this.lastTouches;
    this.lastTouches = touches;
    this.lastTouchesPositions = touchesPositions;
    const touchCoords = getTouchCoords(e2, lastTouches, this.container);
    this.emit("touchmove", touchCoords);
    if (touchCoords.sigmaDefaultPrevented) return;
    this.hasMoved || (this.hasMoved = touchesPositions.some((position, idx) => {
      const startPosition = this.startTouchesPositions[idx];
      return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);
    }));
    if (!this.hasMoved) {
      return;
    }
    this.isMoving = true;
    if (this.movingTimeout) clearTimeout(this.movingTimeout);
    this.movingTimeout = window.setTimeout(() => {
      this.isMoving = false;
    }, this.settings.dragTimeout);
    const camera = this.renderer.getCamera();
    const startCameraState = this.startCameraState;
    const padding = this.renderer.getSetting("stagePadding");
    switch (this.touchMode) {
      case 1: {
        const { x: xStart, y: yStart } = this.renderer.viewportToFramedGraph(
          (this.startTouchesPositions || [])[0]
        );
        const { x: x2, y: y2 } = this.renderer.viewportToFramedGraph(touchesPositions[0]);
        camera.setState({
          x: startCameraState.x + xStart - x2,
          y: startCameraState.y + yStart - y2
        });
        break;
      }
      case 2: {
        const newCameraState = {
          x: 0.5,
          y: 0.5,
          angle: 0,
          ratio: 1
        };
        const { x: x0, y: y0 } = touchesPositions[0];
        const { x: x1, y: y1 } = touchesPositions[1];
        const angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;
        const ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;
        const newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);
        newCameraState.ratio = newRatio;
        newCameraState.angle = startCameraState.angle + angleDiff;
        const dimensions = this.getDimensions();
        const touchGraphPosition = this.renderer.viewportToFramedGraph(
          (this.startTouchesPositions || [])[0],
          { cameraState: startCameraState }
        );
        const smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;
        const dx = smallestDimension / dimensions.width;
        const dy = smallestDimension / dimensions.height;
        const ratio = newRatio / smallestDimension;
        let x2 = x0 - smallestDimension / 2 / dx;
        let y2 = y0 - smallestDimension / 2 / dy;
        [x2, y2] = [
          x2 * Math.cos(-newCameraState.angle) - y2 * Math.sin(-newCameraState.angle),
          y2 * Math.cos(-newCameraState.angle) + x2 * Math.sin(-newCameraState.angle)
        ];
        newCameraState.x = touchGraphPosition.x - x2 * ratio;
        newCameraState.y = touchGraphPosition.y + y2 * ratio;
        camera.setState(newCameraState);
        break;
      }
    }
  }
  setSettings(settings) {
    this.settings = settings;
  }
};

// ../sigma/src/core/labels.ts
var LabelCandidate = class {
  constructor(key, size) {
    this.key = key;
    this.size = size;
  }
  static compare(first, second) {
    if (first.size > second.size) return -1;
    if (first.size < second.size) return 1;
    if (first.key > second.key) return 1;
    return -1;
  }
};
var LabelGrid = class {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.cellSize = 0;
    this.columns = 0;
    this.rows = 0;
    this.cells = {};
  }
  resizeAndClear(dimensions, cellSize) {
    this.width = dimensions.width;
    this.height = dimensions.height;
    this.cellSize = cellSize;
    this.columns = Math.ceil(dimensions.width / cellSize);
    this.rows = Math.ceil(dimensions.height / cellSize);
    this.cells = {};
  }
  getIndex(pos) {
    const xIndex = Math.floor(pos.x / this.cellSize);
    const yIndex = Math.floor(pos.y / this.cellSize);
    return yIndex * this.columns + xIndex;
  }
  add(key, size, pos) {
    const candidate = new LabelCandidate(key, size);
    const index = this.getIndex(pos);
    let cell = this.cells[index];
    if (!cell) {
      cell = [];
      this.cells[index] = cell;
    }
    cell.push(candidate);
  }
  organize() {
    for (const k2 in this.cells) {
      const cell = this.cells[k2];
      cell.sort(LabelCandidate.compare);
    }
  }
  getLabelsToDisplay(ratio, density) {
    const cellArea = this.cellSize * this.cellSize;
    const scaledCellArea = cellArea / ratio / ratio;
    const scaledDensity = scaledCellArea * density / cellArea;
    const labelsToDisplayPerCell = Math.ceil(scaledDensity);
    const labels = [];
    for (const k2 in this.cells) {
      const cell = this.cells[k2];
      for (let i2 = 0; i2 < Math.min(labelsToDisplayPerCell, cell.length); i2++) {
        labels.push(cell[i2].key);
      }
    }
    return labels;
  }
};
function edgeLabelsToDisplayFromNodes(params) {
  const { graph, hoveredNode, highlightedNodes, displayedNodeLabels } = params;
  const worthyEdges = [];
  graph.forEachEdge((edge, _2, source, target) => {
    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {
      worthyEdges.push(edge);
    }
  });
  return worthyEdges;
}

// ../sigma/src/sigma.ts
var X_LABEL_MARGIN = 150;
var Y_LABEL_MARGIN = 50;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function applyNodeDefaults(settings, key, data) {
  if (!hasOwnProperty.call(data, "x") || !hasOwnProperty.call(data, "y"))
    throw new Error(
      `Sigma: could not find a valid position (x, y) for node "${key}". All your nodes must have a number "x" and "y". Maybe your forgot to apply a layout or your "nodeReducer" is not returning the correct data?`
    );
  if (!data.color) data.color = settings.defaultNodeColor;
  if (!data.label && data.label !== "") data.label = null;
  if (data.label !== void 0 && data.label !== null) data.label = "" + data.label;
  else data.label = null;
  if (!data.size) data.size = 2;
  if (!hasOwnProperty.call(data, "hidden")) data.hidden = false;
  if (!hasOwnProperty.call(data, "highlighted")) data.highlighted = false;
  if (!hasOwnProperty.call(data, "forceLabel")) data.forceLabel = false;
  if (!data.type || data.type === "") data.type = settings.defaultNodeType;
  if (!data.zIndex) data.zIndex = 0;
  return data;
}
function applyEdgeDefaults(settings, _key, data) {
  if (!data.color) data.color = settings.defaultEdgeColor;
  if (!data.label) data.label = "";
  if (!data.size) data.size = 0.5;
  if (!hasOwnProperty.call(data, "hidden")) data.hidden = false;
  if (!hasOwnProperty.call(data, "forceLabel")) data.forceLabel = false;
  if (!data.type || data.type === "") data.type = settings.defaultEdgeType;
  if (!data.zIndex) data.zIndex = 0;
  return data;
}
var Sigma = class extends TypedEventEmitter {
  constructor(graph, container, settings = {}) {
    super();
    this.elements = {};
    this.canvasContexts = {};
    this.webGLContexts = {};
    this.pickingLayers = /* @__PURE__ */ new Set();
    this.textures = {};
    this.frameBuffers = {};
    this.activeListeners = {};
    this.labelGrid = new LabelGrid();
    this.nodeDataCache = {};
    this.edgeDataCache = {};
    // Indices to keep track of the index of the item inside programs
    this.nodeProgramIndex = {};
    this.edgeProgramIndex = {};
    this.nodesWithForcedLabels = /* @__PURE__ */ new Set();
    this.edgesWithForcedLabels = /* @__PURE__ */ new Set();
    this.nodeExtent = { x: [0, 1], y: [0, 1] };
    this.nodeZExtent = [Infinity, -Infinity];
    this.edgeZExtent = [Infinity, -Infinity];
    this.matrix = identity();
    this.invMatrix = identity();
    this.correctionRatio = 1;
    this.customBBox = null;
    this.normalizationFunction = createNormalizationFunction({
      x: [0, 1],
      y: [0, 1]
    });
    // Cache:
    this.graphToViewportRatio = 1;
    this.itemIDsIndex = {};
    this.nodeIndices = {};
    this.edgeIndices = {};
    // Starting dimensions and pixel ratio
    this.width = 0;
    this.height = 0;
    this.pixelRatio = getPixelRatio();
    this.pickingDownSizingRatio = 2 * this.pixelRatio;
    // Graph State
    this.displayedNodeLabels = /* @__PURE__ */ new Set();
    this.displayedEdgeLabels = /* @__PURE__ */ new Set();
    this.highlightedNodes = /* @__PURE__ */ new Set();
    this.hoveredNode = null;
    this.hoveredEdge = null;
    // Internal states
    this.renderFrame = null;
    this.renderHighlightedNodesFrame = null;
    this.needToProcess = false;
    this.checkEdgesEventsFrame = null;
    // Programs
    this.nodePrograms = {};
    this.nodeHoverPrograms = {};
    this.edgePrograms = {};
    this.settings = resolveSettings(settings);
    validateSettings(this.settings);
    validateGraph(graph);
    if (!(container instanceof HTMLElement)) throw new Error("Sigma: container should be an html element.");
    this.graph = graph;
    this.container = container;
    this.createWebGLContext("edges", { picking: settings.enableEdgeEvents });
    this.createCanvasContext("edgeLabels");
    this.createWebGLContext("nodes", { picking: true });
    this.createCanvasContext("labels");
    this.createCanvasContext("hovers");
    this.createWebGLContext("hoverNodes");
    this.createCanvasContext("mouse", { style: { touchAction: "none", userSelect: "none" } });
    this.resize();
    for (const type in this.settings.nodeProgramClasses) {
      this.registerNodeProgram(
        type,
        this.settings.nodeProgramClasses[type],
        this.settings.nodeHoverProgramClasses[type]
      );
    }
    for (const type in this.settings.edgeProgramClasses) {
      this.registerEdgeProgram(type, this.settings.edgeProgramClasses[type]);
    }
    this.camera = new Camera();
    this.bindCameraHandlers();
    this.mouseCaptor = new MouseCaptor(this.elements.mouse, this);
    this.mouseCaptor.setSettings(this.settings);
    this.touchCaptor = new TouchCaptor(this.elements.mouse, this);
    this.touchCaptor.setSettings(this.settings);
    this.bindEventHandlers();
    this.bindGraphHandlers();
    this.handleSettingsUpdate();
    this.refresh();
  }
  /**---------------------------------------------------------------------------
   * Internal methods.
   **---------------------------------------------------------------------------
   */
  /**
   * Internal function used to register a node program
   *
   * @param  {string}           key              - The program's key, matching the related nodes "type" values.
   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.
   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).
   * @return {Sigma}
   */
  registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {
    if (this.nodePrograms[key]) this.nodePrograms[key].kill();
    if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();
    this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);
    this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);
    return this;
  }
  /**
   * Internal function used to register an edge program
   *
   * @param  {string}          key              - The program's key, matching the related edges "type" values.
   * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.
   * @return {Sigma}
   */
  registerEdgeProgram(key, EdgeProgramClass) {
    if (this.edgePrograms[key]) this.edgePrograms[key].kill();
    this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);
    return this;
  }
  /**
   * Internal function used to unregister a node program
   *
   * @param  {string} key - The program's key, matching the related nodes "type" values.
   * @return {Sigma}
   */
  unregisterNodeProgram(key) {
    if (this.nodePrograms[key]) {
      const { [key]: program, ...programs } = this.nodePrograms;
      program.kill();
      this.nodePrograms = programs;
    }
    if (this.nodeHoverPrograms[key]) {
      const { [key]: program, ...programs } = this.nodeHoverPrograms;
      program.kill();
      this.nodePrograms = programs;
    }
    return this;
  }
  /**
   * Internal function used to unregister an edge program
   *
   * @param  {string} key - The program's key, matching the related edges "type" values.
   * @return {Sigma}
   */
  unregisterEdgeProgram(key) {
    if (this.edgePrograms[key]) {
      const { [key]: program, ...programs } = this.edgePrograms;
      program.kill();
      this.edgePrograms = programs;
    }
    return this;
  }
  /**
   * Method (re)binding WebGL texture (for picking).
   *
   * @return {Sigma}
   */
  resetWebGLTexture(id) {
    const gl = this.webGLContexts[id];
    const frameBuffer = this.frameBuffers[id];
    const currentTexture = this.textures[id];
    if (currentTexture) gl.deleteTexture(currentTexture);
    const pickingTexture = gl.createTexture();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.bindTexture(gl.TEXTURE_2D, pickingTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);
    this.textures[id] = pickingTexture;
    return this;
  }
  /**
   * Method binding camera handlers.
   *
   * @return {Sigma}
   */
  bindCameraHandlers() {
    this.activeListeners.camera = () => {
      this.scheduleRender();
    };
    this.camera.on("updated", this.activeListeners.camera);
    return this;
  }
  /**
   * Method unbinding camera handlers.
   *
   * @return {Sigma}
   */
  unbindCameraHandlers() {
    this.camera.removeListener("updated", this.activeListeners.camera);
    return this;
  }
  /**
   * Method that returns the closest node to a given position.
   */
  getNodeAtPosition(position) {
    const { x: x2, y: y2 } = position;
    const color = getPixelColor(
      this.webGLContexts.nodes,
      this.frameBuffers.nodes,
      x2,
      y2,
      this.pixelRatio,
      this.pickingDownSizingRatio
    );
    const index = colorToIndex(...color);
    const itemAt = this.itemIDsIndex[index];
    return itemAt && itemAt.type === "node" ? itemAt.id : null;
  }
  /**
   * Method binding event handlers.
   *
   * @return {Sigma}
   */
  bindEventHandlers() {
    this.activeListeners.handleResize = () => {
      this.scheduleRefresh();
    };
    window.addEventListener("resize", this.activeListeners.handleResize);
    this.activeListeners.handleMove = (e2) => {
      const event = cleanMouseCoords(e2);
      const baseEvent = {
        event,
        preventSigmaDefault() {
          event.preventSigmaDefault();
        }
      };
      const nodeToHover = this.getNodeAtPosition(event);
      if (nodeToHover && this.hoveredNode !== nodeToHover && !this.nodeDataCache[nodeToHover].hidden) {
        if (this.hoveredNode) this.emit("leaveNode", { ...baseEvent, node: this.hoveredNode });
        this.hoveredNode = nodeToHover;
        this.emit("enterNode", { ...baseEvent, node: nodeToHover });
        this.scheduleHighlightedNodesRender();
        return;
      }
      if (this.hoveredNode) {
        if (this.getNodeAtPosition(event) !== this.hoveredNode) {
          const node = this.hoveredNode;
          this.hoveredNode = null;
          this.emit("leaveNode", { ...baseEvent, node });
          this.scheduleHighlightedNodesRender();
          return;
        }
      }
      if (this.settings.enableEdgeEvents) {
        const edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);
        if (edgeToHover !== this.hoveredEdge) {
          if (this.hoveredEdge) this.emit("leaveEdge", { ...baseEvent, edge: this.hoveredEdge });
          if (edgeToHover) this.emit("enterEdge", { ...baseEvent, edge: edgeToHover });
          this.hoveredEdge = edgeToHover;
        }
      }
    };
    this.activeListeners.handleMoveBody = (e2) => {
      const event = cleanMouseCoords(e2);
      this.emit("moveBody", {
        event,
        preventSigmaDefault() {
          event.preventSigmaDefault();
        }
      });
    };
    this.activeListeners.handleLeave = (e2) => {
      const event = cleanMouseCoords(e2);
      const baseEvent = {
        event,
        preventSigmaDefault() {
          event.preventSigmaDefault();
        }
      };
      if (this.hoveredNode) {
        this.emit("leaveNode", { ...baseEvent, node: this.hoveredNode });
        this.scheduleHighlightedNodesRender();
      }
      if (this.settings.enableEdgeEvents && this.hoveredEdge) {
        this.emit("leaveEdge", { ...baseEvent, edge: this.hoveredEdge });
        this.scheduleHighlightedNodesRender();
      }
      this.emit("leaveStage", { ...baseEvent });
    };
    this.activeListeners.handleEnter = (e2) => {
      const event = cleanMouseCoords(e2);
      const baseEvent = {
        event,
        preventSigmaDefault() {
          event.preventSigmaDefault();
        }
      };
      this.emit("enterStage", { ...baseEvent });
    };
    const createInteractionListener = (eventType) => {
      return (e2) => {
        const event = cleanMouseCoords(e2);
        const baseEvent = {
          event,
          preventSigmaDefault: () => {
            event.preventSigmaDefault();
          }
        };
        const nodeAtPosition = this.getNodeAtPosition(event);
        if (nodeAtPosition)
          return this.emit(`${eventType}Node`, {
            ...baseEvent,
            node: nodeAtPosition
          });
        if (this.settings.enableEdgeEvents) {
          const edge = this.getEdgeAtPoint(event.x, event.y);
          if (edge) return this.emit(`${eventType}Edge`, { ...baseEvent, edge });
        }
        return this.emit(`${eventType}Stage`, baseEvent);
      };
    };
    this.activeListeners.handleClick = createInteractionListener("click");
    this.activeListeners.handleRightClick = createInteractionListener("rightClick");
    this.activeListeners.handleDoubleClick = createInteractionListener("doubleClick");
    this.activeListeners.handleWheel = createInteractionListener("wheel");
    this.activeListeners.handleDown = createInteractionListener("down");
    this.activeListeners.handleUp = createInteractionListener("up");
    this.mouseCaptor.on("mousemove", this.activeListeners.handleMove);
    this.mouseCaptor.on("mousemovebody", this.activeListeners.handleMoveBody);
    this.mouseCaptor.on("click", this.activeListeners.handleClick);
    this.mouseCaptor.on("rightClick", this.activeListeners.handleRightClick);
    this.mouseCaptor.on("doubleClick", this.activeListeners.handleDoubleClick);
    this.mouseCaptor.on("wheel", this.activeListeners.handleWheel);
    this.mouseCaptor.on("mousedown", this.activeListeners.handleDown);
    this.mouseCaptor.on("mouseup", this.activeListeners.handleUp);
    this.mouseCaptor.on("mouseleave", this.activeListeners.handleLeave);
    this.mouseCaptor.on("mouseenter", this.activeListeners.handleEnter);
    this.touchCaptor.on("touchdown", this.activeListeners.handleDown);
    this.touchCaptor.on("touchdown", this.activeListeners.handleMove);
    this.touchCaptor.on("touchup", this.activeListeners.handleUp);
    this.touchCaptor.on("touchmove", this.activeListeners.handleMove);
    this.touchCaptor.on("tap", this.activeListeners.handleClick);
    this.touchCaptor.on("doubletap", this.activeListeners.handleDoubleClick);
    this.touchCaptor.on("touchmove", this.activeListeners.handleMoveBody);
    return this;
  }
  /**
   * Method binding graph handlers
   *
   * @return {Sigma}
   */
  bindGraphHandlers() {
    const graph = this.graph;
    const LAYOUT_IMPACTING_FIELDS = /* @__PURE__ */ new Set(["x", "y", "zIndex", "type"]);
    this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = (e2) => {
      var _a;
      const updatedFields = (_a = e2.hints) == null ? void 0 : _a.attributes;
      this.graph.forEachNode((node) => this.updateNode(node));
      const layoutChanged = !updatedFields || updatedFields.some((f2) => LAYOUT_IMPACTING_FIELDS.has(f2));
      this.refresh({ partialGraph: { nodes: graph.nodes() }, skipIndexation: !layoutChanged, schedule: true });
    };
    this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = (e2) => {
      var _a;
      const updatedFields = (_a = e2.hints) == null ? void 0 : _a.attributes;
      this.graph.forEachEdge((edge) => this.updateEdge(edge));
      const layoutChanged = updatedFields && ["zIndex", "type"].some((f2) => updatedFields == null ? void 0 : updatedFields.includes(f2));
      this.refresh({ partialGraph: { edges: graph.edges() }, skipIndexation: !layoutChanged, schedule: true });
    };
    this.activeListeners.addNodeGraphUpdate = (payload) => {
      const node = payload.key;
      this.addNode(node);
      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });
    };
    this.activeListeners.updateNodeGraphUpdate = (payload) => {
      const node = payload.key;
      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });
    };
    this.activeListeners.dropNodeGraphUpdate = (payload) => {
      const node = payload.key;
      this.removeNode(node);
      this.refresh({ schedule: true });
    };
    this.activeListeners.addEdgeGraphUpdate = (payload) => {
      const edge = payload.key;
      this.addEdge(edge);
      this.refresh({ partialGraph: { edges: [edge] }, schedule: true });
    };
    this.activeListeners.updateEdgeGraphUpdate = (payload) => {
      const edge = payload.key;
      this.refresh({ partialGraph: { edges: [edge] }, skipIndexation: false, schedule: true });
    };
    this.activeListeners.dropEdgeGraphUpdate = (payload) => {
      const edge = payload.key;
      this.removeEdge(edge);
      this.refresh({ schedule: true });
    };
    this.activeListeners.clearEdgesGraphUpdate = () => {
      this.clearEdgeState();
      this.clearEdgeIndices();
      this.refresh({ schedule: true });
    };
    this.activeListeners.clearGraphUpdate = () => {
      this.clearEdgeState();
      this.clearNodeState();
      this.clearEdgeIndices();
      this.clearNodeIndices();
      this.refresh({ schedule: true });
    };
    graph.on("nodeAdded", this.activeListeners.addNodeGraphUpdate);
    graph.on("nodeDropped", this.activeListeners.dropNodeGraphUpdate);
    graph.on("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate);
    graph.on("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);
    graph.on("edgeAdded", this.activeListeners.addEdgeGraphUpdate);
    graph.on("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
    graph.on("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate);
    graph.on("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);
    graph.on("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
    graph.on("cleared", this.activeListeners.clearGraphUpdate);
    return this;
  }
  /**
   * Method used to unbind handlers from the graph.
   *
   * @return {undefined}
   */
  unbindGraphHandlers() {
    const graph = this.graph;
    graph.removeListener("nodeAdded", this.activeListeners.addNodeGraphUpdate);
    graph.removeListener("nodeDropped", this.activeListeners.dropNodeGraphUpdate);
    graph.removeListener("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate);
    graph.removeListener("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);
    graph.removeListener("edgeAdded", this.activeListeners.addEdgeGraphUpdate);
    graph.removeListener("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
    graph.removeListener("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate);
    graph.removeListener("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);
    graph.removeListener("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
    graph.removeListener("cleared", this.activeListeners.clearGraphUpdate);
  }
  /**
   * Method looking for an edge colliding with a given point at (x, y). Returns
   * the key of the edge if any, or null else.
   */
  getEdgeAtPoint(x2, y2) {
    const color = getPixelColor(
      this.webGLContexts.edges,
      this.frameBuffers.edges,
      x2,
      y2,
      this.pixelRatio,
      this.pickingDownSizingRatio
    );
    const index = colorToIndex(...color);
    const itemAt = this.itemIDsIndex[index];
    return itemAt && itemAt.type === "edge" ? itemAt.id : null;
  }
  /**
   * Method used to process the whole graph's data.
   *  - extent
   *  - normalizationFunction
   *  - compute node's coordinate
   *  - labelgrid
   *  - program data allocation
   * @return {Sigma}
   */
  process() {
    this.emit("beforeProcess");
    const graph = this.graph;
    const settings = this.settings;
    const dimensions = this.getDimensions();
    this.nodeExtent = graphExtent(this.graph);
    if (!this.settings.autoRescale) {
      const { width, height } = dimensions;
      const { x: x2, y: y2 } = this.nodeExtent;
      this.nodeExtent = {
        x: [(x2[0] + x2[1]) / 2 - width / 2, (x2[0] + x2[1]) / 2 + width / 2],
        y: [(y2[0] + y2[1]) / 2 - height / 2, (y2[0] + y2[1]) / 2 + height / 2]
      };
    }
    this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);
    const nullCamera = new Camera();
    const nullCameraMatrix = matrixFromCamera(
      nullCamera.getState(),
      dimensions,
      this.getGraphDimensions(),
      this.getStagePadding()
    );
    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);
    const nodesPerPrograms = {};
    const nodeIndices = {};
    const edgeIndices = {};
    const itemIDsIndex = {};
    let incrID = 1;
    let nodes = graph.nodes();
    for (let i2 = 0, l2 = nodes.length; i2 < l2; i2++) {
      const node = nodes[i2];
      const data = this.nodeDataCache[node];
      const attrs = graph.getNodeAttributes(node);
      data.x = attrs.x;
      data.y = attrs.y;
      this.normalizationFunction.applyTo(data);
      if (typeof data.label === "string" && !data.hidden)
        this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));
      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;
    }
    this.labelGrid.organize();
    for (const type in this.nodePrograms) {
      if (!hasOwnProperty.call(this.nodePrograms, type)) {
        throw new Error(`Sigma: could not find a suitable program for node type "${type}"!`);
      }
      this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);
      nodesPerPrograms[type] = 0;
    }
    if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1])
      nodes = zIndexOrdering(
        this.nodeZExtent,
        (node) => this.nodeDataCache[node].zIndex,
        nodes
      );
    for (let i2 = 0, l2 = nodes.length; i2 < l2; i2++) {
      const node = nodes[i2];
      nodeIndices[node] = incrID;
      itemIDsIndex[nodeIndices[node]] = { type: "node", id: node };
      incrID++;
      const data = this.nodeDataCache[node];
      this.addNodeToProgram(node, nodeIndices[node], nodesPerPrograms[data.type]++);
    }
    const edgesPerPrograms = {};
    let edges = graph.edges();
    for (let i2 = 0, l2 = edges.length; i2 < l2; i2++) {
      const edge = edges[i2];
      const data = this.edgeDataCache[edge];
      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;
    }
    if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1])
      edges = zIndexOrdering(
        this.edgeZExtent,
        (edge) => this.edgeDataCache[edge].zIndex,
        edges
      );
    for (const type in this.edgePrograms) {
      if (!hasOwnProperty.call(this.edgePrograms, type)) {
        throw new Error(`Sigma: could not find a suitable program for edge type "${type}"!`);
      }
      this.edgePrograms[type].reallocate(edgesPerPrograms[type] || 0);
      edgesPerPrograms[type] = 0;
    }
    for (let i2 = 0, l2 = edges.length; i2 < l2; i2++) {
      const edge = edges[i2];
      edgeIndices[edge] = incrID;
      itemIDsIndex[edgeIndices[edge]] = { type: "edge", id: edge };
      incrID++;
      const data = this.edgeDataCache[edge];
      this.addEdgeToProgram(edge, edgeIndices[edge], edgesPerPrograms[data.type]++);
    }
    this.itemIDsIndex = itemIDsIndex;
    this.nodeIndices = nodeIndices;
    this.edgeIndices = edgeIndices;
    this.emit("afterProcess");
    return this;
  }
  /**
   * Method that backports potential settings updates where it's needed.
   * @private
   */
  handleSettingsUpdate(oldSettings) {
    const settings = this.settings;
    this.camera.minRatio = settings.minCameraRatio;
    this.camera.maxRatio = settings.maxCameraRatio;
    this.camera.enabledRotation = settings.enableCameraRotation;
    this.camera.setState(this.camera.validateState(this.camera.getState()));
    if (oldSettings) {
      if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {
        for (const type in settings.edgeProgramClasses) {
          if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {
            this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);
          }
        }
        for (const type in oldSettings.edgeProgramClasses) {
          if (!settings.edgeProgramClasses[type]) this.unregisterEdgeProgram(type);
        }
      }
      if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {
        for (const type in settings.nodeProgramClasses) {
          if (settings.nodeProgramClasses[type] !== oldSettings.nodeProgramClasses[type] || settings.nodeHoverProgramClasses[type] !== oldSettings.nodeHoverProgramClasses[type]) {
            this.registerNodeProgram(type, settings.nodeProgramClasses[type], settings.nodeHoverProgramClasses[type]);
          }
        }
        for (const type in oldSettings.nodeProgramClasses) {
          if (!settings.nodeProgramClasses[type]) this.unregisterNodeProgram(type);
        }
      }
    }
    this.mouseCaptor.setSettings(this.settings);
    this.touchCaptor.setSettings(this.settings);
    return this;
  }
  /**
   * Method used to render labels.
   *
   * @return {Sigma}
   */
  renderLabels() {
    if (!this.settings.renderLabels) return this;
    const cameraState = this.camera.getState();
    const labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);
    extend(labelsToDisplay, this.nodesWithForcedLabels);
    this.displayedNodeLabels = /* @__PURE__ */ new Set();
    const context = this.canvasContexts.labels;
    for (let i2 = 0, l2 = labelsToDisplay.length; i2 < l2; i2++) {
      const node = labelsToDisplay[i2];
      const data = this.nodeDataCache[node];
      if (this.displayedNodeLabels.has(node)) continue;
      if (data.hidden) continue;
      const { x: x2, y: y2 } = this.framedGraphToViewport(data);
      const size = this.scaleSize(data.size);
      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;
      if (x2 < -X_LABEL_MARGIN || x2 > this.width + X_LABEL_MARGIN || y2 < -Y_LABEL_MARGIN || y2 > this.height + Y_LABEL_MARGIN)
        continue;
      this.displayedNodeLabels.add(node);
      const { defaultDrawNodeLabel } = this.settings;
      const nodeProgram = this.nodePrograms[data.type];
      const drawLabel = (nodeProgram == null ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;
      drawLabel(
        context,
        {
          key: node,
          ...data,
          size,
          x: x2,
          y: y2
        },
        this.settings
      );
    }
    return this;
  }
  /**
   * Method used to render edge labels, based on which node labels were
   * rendered.
   *
   * @return {Sigma}
   */
  renderEdgeLabels() {
    if (!this.settings.renderEdgeLabels) return this;
    const context = this.canvasContexts.edgeLabels;
    context.clearRect(0, 0, this.width, this.height);
    const edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({
      graph: this.graph,
      hoveredNode: this.hoveredNode,
      displayedNodeLabels: this.displayedNodeLabels,
      highlightedNodes: this.highlightedNodes
    });
    extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);
    const displayedLabels = /* @__PURE__ */ new Set();
    for (let i2 = 0, l2 = edgeLabelsToDisplay.length; i2 < l2; i2++) {
      const edge = edgeLabelsToDisplay[i2], extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]], edgeData = this.edgeDataCache[edge];
      if (displayedLabels.has(edge)) continue;
      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {
        continue;
      }
      const { defaultDrawEdgeLabel } = this.settings;
      const edgeProgram = this.edgePrograms[edgeData.type];
      const drawLabel = (edgeProgram == null ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;
      drawLabel(
        context,
        {
          key: edge,
          ...edgeData,
          size: this.scaleSize(edgeData.size)
        },
        {
          key: extremities[0],
          ...sourceData,
          ...this.framedGraphToViewport(sourceData),
          size: this.scaleSize(sourceData.size)
        },
        {
          key: extremities[1],
          ...targetData,
          ...this.framedGraphToViewport(targetData),
          size: this.scaleSize(targetData.size)
        },
        this.settings
      );
      displayedLabels.add(edge);
    }
    this.displayedEdgeLabels = displayedLabels;
    return this;
  }
  /**
   * Method used to render the highlighted nodes.
   *
   * @return {Sigma}
   */
  renderHighlightedNodes() {
    const context = this.canvasContexts.hovers;
    context.clearRect(0, 0, this.width, this.height);
    const render = (node) => {
      const data = this.nodeDataCache[node];
      const { x: x2, y: y2 } = this.framedGraphToViewport(data);
      const size = this.scaleSize(data.size);
      const { defaultDrawNodeHover } = this.settings;
      const nodeProgram = this.nodePrograms[data.type];
      const drawHover = (nodeProgram == null ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;
      drawHover(
        context,
        {
          key: node,
          ...data,
          size,
          x: x2,
          y: y2
        },
        this.settings
      );
    };
    const nodesToRender = [];
    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {
      nodesToRender.push(this.hoveredNode);
    }
    this.highlightedNodes.forEach((node) => {
      if (node !== this.hoveredNode) nodesToRender.push(node);
    });
    nodesToRender.forEach((node) => render(node));
    const nodesPerPrograms = {};
    nodesToRender.forEach((node) => {
      const type = this.nodeDataCache[node].type;
      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;
    });
    for (const type in this.nodeHoverPrograms) {
      this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);
      nodesPerPrograms[type] = 0;
    }
    nodesToRender.forEach((node) => {
      const data = this.nodeDataCache[node];
      this.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);
    });
    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);
    const renderParams = this.getRenderParams();
    for (const type in this.nodeHoverPrograms) {
      const program = this.nodeHoverPrograms[type];
      program.render(renderParams);
    }
  }
  /**
   * Method used to schedule a hover render.
   *
   */
  scheduleHighlightedNodesRender() {
    if (this.renderHighlightedNodesFrame || this.renderFrame) return;
    this.renderHighlightedNodesFrame = requestAnimationFrame(() => {
      this.renderHighlightedNodesFrame = null;
      this.renderHighlightedNodes();
      this.renderEdgeLabels();
    });
  }
  /**
   * Method used to render.
   *
   * @return {Sigma}
   */
  render() {
    this.emit("beforeRender");
    const exitRender = () => {
      this.emit("afterRender");
      return this;
    };
    if (this.renderFrame) {
      cancelAnimationFrame(this.renderFrame);
      this.renderFrame = null;
    }
    this.resize();
    if (this.needToProcess) this.process();
    this.needToProcess = false;
    this.clear();
    this.pickingLayers.forEach((layer) => this.resetWebGLTexture(layer));
    if (!this.graph.order) return exitRender();
    const mouseCaptor = this.mouseCaptor;
    const moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;
    const cameraState = this.camera.getState();
    const viewportDimensions = this.getDimensions();
    const graphDimensions = this.getGraphDimensions();
    const padding = this.getStagePadding();
    this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);
    this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);
    this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);
    this.graphToViewportRatio = this.getGraphToViewportRatio();
    const params = this.getRenderParams();
    for (const type in this.nodePrograms) {
      const program = this.nodePrograms[type];
      program.render(params);
    }
    if (!this.settings.hideEdgesOnMove || !moving) {
      for (const type in this.edgePrograms) {
        const program = this.edgePrograms[type];
        program.render(params);
      }
    }
    if (this.settings.hideLabelsOnMove && moving) return exitRender();
    this.renderLabels();
    this.renderEdgeLabels();
    this.renderHighlightedNodes();
    return exitRender();
  }
  /**
   * Add a node in the internal data structures.
   * @private
   * @param key The node's graphology ID
   */
  addNode(key) {
    let attr = Object.assign({}, this.graph.getNodeAttributes(key));
    if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);
    const data = applyNodeDefaults(this.settings, key, attr);
    this.nodeDataCache[key] = data;
    this.nodesWithForcedLabels.delete(key);
    if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);
    this.highlightedNodes.delete(key);
    if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);
    if (this.settings.zIndex) {
      if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;
      if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;
    }
  }
  /**
   * Update a node the internal data structures.
   * @private
   * @param key The node's graphology ID
   */
  updateNode(key) {
    this.addNode(key);
    const data = this.nodeDataCache[key];
    this.normalizationFunction.applyTo(data);
  }
  /**
   * Remove a node from the internal data structures.
   * @private
   * @param key The node's graphology ID
   */
  removeNode(key) {
    delete this.nodeDataCache[key];
    delete this.nodeProgramIndex[key];
    this.highlightedNodes.delete(key);
    if (this.hoveredNode === key) this.hoveredNode = null;
    this.nodesWithForcedLabels.delete(key);
  }
  /**
   * Add an edge into the internal data structures.
   * @private
   * @param key The edge's graphology ID
   */
  addEdge(key) {
    let attr = Object.assign({}, this.graph.getEdgeAttributes(key));
    if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);
    const data = applyEdgeDefaults(this.settings, key, attr);
    this.edgeDataCache[key] = data;
    this.edgesWithForcedLabels.delete(key);
    if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);
    if (this.settings.zIndex) {
      if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;
      if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;
    }
  }
  /**
   * Update an edge in the internal data structures.
   * @private
   * @param key The edge's graphology ID
   */
  updateEdge(key) {
    this.addEdge(key);
  }
  /**
   * Remove an edge from the internal data structures.
   * @private
   * @param key The edge's graphology ID
   */
  removeEdge(key) {
    delete this.edgeDataCache[key];
    delete this.edgeProgramIndex[key];
    if (this.hoveredEdge === key) this.hoveredEdge = null;
    this.edgesWithForcedLabels.delete(key);
  }
  /**
   * Clear all indices related to nodes.
   * @private
   */
  clearNodeIndices() {
    this.labelGrid = new LabelGrid();
    this.nodeExtent = { x: [0, 1], y: [0, 1] };
    this.nodeDataCache = {};
    this.edgeProgramIndex = {};
    this.nodesWithForcedLabels = /* @__PURE__ */ new Set();
    this.nodeZExtent = [Infinity, -Infinity];
  }
  /**
   * Clear all indices related to edges.
   * @private
   */
  clearEdgeIndices() {
    this.edgeDataCache = {};
    this.edgeProgramIndex = {};
    this.edgesWithForcedLabels = /* @__PURE__ */ new Set();
    this.edgeZExtent = [Infinity, -Infinity];
  }
  /**
   * Clear all indices.
   * @private
   */
  clearIndices() {
    this.clearEdgeIndices();
    this.clearNodeIndices();
  }
  /**
   * Clear all graph state related to nodes.
   * @private
   */
  clearNodeState() {
    this.displayedNodeLabels = /* @__PURE__ */ new Set();
    this.highlightedNodes = /* @__PURE__ */ new Set();
    this.hoveredNode = null;
  }
  /**
   * Clear all graph state related to edges.
   * @private
   */
  clearEdgeState() {
    this.displayedEdgeLabels = /* @__PURE__ */ new Set();
    this.highlightedNodes = /* @__PURE__ */ new Set();
    this.hoveredEdge = null;
  }
  /**
   * Clear all graph state.
   * @private
   */
  clearState() {
    this.clearEdgeState();
    this.clearNodeState();
  }
  /**
   * Add the node data to its program.
   * @private
   * @param node The node's graphology ID
   * @param fingerprint A fingerprint used to identity the node with picking
   * @param position The index where to place the node in the program
   */
  addNodeToProgram(node, fingerprint, position) {
    const data = this.nodeDataCache[node];
    const nodeProgram = this.nodePrograms[data.type];
    if (!nodeProgram) throw new Error(`Sigma: could not find a suitable program for node type "${data.type}"!`);
    nodeProgram.process(fingerprint, position, data);
    this.nodeProgramIndex[node] = position;
  }
  /**
   * Add the edge data to its program.
   * @private
   * @param edge The edge's graphology ID
   * @param fingerprint A fingerprint used to identity the edge with picking
   * @param position The index where to place the edge in the program
   */
  addEdgeToProgram(edge, fingerprint, position) {
    const data = this.edgeDataCache[edge];
    const edgeProgram = this.edgePrograms[data.type];
    if (!edgeProgram) throw new Error(`Sigma: could not find a suitable program for edge type "${data.type}"!`);
    const extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]];
    edgeProgram.process(fingerprint, position, sourceData, targetData, data);
    this.edgeProgramIndex[edge] = position;
  }
  /**---------------------------------------------------------------------------
   * Public API.
   **---------------------------------------------------------------------------
   */
  /**
   * Function used to get the render params.
   *
   * @return {RenderParams}
   */
  getRenderParams() {
    return {
      matrix: this.matrix,
      invMatrix: this.invMatrix,
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio,
      zoomRatio: this.camera.ratio,
      cameraAngle: this.camera.angle,
      sizeRatio: 1 / this.scaleSize(),
      correctionRatio: this.correctionRatio,
      downSizingRatio: this.pickingDownSizingRatio,
      minEdgeThickness: this.settings.minEdgeThickness,
      antiAliasingFeather: this.settings.antiAliasingFeather
    };
  }
  /**
   * Function used to retrieve the actual stage padding value.
   *
   * @return {number}
   */
  getStagePadding() {
    const { stagePadding, autoRescale } = this.settings;
    return autoRescale ? stagePadding || 0 : 0;
  }
  /**
   * Function used to create a canvas element.
   *
   * @param {string} id - Context's id.
   * @param options
   * @return {Sigma}
   */
  createCanvas(id, options = {}) {
    if (this.elements[id]) throw new Error(`Sigma: a layer named "${id}" already exists`);
    const canvas = createElement(
      "canvas",
      {
        position: "absolute"
      },
      {
        class: `sigma-${id}`
      }
    );
    if (options.style) Object.assign(canvas.style, options.style);
    this.elements[id] = canvas;
    if ("beforeLayer" in options && options.beforeLayer) {
      this.elements[options.beforeLayer].before(canvas);
    } else if ("afterLayer" in options && options.afterLayer) {
      this.elements[options.afterLayer].after(canvas);
    } else {
      this.container.appendChild(canvas);
    }
    return canvas;
  }
  /**
   * Function used to create a canvas context and add the relevant DOM elements.
   *
   * @param  {string} id - Context's id.
   * @return {Sigma}
   */
  createCanvasContext(id, options = {}) {
    const canvas = this.createCanvas(id, options);
    const contextOptions = {
      preserveDrawingBuffer: false,
      antialias: false
    };
    this.canvasContexts[id] = canvas.getContext("2d", contextOptions);
    return this;
  }
  /**
   * Function used to create a WebGL context and add the relevant DOM
   * elements.
   *
   * @param  {string}  id      - Context's id.
   * @param  {object?} options - #getContext params to override (optional)
   * @return {WebGLRenderingContext}
   */
  createWebGLContext(id, options = {}) {
    const canvas = (options == null ? void 0 : options.canvas) || this.createCanvas(id, options);
    if (options.hidden) canvas.remove();
    const contextOptions = {
      preserveDrawingBuffer: false,
      antialias: false,
      ...options
    };
    let context;
    context = canvas.getContext("webgl2", contextOptions);
    if (!context) context = canvas.getContext("webgl", contextOptions);
    if (!context) context = canvas.getContext("experimental-webgl", contextOptions);
    const gl = context;
    this.webGLContexts[id] = gl;
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    if (options.picking) {
      this.pickingLayers.add(id);
      const newFrameBuffer = gl.createFramebuffer();
      if (!newFrameBuffer) throw new Error(`Sigma: cannot create a new frame buffer for layer ${id}`);
      this.frameBuffers[id] = newFrameBuffer;
    }
    return gl;
  }
  /**
   * Function used to properly kill a canvas layer.
   *
   * @param  {string} id - Layer id.
   * @return {Sigma}
   */
  killLayer(id) {
    var _a;
    const canvas = this.elements[id];
    if (!canvas) throw new Error(`Sigma: cannot kill layer ${id}, which does not exist`);
    if (this.webGLContexts[id]) {
      const gl = this.webGLContexts[id];
      (_a = gl.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
      delete this.webGLContexts[id];
    } else {
      delete this.canvasContexts[id];
    }
    canvas.remove();
    delete this.elements[id];
    return this;
  }
  /**
   * Method returning the renderer's camera.
   *
   * @return {Camera}
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Method setting the renderer's camera.
   *
   * @param  {Camera} camera - New camera.
   * @return {Sigma}
   */
  setCamera(camera) {
    this.unbindCameraHandlers();
    this.camera = camera;
    this.bindCameraHandlers();
  }
  /**
   * Method returning the container DOM element.
   *
   * @return {HTMLElement}
   */
  getContainer() {
    return this.container;
  }
  /**
   * Method returning the renderer's graph.
   *
   * @return {Graph}
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Method used to set the renderer's graph.
   *
   * @return {Graph}
   */
  setGraph(graph) {
    if (graph === this.graph) return;
    this.unbindGraphHandlers();
    if (this.checkEdgesEventsFrame !== null) {
      cancelAnimationFrame(this.checkEdgesEventsFrame);
      this.checkEdgesEventsFrame = null;
    }
    this.graph = graph;
    this.bindGraphHandlers();
    this.refresh();
  }
  /**
   * Method returning the mouse captor.
   *
   * @return {MouseCaptor}
   */
  getMouseCaptor() {
    return this.mouseCaptor;
  }
  /**
   * Method returning the touch captor.
   *
   * @return {TouchCaptor}
   */
  getTouchCaptor() {
    return this.touchCaptor;
  }
  /**
   * Method returning the current renderer's dimensions.
   *
   * @return {Dimensions}
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  /**
   * Method returning the current graph's dimensions.
   *
   * @return {Dimensions}
   */
  getGraphDimensions() {
    const extent = this.customBBox || this.nodeExtent;
    return {
      width: extent.x[1] - extent.x[0] || 1,
      height: extent.y[1] - extent.y[0] || 1
    };
  }
  /**
   * Method used to get all the sigma node attributes.
   * It's useful for example to get the position of a node
   * and to get values that are set by the nodeReducer
   *
   * @param  {string} key - The node's key.
   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found
   */
  getNodeDisplayData(key) {
    const node = this.nodeDataCache[key];
    return node ? Object.assign({}, node) : void 0;
  }
  /**
   * Method used to get all the sigma edge attributes.
   * It's useful for example to get values that are set by the edgeReducer.
   *
   * @param  {string} key - The edge's key.
   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found
   */
  getEdgeDisplayData(key) {
    const edge = this.edgeDataCache[key];
    return edge ? Object.assign({}, edge) : void 0;
  }
  /**
   * Method used to get the set of currently displayed node labels.
   *
   * @return {Set<string>} A set of node keys whose label is displayed.
   */
  getNodeDisplayedLabels() {
    return new Set(this.displayedNodeLabels);
  }
  /**
   * Method used to get the set of currently displayed edge labels.
   *
   * @return {Set<string>} A set of edge keys whose label is displayed.
   */
  getEdgeDisplayedLabels() {
    return new Set(this.displayedEdgeLabels);
  }
  /**
   * Method returning a copy of the settings collection.
   *
   * @return {Settings} A copy of the settings collection.
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Method returning the current value for a given setting key.
   *
   * @param  {string} key - The setting key to get.
   * @return {any} The value attached to this setting key or undefined if not found
   */
  getSetting(key) {
    return this.settings[key];
  }
  /**
   * Method setting the value of a given setting key. Note that this will schedule
   * a new render next frame.
   *
   * @param  {string} key - The setting key to set.
   * @param  {any}    value - The value to set.
   * @return {Sigma}
   */
  setSetting(key, value) {
    const oldValues = { ...this.settings };
    this.settings[key] = value;
    validateSettings(this.settings);
    this.handleSettingsUpdate(oldValues);
    this.scheduleRefresh();
    return this;
  }
  /**
   * Method updating the value of a given setting key using the provided function.
   * Note that this will schedule a new render next frame.
   *
   * @param  {string}   key     - The setting key to set.
   * @param  {function} updater - The update function.
   * @return {Sigma}
   */
  updateSetting(key, updater) {
    this.setSetting(key, updater(this.settings[key]));
    return this;
  }
  /**
   * Method used to resize the renderer.
   *
   * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).
   * @return {Sigma}
   */
  resize(force) {
    const previousWidth = this.width, previousHeight = this.height;
    this.width = this.container.offsetWidth;
    this.height = this.container.offsetHeight;
    this.pixelRatio = getPixelRatio();
    if (this.width === 0) {
      if (this.settings.allowInvalidContainer) this.width = 1;
      else
        throw new Error(
          "Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error."
        );
    }
    if (this.height === 0) {
      if (this.settings.allowInvalidContainer) this.height = 1;
      else
        throw new Error(
          "Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error."
        );
    }
    if (!force && previousWidth === this.width && previousHeight === this.height) return this;
    this.emit("resize");
    for (const id in this.elements) {
      const element = this.elements[id];
      element.style.width = this.width + "px";
      element.style.height = this.height + "px";
    }
    for (const id in this.canvasContexts) {
      this.elements[id].setAttribute("width", this.width * this.pixelRatio + "px");
      this.elements[id].setAttribute("height", this.height * this.pixelRatio + "px");
      if (this.pixelRatio !== 1) this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);
    }
    for (const id in this.webGLContexts) {
      this.elements[id].setAttribute("width", this.width * this.pixelRatio + "px");
      this.elements[id].setAttribute("height", this.height * this.pixelRatio + "px");
      const gl = this.webGLContexts[id];
      gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);
      if (this.pickingLayers.has(id)) {
        const currentTexture = this.textures[id];
        if (currentTexture) gl.deleteTexture(currentTexture);
      }
    }
    return this;
  }
  /**
   * Method used to clear all the canvases.
   *
   * @return {Sigma}
   */
  clear() {
    this.emit("beforeClear");
    this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);
    this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
    this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);
    this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
    this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);
    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);
    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);
    this.emit("afterClear");
    return this;
  }
  /**
   * Method used to refresh, i.e. force the renderer to reprocess graph
   * data and render, but keep the state.
   * - if a partialGraph is provided, we only reprocess those nodes & edges.
   * - if schedule is TRUE, we schedule a render instead of sync render
   * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)
   *
   * @return {Sigma}
   */
  refresh(opts) {
    var _a, _b;
    const skipIndexation = (opts == null ? void 0 : opts.skipIndexation) !== void 0 ? opts == null ? void 0 : opts.skipIndexation : false;
    const schedule = (opts == null ? void 0 : opts.schedule) !== void 0 ? opts.schedule : false;
    const fullRefresh = !opts || !opts.partialGraph;
    if (fullRefresh) {
      this.clearEdgeIndices();
      this.clearNodeIndices();
      this.graph.forEachNode((node) => this.addNode(node));
      this.graph.forEachEdge((edge) => this.addEdge(edge));
    } else {
      const nodes = ((_a = opts.partialGraph) == null ? void 0 : _a.nodes) || [];
      for (let i2 = 0, l2 = (nodes == null ? void 0 : nodes.length) || 0; i2 < l2; i2++) {
        const node = nodes[i2];
        this.updateNode(node);
        if (skipIndexation) {
          const programIndex = this.nodeProgramIndex[node];
          if (programIndex === void 0) throw new Error(`Sigma: node "${node}" can't be repaint`);
          this.addNodeToProgram(node, this.nodeIndices[node], programIndex);
        }
      }
      const edges = ((_b = opts == null ? void 0 : opts.partialGraph) == null ? void 0 : _b.edges) || [];
      for (let i2 = 0, l2 = edges.length; i2 < l2; i2++) {
        const edge = edges[i2];
        this.updateEdge(edge);
        if (skipIndexation) {
          const programIndex = this.edgeProgramIndex[edge];
          if (programIndex === void 0) throw new Error(`Sigma: edge "${edge}" can't be repaint`);
          this.addEdgeToProgram(edge, this.edgeIndices[edge], programIndex);
        }
      }
    }
    if (fullRefresh || !skipIndexation) this.needToProcess = true;
    if (schedule) this.scheduleRender();
    else this.render();
    return this;
  }
  /**
   * Method used to schedule a render at the next available frame.
   * This method can be safely called on a same frame because it basically
   * debounces refresh to the next frame.
   *
   * @return {Sigma}
   */
  scheduleRender() {
    if (!this.renderFrame) {
      this.renderFrame = requestAnimationFrame(() => {
        this.render();
      });
    }
    return this;
  }
  /**
   * Method used to schedule a refresh (i.e. fully reprocess graph data and render)
   * at the next available frame.
   * This method can be safely called on a same frame because it basically
   * debounces refresh to the next frame.
   *
   * @return {Sigma}
   */
  scheduleRefresh(opts) {
    return this.refresh({ ...opts, schedule: true });
  }
  /**
   * Method used to (un)zoom, while preserving the position of a viewport point.
   * Used for instance to zoom "on the mouse cursor".
   *
   * @param viewportTarget
   * @param newRatio
   * @return {CameraState}
   */
  getViewportZoomedState(viewportTarget, newRatio) {
    const { ratio, angle, x: x2, y: y2 } = this.camera.getState();
    const { minCameraRatio, maxCameraRatio } = this.settings;
    if (typeof maxCameraRatio === "number") newRatio = Math.min(newRatio, maxCameraRatio);
    if (typeof minCameraRatio === "number") newRatio = Math.max(newRatio, minCameraRatio);
    const ratioDiff = newRatio / ratio;
    const center = {
      x: this.width / 2,
      y: this.height / 2
    };
    const graphMousePosition = this.viewportToFramedGraph(viewportTarget);
    const graphCenterPosition = this.viewportToFramedGraph(center);
    return {
      angle,
      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x2,
      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y2,
      ratio: newRatio
    };
  }
  /**
   * Method returning the abstract rectangle containing the graph according
   * to the camera's state.
   *
   * @return {object} - The view's rectangle.
   */
  viewRectangle() {
    const p1 = this.viewportToFramedGraph({ x: 0, y: 0 }), p2 = this.viewportToFramedGraph({ x: this.width, y: 0 }), h2 = this.viewportToFramedGraph({ x: 0, y: this.height });
    return {
      x1: p1.x,
      y1: p1.y,
      x2: p2.x,
      y2: p2.y,
      height: p2.y - h2.y
    };
  }
  /**
   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows
   * overriding anything that is used to get the translation matrix, or even the matrix itself.
   *
   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
   * of computations.
   */
  framedGraphToViewport(coordinates, override = {}) {
    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;
    const matrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(
      override.cameraState || this.camera.getState(),
      override.viewportDimensions || this.getDimensions(),
      override.graphDimensions || this.getGraphDimensions(),
      override.padding || this.getStagePadding()
    ) : this.matrix;
    const viewportPos = multiplyVec2(matrix, coordinates);
    return {
      x: (1 + viewportPos.x) * this.width / 2,
      y: (1 - viewportPos.y) * this.height / 2
    };
  }
  /**
   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows
   * overriding anything that is used to get the translation matrix, or even the matrix itself.
   *
   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
   * of computations.
   */
  viewportToFramedGraph(coordinates, override = {}) {
    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;
    const invMatrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(
      override.cameraState || this.camera.getState(),
      override.viewportDimensions || this.getDimensions(),
      override.graphDimensions || this.getGraphDimensions(),
      override.padding || this.getStagePadding(),
      true
    ) : this.invMatrix;
    const res = multiplyVec2(invMatrix, {
      x: coordinates.x / this.width * 2 - 1,
      y: 1 - coordinates.y / this.height * 2
    });
    if (isNaN(res.x)) res.x = 0;
    if (isNaN(res.y)) res.y = 0;
    return res;
  }
  /**
   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the
   * stage) to the graph system (the reference system of data as they are in the given graph instance).
   *
   * This method accepts an optional camera which can be useful if you need to translate coordinates
   * based on a different view than the one being currently being displayed on screen.
   *
   * @param {Coordinates}                  viewportPoint
   * @param {CoordinateConversionOverride} override
   */
  viewportToGraph(viewportPoint, override = {}) {
    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));
  }
  /**
   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in
   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).
   *
   * This method accepts an optional camera which can be useful if you need to translate coordinates
   * based on a different view than the one being currently being displayed on screen.
   *
   * @param {Coordinates}                  graphPoint
   * @param {CoordinateConversionOverride} override
   */
  graphToViewport(graphPoint, override = {}) {
    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);
  }
  /**
   * Method returning the distance multiplier between the graph system and the
   * viewport system.
   */
  getGraphToViewportRatio() {
    const graphP1 = { x: 0, y: 0 };
    const graphP2 = { x: 1, y: 1 };
    const graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));
    const viewportP1 = this.graphToViewport(graphP1);
    const viewportP2 = this.graphToViewport(graphP2);
    const viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));
    return viewportD / graphD;
  }
  /**
   * Method returning the graph's bounding box.
   *
   * @return {{ x: Extent, y: Extent }}
   */
  getBBox() {
    return this.nodeExtent;
  }
  /**
   * Method returning the graph's custom bounding box, if any.
   *
   * @return {{ x: Extent, y: Extent } | null}
   */
  getCustomBBox() {
    return this.customBBox;
  }
  /**
   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.
   *
   * @return {Sigma}
   */
  setCustomBBox(customBBox) {
    this.customBBox = customBBox;
    this.scheduleRender();
    return this;
  }
  /**
   * Method used to shut the container & release event listeners.
   *
   * @return {undefined}
   */
  kill() {
    this.emit("kill");
    this.removeAllListeners();
    this.unbindCameraHandlers();
    window.removeEventListener("resize", this.activeListeners.handleResize);
    this.mouseCaptor.kill();
    this.touchCaptor.kill();
    this.unbindGraphHandlers();
    this.clearIndices();
    this.clearState();
    this.nodeDataCache = {};
    this.edgeDataCache = {};
    this.highlightedNodes.clear();
    if (this.renderFrame) {
      cancelAnimationFrame(this.renderFrame);
      this.renderFrame = null;
    }
    if (this.renderHighlightedNodesFrame) {
      cancelAnimationFrame(this.renderHighlightedNodesFrame);
      this.renderHighlightedNodesFrame = null;
    }
    const container = this.container;
    while (container.firstChild) container.removeChild(container.firstChild);
    this.canvasContexts = {};
    this.webGLContexts = {};
    this.elements = {};
    for (const type in this.nodePrograms) {
      this.nodePrograms[type].kill();
    }
    for (const type in this.nodeHoverPrograms) {
      this.nodeHoverPrograms[type].kill();
    }
    for (const type in this.edgePrograms) {
      this.edgePrograms[type].kill();
    }
    this.nodePrograms = {};
    this.nodeHoverPrograms = {};
    this.edgePrograms = {};
    for (const id in this.elements) {
      this.killLayer(id);
    }
  }
  /**
   * Method used to scale the given size according to the camera's ratio, i.e.
   * zooming state.
   *
   * @param  {number?} size -        The size to scale (node size, edge thickness etc.).
   * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).
   * @return {number}              - The scaled size.
   */
  scaleSize(size = 1, cameraRatio = this.camera.ratio) {
    return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting("itemSizesReference") === "positions" ? cameraRatio * this.graphToViewportRatio : 1);
  }
  /**
   * Method that returns the collection of all used canvases.
   * At the moment, the instantiated canvases are the following, and in the
   * following order in the DOM:
   * - `edges`
   * - `nodes`
   * - `edgeLabels`
   * - `labels`
   * - `hovers`
   * - `hoverNodes`
   * - `mouse`
   *
   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.
   */
  getCanvases() {
    return { ...this.elements };
  }
};

// ../../node_modules/@react-sigma/core/lib/react-sigma_core.esm.min.js
var m = (0, import_react.createContext)(null);
var h = m.Provider;
function f() {
  const e2 = (0, import_react.useContext)(m);
  if (null == e2) throw new Error("No context provided: useSigmaContext() can only be used in a descendant of <SigmaContainer>");
  return e2;
}
function v() {
  return f().sigma;
}
function p() {
  const { sigma: e2 } = f();
  return (0, import_react.useCallback)((t2) => {
    e2 && Object.keys(t2).forEach((n2) => {
      e2.setSetting(n2, t2[n2]);
    });
  }, [e2]);
}
function b(e2) {
  return new Set(Object.keys(e2));
}
var w = b({ clickNode: true, rightClickNode: true, downNode: true, enterNode: true, leaveNode: true, doubleClickNode: true, wheelNode: true, clickEdge: true, rightClickEdge: true, downEdge: true, enterEdge: true, leaveEdge: true, doubleClickEdge: true, wheelEdge: true, clickStage: true, rightClickStage: true, downStage: true, doubleClickStage: true, wheelStage: true, beforeRender: true, afterRender: true, kill: true, upStage: true, upEdge: true, upNode: true, enterStage: true, leaveStage: true, resize: true, afterClear: true, afterProcess: true, beforeClear: true, beforeProcess: true });
var E = b({ click: true, rightClick: true, doubleClick: true, mouseup: true, mousedown: true, mousemove: true, mousemovebody: true, mouseleave: true, mouseenter: true, wheel: true });
var O = b({ touchup: true, touchdown: true, touchmove: true });
var y = b({ updated: true });
function _() {
  const e2 = v(), t2 = p(), [n2, r2] = (0, import_react.useState)({});
  return (0, import_react.useEffect)(() => {
    if (!e2 || !n2) return;
    const t3 = n2, r3 = Object.keys(t3);
    return r3.forEach((n3) => {
      const r4 = t3[n3];
      w.has(n3) && e2.on(n3, r4), E.has(n3) && e2.getMouseCaptor().on(n3, r4), O.has(n3) && e2.getTouchCaptor().on(n3, r4), y.has(n3) && e2.getCamera().on(n3, r4);
    }), () => {
      e2 && r3.forEach((n3) => {
        const r4 = t3[n3];
        w.has(n3) && e2.off(n3, r4), E.has(n3) && e2.getMouseCaptor().off(n3, r4), O.has(n3) && e2.getTouchCaptor().off(n3, r4), y.has(n3) && e2.getCamera().off(n3, r4);
      });
    };
  }, [e2, n2, t2]), r2;
}
function j() {
  const e2 = v();
  return (0, import_react.useCallback)((t2, n2 = true) => {
    e2 && t2 && (n2 && e2.getGraph().order > 0 && e2.getGraph().clear(), e2.getGraph().import(t2), e2.refresh());
  }, [e2]);
}
function C() {
  return Math.random().toString(36).slice(2);
}
function N(e2, t2) {
  if (e2 === t2) return true;
  if ("object" == typeof e2 && null != e2 && "object" == typeof t2 && null != t2) {
    if (Object.keys(e2).length != Object.keys(t2).length) return false;
    for (const n2 in e2) {
      if (!Object.hasOwn(t2, n2)) return false;
      if (!N(e2[n2], t2[n2])) return false;
    }
    return true;
  }
  return false;
}
function x(e2) {
  const t2 = v(), [n2, r2] = (0, import_react.useState)(e2 || {});
  (0, import_react.useEffect)(() => {
    N(n2, e2 || {}) || r2(e2 || {});
  }, [e2]);
  const o2 = (0, import_react.useCallback)((e3) => {
    t2.getCamera().animatedZoom(Object.assign(Object.assign({}, n2), e3));
  }, [t2, n2]), s2 = (0, import_react.useCallback)((e3) => {
    t2.getCamera().animatedUnzoom(Object.assign(Object.assign({}, n2), e3));
  }, [t2, n2]), i2 = (0, import_react.useCallback)((e3) => {
    t2.getCamera().animatedReset(Object.assign(Object.assign({}, n2), e3));
  }, [t2, n2]), u2 = (0, import_react.useCallback)((e3, r3) => {
    t2.getCamera().animate(e3, Object.assign(Object.assign({}, n2), r3));
  }, [t2, n2]), d = (0, import_react.useCallback)((e3, r3) => {
    const a2 = t2.getNodeDisplayData(e3);
    a2 ? t2.getCamera().animate(a2, Object.assign(Object.assign({}, n2), r3)) : console.log(`Node ${e3} not found`);
  }, [t2, n2]);
  return { zoomIn: o2, zoomOut: s2, reset: i2, goto: u2, gotoNode: d };
}
function k(e2) {
  const t2 = f(), [n2, r2] = (0, import_react.useState)(false), [o2, s2] = (0, import_react.useState)(e2 || t2.container), i2 = () => r2((e3) => !e3);
  (0, import_react.useEffect)(() => (document.addEventListener("fullscreenchange", i2), () => document.removeEventListener("fullscreenchange", i2)), [i2]), (0, import_react.useEffect)(() => {
    s2(e2 || t2.container);
  }, [e2, t2.container]);
  return { toggle: (0, import_react.useCallback)(() => {
    var e3;
    e3 = o2, document.fullscreenElement !== e3 ? e3.requestFullscreen() : document.exitFullscreen && document.exitFullscreen();
  }, [o2]), isFullScreen: n2 };
}
var S = (0, import_react.forwardRef)(({ graph: e2, id: n2, className: r2, style: a2, settings: o2 = {}, children: m2 }, f2) => {
  const v2 = (0, import_react.useRef)(null), p2 = (0, import_react.useRef)(null), b2 = { className: `react-sigma ${r2 || ""}`, id: n2, style: a2 }, [w2, E2] = (0, import_react.useState)(null), [O2, y2] = (0, import_react.useState)(o2);
  (0, import_react.useEffect)(() => {
    N(O2, o2) || y2(o2);
  }, [o2]), (0, import_react.useEffect)(() => {
    let t2 = null;
    if (null !== p2.current) {
      let n3 = new Graph();
      e2 && (n3 = "function" == typeof e2 ? new e2() : e2), t2 = new Sigma(n3, p2.current, O2), w2 && t2.getCamera().setState(w2.getCamera().getState());
    }
    return E2(t2), () => {
      t2 && t2.kill(), E2(null);
    };
  }, [p2, e2, O2]), (0, import_react.useImperativeHandle)(f2, () => w2, [w2]);
  const _2 = (0, import_react.useMemo)(() => w2 && v2.current ? { sigma: w2, container: v2.current } : null, [w2, v2.current]), j2 = null !== _2 ? import_react.default.createElement(h, { value: _2 }, m2) : null;
  return import_react.default.createElement("div", Object.assign({}, b2, { ref: v2 }), import_react.default.createElement("div", { className: "sigma-container", ref: p2 }), j2);
});
var H = ({ id: e2, className: n2, style: r2, children: a2, position: c2 = "bottom-left" }) => {
  const l2 = { className: `react-sigma-controls ${n2 || ""} ${c2}`, id: e2, style: r2 };
  return import_react.default.createElement("div", Object.assign({}, l2), a2);
};
var M;
function $() {
  return $ = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }, $.apply(this, arguments);
}
var z;
var P = function(t2) {
  return e.createElement("svg", $({ xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", className: "plus-solid_svg__svg-inline--fa plus-solid_svg__fa-plus plus-solid_svg__fa-w-14", "data-icon": "plus", "data-prefix": "fas", viewBox: "0 0 448 512", width: "1em", height: "1em" }, t2), M || (M = e.createElement("path", { fill: "currentColor", d: "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32" })));
};
function V() {
  return V = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }, V.apply(this, arguments);
}
var F;
var G = function(t2) {
  return e.createElement("svg", V({ xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", className: "minus-solid_svg__svg-inline--fa minus-solid_svg__fa-minus minus-solid_svg__fa-w-14", "data-icon": "minus", "data-prefix": "fas", viewBox: "0 0 448 512", width: "1em", height: "1em" }, t2), z || (z = e.createElement("path", { fill: "currentColor", d: "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32" })));
};
function B() {
  return B = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }, B.apply(this, arguments);
}
var I = function(t2) {
  return e.createElement("svg", B({ xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", className: "dot-circle-regular_svg__svg-inline--fa dot-circle-regular_svg__fa-dot-circle dot-circle-regular_svg__fa-w-16", "data-icon": "dot-circle", "data-prefix": "far", viewBox: "0 0 512 512", width: "1em", height: "1em" }, t2), F || (F = e.createElement("path", { fill: "currentColor", d: "M256 56c110.532 0 200 89.451 200 200 0 110.532-89.451 200-200 200-110.532 0-200-89.451-200-200 0-110.532 89.451-200 200-200m0-48C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8m0 168c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80" })));
};
var L = ({ className: e2, style: n2, animationDuration: r2 = 200, children: a2, labels: c2 = {} }) => {
  const { zoomIn: l2, zoomOut: o2, reset: s2 } = x({ duration: r2, factor: 1.5 }), i2 = { style: n2, className: `react-sigma-control ${e2 || ""}` };
  return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("div", Object.assign({}, i2), import_react.default.createElement("button", { onClick: () => l2(), title: c2.zoomIn || "Zoom In" }, a2 ? a2[0] : import_react.default.createElement(P, { style: { width: "1em" } }))), import_react.default.createElement("div", Object.assign({}, i2), import_react.default.createElement("button", { onClick: () => o2(), title: c2.zoomOut || "Zoom Out" }, a2 ? a2[1] : import_react.default.createElement(G, { style: { width: "1em" } }))), import_react.default.createElement("div", Object.assign({}, i2), import_react.default.createElement("button", { onClick: () => s2(), title: c2.reset || "See whole graph" }, a2 ? a2[2] : import_react.default.createElement(I, { style: { width: "1em" } }))));
};
var D;
function R() {
  return R = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }, R.apply(this, arguments);
}
var Z;
var A = function(t2) {
  return e.createElement("svg", R({ xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", className: "expand-solid_svg__svg-inline--fa expand-solid_svg__fa-expand expand-solid_svg__fa-w-14", "data-icon": "expand", "data-prefix": "fas", viewBox: "0 0 448 512", width: "1em", height: "1em" }, t2), D || (D = e.createElement("path", { fill: "currentColor", d: "M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12M288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12m148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12M160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12" })));
};
function T() {
  return T = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }, T.apply(this, arguments);
}
var q = function(t2) {
  return e.createElement("svg", T({ xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", className: "compress-solid_svg__svg-inline--fa compress-solid_svg__fa-compress compress-solid_svg__fa-w-14", "data-icon": "compress", "data-prefix": "fas", viewBox: "0 0 448 512", width: "1em", height: "1em" }, t2), Z || (Z = e.createElement("path", { fill: "currentColor", d: "M436 192H312c-13.3 0-24-10.7-24-24V44c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v84h84c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12m-276-24V44c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v84H12c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24m0 300V344c0-13.3-10.7-24-24-24H12c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12m192 0v-84h84c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12H312c-13.3 0-24 10.7-24 24v124c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12" })));
};
var U = ({ id: e2, className: n2, style: r2, container: a2, children: c2, labels: l2 = {} }) => {
  const { isFullScreen: o2, toggle: s2 } = k(null == a2 ? void 0 : a2.current), i2 = { className: `react-sigma-control ${n2 || ""}`, id: e2, style: r2 };
  return document.fullscreenEnabled ? import_react.default.createElement("div", Object.assign({}, i2), import_react.default.createElement("button", { onClick: s2, title: o2 ? l2.exit || "Exit fullscreen" : l2.enter || "Enter fullscreen" }, c2 && !o2 && c2[0], c2 && o2 && c2[1], !c2 && !o2 && import_react.default.createElement(A, { style: { width: "1em" } }), !c2 && o2 && import_react.default.createElement(q, { style: { width: "1em" } }))) : null;
};
var J = ({ id: e2, className: n2, style: r2, labels: a2 = {} }) => {
  const o2 = v(), s2 = _(), { gotoNode: i2 } = x(), [u2, d] = (0, import_react.useState)(""), [g, m2] = (0, import_react.useState)([]), [h2, f2] = (0, import_react.useState)(null), [p2, b2] = (0, import_react.useState)("");
  (0, import_react.useEffect)(() => {
    b2(`search-${C()}`);
  }, []), (0, import_react.useEffect)(() => {
    const e3 = [];
    !h2 && u2.length > 1 && o2.getGraph().forEachNode((t2, n3) => {
      n3.label && n3.label.toLowerCase().includes(u2.toLowerCase()) && e3.push({ id: t2, label: n3.label });
    }), m2(e3);
  }, [u2]), (0, import_react.useEffect)(() => {
    s2({ clickStage: () => {
      f2(null), d("");
    } });
  }, [s2]), (0, import_react.useEffect)(() => {
    if (h2) return o2.getGraph().setNodeAttribute(h2, "highlighted", true), i2(h2), () => {
      o2.getGraph().setNodeAttribute(h2, "highlighted", false);
    };
  }, [h2]);
  const w2 = { className: `react-sigma-search ${n2 || ""}`, id: e2, style: r2 };
  return import_react.default.createElement("div", Object.assign({}, w2), import_react.default.createElement("label", { htmlFor: p2, style: { display: "none" } }, a2.text || "Search a node"), import_react.default.createElement("input", { id: p2, type: "text", placeholder: a2.placeholder || "Search...", list: `${p2}-datalist`, value: u2, onChange: (e3) => {
    const t2 = e3.target.value, n3 = g.find((e4) => e4.label === t2);
    n3 ? (d(n3.label), m2([]), f2(n3.id)) : (f2(null), d(t2));
  } }), import_react.default.createElement("datalist", { id: `${p2}-datalist` }, g.map((e3) => import_react.default.createElement("option", { key: e3.id, value: e3.label }, e3.label))));
};
export {
  H as ControlsContainer,
  U as FullScreenControl,
  J as SearchControl,
  S as SigmaContainer,
  m as SigmaContext,
  h as SigmaProvider,
  L as ZoomControl,
  C as getUniqueKey,
  N as isEqual,
  x as useCamera,
  k as useFullScreen,
  j as useLoadGraph,
  _ as useRegisterEvents,
  p as useSetSettings,
  v as useSigma,
  f as useSigmaContext
};
//# sourceMappingURL=@react-sigma_core.js.map
